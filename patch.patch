diff --git a/bundle.json b/bundle.json
index c683631..a7731ed 100644
--- a/bundle.json
+++ b/bundle.json
@@ -55,6 +55,7 @@
           "init",
           "ipc",
           "kv_store",
+          "libexif",
           "memory_utils",
           "memmgr",
           "image_framework",
diff --git a/frameworks/innerkitsimpl/media_library_helper/include/medialibrary_operation.h b/frameworks/innerkitsimpl/media_library_helper/include/medialibrary_operation.h
index ed488bc..a8b1edf 100644
--- a/frameworks/innerkitsimpl/media_library_helper/include/medialibrary_operation.h
+++ b/frameworks/innerkitsimpl/media_library_helper/include/medialibrary_operation.h
@@ -86,6 +86,8 @@ enum class EXPORT OperationObject : uint32_t {
     PAH_BATCH_THUMBNAIL_OPERATE,
     APP_URI_PERMISSION_INNER,
     MEDIA_APP_URI_PERMISSION,
+    REQUEST_PICTURE,
+    PHOTO_REQUEST_PICTURE_BUFFER,
 };
 
 enum class EXPORT OperationType : uint32_t {
@@ -147,6 +149,8 @@ enum class EXPORT OperationType : uint32_t {
     START_GENERATE_THUMBNAILS,
     STOP_GENERATE_THUMBNAILS,
     TOOL_QUERY_BY_DISPLAY_NAME,
+    ADD_LOWQUALITY_IMAGE,
+    FINISH_REQUEST_PICTURE,
     SCAN_WITHOUT_ALBUM_UPDATE,
 };
 
diff --git a/frameworks/innerkitsimpl/media_library_helper/src/media_change_effect.cpp b/frameworks/innerkitsimpl/media_library_helper/src/media_change_effect.cpp
index 1fc5426..fcbcabf 100644
--- a/frameworks/innerkitsimpl/media_library_helper/src/media_change_effect.cpp
+++ b/frameworks/innerkitsimpl/media_library_helper/src/media_change_effect.cpp
@@ -55,6 +55,28 @@ int32_t MediaChangeEffect::TakeEffect(const string &inputPath, const string &out
 #endif
     return 0;
 }
+
+int32_t MediaChangeEffect::TakeEffectForPicture(std::shared_ptr<Media::Picture>& inPicture, string &editData)
+{
+#ifdef IMAGE_EFFECT_SUPPORT
+    Effect::ErrorCode ret = Effect::ErrorCode::ERR_UNKNOWN;
+    std::shared_ptr<Effect::ImageEffect> imageEffect = Effect::ImageEffect::Restore(editData);
+    if (imageEffect == nullptr) {
+        return ParseInt(ret);
+    }
+
+    ret = imageEffect->SetInputPicture(inPicture.get()); // 原图修改
+    if (ret != Effect::ErrorCode::SUCCESS) {
+        return ParseInt(ret);
+    }
+
+    ret = imageEffect->Start();
+    if (ret != Effect::ErrorCode::SUCCESS) {
+        return ParseInt(ret);
+    }
+#endif
+    return 0;
+}
  
 } // end of namespace
-}
\ No newline at end of file
+}
diff --git a/frameworks/innerkitsimpl/media_library_helper/src/media_column.cpp b/frameworks/innerkitsimpl/media_library_helper/src/media_column.cpp
index 3dfcb19..e60974e 100644
--- a/frameworks/innerkitsimpl/media_library_helper/src/media_column.cpp
+++ b/frameworks/innerkitsimpl/media_library_helper/src/media_column.cpp
@@ -128,6 +128,12 @@ const std::string PhotoColumn::HIGHTLIGHT_COVER_URI = "/highlight";
 
 const std::string PhotoColumn::PHOTO_CLOUD_URI_PREFIX = "file://cloudsync/Photo/";
 
+const std::string PhotoColumn::PHOTO_HEIGHT_ERROR_URI_PREFIX = "file://cloudsync/Photo/HeightError/";
+const std::string PhotoColumn::PHOTO_DOWNLOAD_SUCCEED_URI_PREFIX = "file://cloudsync/Photo/DownloadSucceed/";
+
+const std::string PhotoColumn::PHOTO_REQUEST_PICTURE = "file://media/Photo/picture/";
+const std::string PhotoColumn::PHOTO_REQUEST_PICTURE_BUFFER = "file://media/Photo/pictureBuffer/";
+
 const std::set<std::string> PhotoColumn::DEFAULT_FETCH_COLUMNS = {
     PHOTO_SUBTYPE, PHOTO_BURST_KEY,
 };
diff --git a/frameworks/innerkitsimpl/media_library_helper/src/media_photo_asset_proxy.cpp b/frameworks/innerkitsimpl/media_library_helper/src/media_photo_asset_proxy.cpp
index b6994b2..6fd8731 100644
--- a/frameworks/innerkitsimpl/media_library_helper/src/media_photo_asset_proxy.cpp
+++ b/frameworks/innerkitsimpl/media_library_helper/src/media_photo_asset_proxy.cpp
@@ -15,6 +15,10 @@
 
 #define MLOG_TAG "PhotoAssetProxy"
 
+#include <cstdint>
+#include <string>
+#include <sstream>
+
 #include "media_photo_asset_proxy.h"
 
 #include "datashare_abs_result_set.h"
@@ -37,6 +41,7 @@ using namespace std;
 namespace OHOS {
 namespace Media {
 const string API_VERSION = "api_version";
+const string SAVE_PICTURE = "save_picture";
 const double TIMER_MULTIPLIER = 60.0;
 const int32_t BURST_COVER = 1;
 const int32_t BURST_MEMBER = 2;
@@ -332,6 +337,9 @@ int32_t PhotoAssetProxy::UpdatePhotoQuality(shared_ptr<DataShare::DataShareHelpe
 {
     string uri = PAH_ADD_IMAGE;
     MediaFileUtils::UriAppendKeyValue(uri, API_VERSION, to_string(MEDIA_API_VERSION_V10));
+    if (photoProxy->GetFormat() == PhotoFormat::YUV || photoProxy->GetFormat() == PhotoFormat::HEIF) {
+        MediaFileUtils::UriAppendKeyValue(uri, SAVE_PICTURE, OPRN_ADD_LOWQUALITY_IMAGE);
+    }
     Uri updateAssetUri(uri);
     DataShare::DataSharePredicates predicates;
     predicates.SetWhereClause(MediaColumn::MEDIA_ID + " = ? ");
@@ -342,6 +350,7 @@ int32_t PhotoAssetProxy::UpdatePhotoQuality(shared_ptr<DataShare::DataShareHelpe
     valuesBucket.Put(PhotoColumn::PHOTO_DEFERRED_PROC_TYPE, static_cast<int32_t>(photoProxy->GetDeferredProcType()));
     valuesBucket.Put(MediaColumn::MEDIA_ID, fileId);
     valuesBucket.Put(PhotoColumn::PHOTO_SUBTYPE, static_cast<int32_t>(subType));
+    valuesBucket.Put(PhotoColumn::PHOTO_QUALITY, static_cast<int32_t>(photoProxy->GetPhotoQuality()));
 
     int32_t changeRows = dataShareHelper->Update(updateAssetUri, predicates, valuesBucket);
     if (changeRows < 0) {
@@ -351,6 +360,35 @@ int32_t PhotoAssetProxy::UpdatePhotoQuality(shared_ptr<DataShare::DataShareHelpe
     return changeRows;
 }
 
+int PhotoAssetProxy::SaveLowQualityPhoto(std::shared_ptr<DataShare::DataShareHelper>  &dataShareHelper,
+    const sptr<PhotoProxy> &photoProxy, int32_t fileId, int32_t subType)
+{
+    MediaLibraryTracer tracer;
+    tracer.Start("SaveLowQualityPhoto");
+    string uri = PAH_ADD_LOWQUALITY_IMAGE;
+    MediaFileUtils::UriAppendKeyValue(uri, API_VERSION, to_string(MEDIA_API_VERSION_V10));
+    Uri updateAssetUri(uri);
+    DataShare::DataSharePredicates predicates;
+    predicates.SetWhereClause(MediaColumn::MEDIA_ID + " = ? ");
+    predicates.SetWhereArgs({ to_string(fileId) });
+ 
+    DataShare::DataShareValuesBucket valuesBucket;
+    valuesBucket.Put(PhotoColumn::PHOTO_ID, photoProxy->GetPhotoId());
+    valuesBucket.Put(PhotoColumn::PHOTO_DEFERRED_PROC_TYPE, static_cast<int32_t>(photoProxy->GetDeferredProcType()));
+    valuesBucket.Put(MediaColumn::MEDIA_ID, fileId);
+    valuesBucket.Put(PhotoColumn::PHOTO_SUBTYPE, static_cast<int32_t>(subType));
+    valuesBucket.Put(PhotoColumn::PHOTO_LATITUDE, photoProxy->GetLatitude());
+    valuesBucket.Put(PhotoColumn::PHOTO_LONGITUDE, photoProxy->GetLongitude());
+ 
+    int32_t changeRows = dataShareHelper->Update(updateAssetUri, predicates, valuesBucket);
+    if (changeRows < 0) {
+        MEDIA_ERR_LOG("update fail, error: %{public}d", changeRows);
+    }
+    MEDIA_INFO_LOG("photoId: %{public}s,", photoProxy->GetPhotoId().c_str());
+    photoProxy->Release();
+    return E_OK;
+}
+
 void PhotoAssetProxy::DealWithLowQualityPhoto(shared_ptr<DataShare::DataShareHelper> &dataShareHelper,
     int fd, const string &uri, const sptr<PhotoProxy> &photoProxy)
 {
@@ -385,8 +423,11 @@ void PhotoAssetProxy::AddPhotoProxy(const sptr<PhotoProxy> &photoProxy)
     if (cameraShotType_ == CameraShotType::VIDEO) {
         return;
     }
-    if (photoProxy->GetPhotoQuality() == PhotoQuality::LOW) {
-        UpdatePhotoQuality(dataShareHelper_, photoProxy, fileId_, static_cast<int32_t>(subType_));
+    UpdatePhotoQuality(dataShareHelper_, photoProxy, fileId_, static_cast<int32_t>(subType_));
+    if (photoProxy->GetFormat() == PhotoFormat::YUV || photoProxy->GetFormat() == PhotoFormat::HEIF) {
+        photoProxy->Release();
+        tracer.Finish();
+        return;
     }
     tracer.Finish();
 
diff --git a/frameworks/innerkitsimpl/media_library_helper/src/medialibrary_operation.cpp b/frameworks/innerkitsimpl/media_library_helper/src/medialibrary_operation.cpp
index af8e8ea..729b0e2 100644
--- a/frameworks/innerkitsimpl/media_library_helper/src/medialibrary_operation.cpp
+++ b/frameworks/innerkitsimpl/media_library_helper/src/medialibrary_operation.cpp
@@ -272,6 +272,8 @@ const std::map<std::string, OperationType>& GetOprnTypeMap()
         { OPRN_START_GENERATE_THUMBNAILS, OperationType::START_GENERATE_THUMBNAILS },
         { OPRN_STOP_GENERATE_THUMBNAILS, OperationType::STOP_GENERATE_THUMBNAILS },
         { OPRN_TOOL_QUERY_BY_DISPLAY_NAME, OperationType::TOOL_QUERY_BY_DISPLAY_NAME },
+        { OPRN_ADD_LOWQUALITY_IMAGE, OperationType::ADD_LOWQUALITY_IMAGE },
+        { OPRN_FINISH_REQUEST_PICTURE, OperationType::FINISH_REQUEST_PICTURE },
         { OPRN_SCAN_WITHOUT_ALBUM_UPDATE, OperationType::SCAN_WITHOUT_ALBUM_UPDATE },
     };
     return oprnTypeMap;
diff --git a/frameworks/innerkitsimpl/medialibrary_data_extension/BUILD.gn b/frameworks/innerkitsimpl/medialibrary_data_extension/BUILD.gn
index 05fa66e..48487a6 100644
--- a/frameworks/innerkitsimpl/medialibrary_data_extension/BUILD.gn
+++ b/frameworks/innerkitsimpl/medialibrary_data_extension/BUILD.gn
@@ -70,12 +70,12 @@ config("media_data_extension_public_config") {
     "-fvisibility=hidden",
     "-fdata-sections",
     "-ffunction-sections",
-    "-Os",
+    "-O2",
   ]
 
   cflags_cc = [
     "-fvisibility-inlines-hidden",
-    "-Os",
+    "-O2",
   ]
 
   if (target_cpu == "arm") {
@@ -226,6 +226,7 @@ ohos_shared_library("medialibrary_data_extension") {
     "src/medialibrary_notify.cpp",
     "src/medialibrary_object_utils.cpp",
     "src/medialibrary_photo_operations.cpp",
+    "src/picture_handle_service.cpp",
     "src/medialibrary_rdbstore.cpp",
     "src/medialibrary_restore.cpp",
     "src/medialibrary_search_operations.cpp",
@@ -236,6 +237,8 @@ ohos_shared_library("medialibrary_data_extension") {
     "src/medialibrary_uripermission_operations.cpp",
     "src/medialibrary_vision_operations.cpp",
     "src/photo_map_operations.cpp",
+    "src/picture_data_operations.cpp",
+    "src/picture_manager_thread.cpp",
     "src/trash_async_worker.cpp",
   ]
   sources += media_scan_source
@@ -293,6 +296,7 @@ ohos_shared_library("medialibrary_data_extension") {
     "ipc:ipc_core",
     "ipc:ipc_single",
     "kv_store:distributeddata_inner",
+    "libexif:libexif",
     "napi:ace_napi",
     "os_account:os_account_innerkits",
     "player_framework:media_client",
diff --git a/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_photo_operations.h b/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_photo_operations.h
index 84fe8cb..0466a90 100644
--- a/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_photo_operations.h
+++ b/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_photo_operations.h
@@ -25,6 +25,7 @@
 #include "file_asset.h"
 #include "medialibrary_asset_operations.h"
 #include "medialibrary_command.h"
+#include "picture.h"
 
 namespace OHOS {
 namespace Media {
@@ -50,7 +51,16 @@ public:
     EXPORT static void StoreThumbnailSize(const std::string& photoId, const std::string& photoPath);
     EXPORT static void DropThumbnailSize(const std::string& photoId);
     EXPORT static int32_t ScanFileWithoutAlbumUpdate(MediaLibraryCommand &cmd);
-
+    EXPORT static int32_t ProcessMultistagesPhotoForPicture(bool isEdited, const std::string &path,
+        std::shared_ptr<Media::Picture> &picture, int32_t fileId, const std::string &mime_type);
+    EXPORT static int32_t Save(bool isEdited, const std::string &path,
+        const uint8_t *addr, const long bytes, int32_t fileId);
+    EXPORT static int32_t AddFiltersToPicture(std::shared_ptr<Media::Picture>& inPicture,
+        const std::string &outputPath, std::string &editdata, const std::string &mime_type);
+    EXPORT static int32_t SavePicture(const int32_t &fileType, const std::shared_ptr<FileAsset> &fileAsset);
+    EXPORT static int32_t GetPicture(const int32_t &fileId, std::shared_ptr<Media::Picture> &picture,
+        bool isCleanImmediately, std::string &photoId);
+    EXPORT static int32_t FinishRequestPicture(MediaLibraryCommand &cmd);
 private:
     static int32_t CreateV9(MediaLibraryCommand &cmd);
     static int32_t CreateV10(MediaLibraryCommand &cmd);
@@ -98,6 +108,10 @@ private:
     static bool IsNeedRevertEffectMode(MediaLibraryCommand& cmd, const std::shared_ptr<FileAsset>& fileAsset,
         int32_t& effectMode);
     static int32_t SaveCameraPhoto(MediaLibraryCommand &cmd);
+    static std::shared_ptr<FileAsset> GetFileAsset(MediaLibraryCommand &cmd);
+private:
+    static std::mutex saveCameraPhotoMutex_;
+    static std::condition_variable condition_;
 };
 
 class PhotoEditingRecord {
diff --git a/frameworks/innerkitsimpl/medialibrary_data_extension/src/media_datashare_ext_ability.cpp b/frameworks/innerkitsimpl/medialibrary_data_extension/src/media_datashare_ext_ability.cpp
index 188ba43..881726e 100644
--- a/frameworks/innerkitsimpl/medialibrary_data_extension/src/media_datashare_ext_ability.cpp
+++ b/frameworks/innerkitsimpl/medialibrary_data_extension/src/media_datashare_ext_ability.cpp
@@ -694,6 +694,12 @@ int MediaDataShareExtAbility::OpenFile(const Uri &uri, const string &mode)
     if (command.GetUri().ToString().find(MEDIA_DATA_DB_HIGHLIGHT) != string::npos) {
         command.SetOprnObject(OperationObject::HIGHLIGHT_COVER);
     }
+    if (command.GetUri().ToString().find(PhotoColumn::PHOTO_REQUEST_PICTURE) != string::npos) {
+        command.SetOprnObject(OperationObject::REQUEST_PICTURE);
+    }
+    if (command.GetUri().ToString().find(PhotoColumn::PHOTO_REQUEST_PICTURE_BUFFER) != string::npos) {
+        command.SetOprnObject(OperationObject::PHOTO_REQUEST_PICTURE_BUFFER);
+    }
     return MediaLibraryDataManager::GetInstance()->OpenFile(command, unifyMode);
 }
 
diff --git a/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_asset_operations.cpp b/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_asset_operations.cpp
index 1d724cc..1dea2a9 100644
--- a/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_asset_operations.cpp
+++ b/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_asset_operations.cpp
@@ -112,6 +112,9 @@ int32_t MediaLibraryAssetOperations::HandleInsertOperation(MediaLibraryCommand &
         case OperationType::SCAN_WITHOUT_ALBUM_UPDATE:
             errCode = MediaLibraryPhotoOperations::ScanFileWithoutAlbumUpdate(cmd);
             break;
+        case OperationType::FINISH_REQUEST_PICTURE:
+            errCode = MediaLibraryPhotoOperations::FinishRequestPicture(cmd);
+            break;
         default:
             MEDIA_ERR_LOG("unknown operation type %{public}d", cmd.GetOprnType());
             break;
diff --git a/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_data_manager.cpp b/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_data_manager.cpp
index 90e5b03..7cc78f7 100644
--- a/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_data_manager.cpp
+++ b/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_data_manager.cpp
@@ -17,6 +17,7 @@
 
 #include "medialibrary_data_manager.h"
 
+#include <cstdlib>
 #include <shared_mutex>
 #include <unordered_set>
 
@@ -1341,7 +1342,8 @@ int32_t MediaLibraryDataManager::OpenFile(MediaLibraryCommand &cmd, const string
     }
 
 #ifdef MEDIALIBRARY_COMPATIBILITY
-    if (oprnObject != OperationObject::THUMBNAIL && oprnObject != OperationObject::THUMBNAIL_ASTC) {
+    if (oprnObject != OperationObject::THUMBNAIL && oprnObject != OperationObject::THUMBNAIL_ASTC &&
+        oprnObject != OperationObject::REQUEST_PICTURE && oprnObject != OperationObject::PHOTO_REQUEST_PICTURE_BUFFER) {
         string opObject = MediaFileUri::GetPathFirstDentry(const_cast<Uri &>(cmd.GetUri()));
         if (opObject == IMAGE_ASSET_TYPE || opObject == VIDEO_ASSET_TYPE || opObject == URI_TYPE_PHOTO) {
             cmd.SetOprnObject(OperationObject::FILESYSTEM_PHOTO);
diff --git a/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_object_utils.cpp b/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_object_utils.cpp
index ef30eec..7fb5026 100644
--- a/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_object_utils.cpp
+++ b/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_object_utils.cpp
@@ -58,6 +58,7 @@
 #include "thumbnail_service.h"
 #include "value_object.h"
 #include "medialibrary_tracer.h"
+#include "picture_handle_service.h"
 #include "post_event_utils.h"
 
 using namespace std;
@@ -781,10 +782,19 @@ int32_t MediaLibraryObjectUtils::OpenFile(MediaLibraryCommand &cmd, const string
     tracer.Start("MediaLibraryObjectUtils::OpenFile");
 
     string uriString = cmd.GetUri().ToString();
+    MEDIA_DEBUG_LOG("MediaLibraryObjectUtils OpenFile uriString:%{public}s", uriString.c_str());
     if (cmd.GetOprnObject() == OperationObject::THUMBNAIL) {
         return ThumbnailService::GetInstance()->GetThumbnailFd(uriString);
     } else if (cmd.GetOprnObject() == OperationObject::THUMBNAIL_ASTC) {
         return ThumbnailService::GetInstance()->GetThumbnailFd(uriString, true);
+    } else if (cmd.GetOprnObject() == OperationObject::REQUEST_PICTURE) {
+        std::string fileId = cmd.GetQuerySetParam(MediaColumn::MEDIA_ID);
+        int32_t fd;
+        PictureHandlerService::OpenPicture(fileId, fd);
+        return fd;
+    } else if (cmd.GetOprnObject() == OperationObject::PHOTO_REQUEST_PICTURE_BUFFER) {
+        std::string fd = cmd.GetQuerySetParam("fd");
+        return PictureHandlerService::RequestBufferHandlerFd(fd);
     } else if (IsDocumentUri(uriString)) {
         return OpenDocument(uriString, mode);
     }
diff --git a/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_photo_operations.cpp b/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_photo_operations.cpp
index 4313039..22f0e3b 100644
--- a/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_photo_operations.cpp
+++ b/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_photo_operations.cpp
@@ -23,6 +23,8 @@
 #include "file_asset.h"
 #include "file_utils.h"
 #include "media_analysis_helper.h"
+#include "image_packer.h"
+#include "iservice_registry.h"
 #include "media_change_effect.h"
 #include "media_column.h"
 #include "media_file_uri.h"
@@ -49,6 +51,9 @@
 #include "photo_album_column.h"
 #include "photo_map_column.h"
 #include "photo_map_operations.h"
+#include "picture.h"
+#include "picture_manager_thread.h"
+
 #include "rdb_predicates.h"
 #include "result_set_utils.h"
 #include "thumbnail_const.h"
@@ -71,7 +76,8 @@ namespace Media {
 static const string ANALYSIS_HAS_DATA = "1";
 shared_ptr<PhotoEditingRecord> PhotoEditingRecord::instance_ = nullptr;
 mutex PhotoEditingRecord::mutex_;
-
+std::mutex MediaLibraryPhotoOperations::saveCameraPhotoMutex_;
+std::condition_variable MediaLibraryPhotoOperations::condition_;
 int32_t MediaLibraryPhotoOperations::Create(MediaLibraryCommand &cmd)
 {
     switch (cmd.GetApi()) {
@@ -742,6 +748,15 @@ int32_t MediaLibraryPhotoOperations::SaveCameraPhoto(MediaLibraryCommand &cmd)
         MEDIA_ERR_LOG("get fileId fail");
         return 0;
     }
+    vector<string> columns = { PhotoColumn::MEDIA_ID, PhotoColumn::MEDIA_FILE_PATH, PhotoColumn::MEDIA_NAME,
+        PhotoColumn::PHOTO_SUBTYPE, PhotoColumn::MEDIA_TIME_PENDING, PhotoColumn::MEDIA_DATE_TRASHED };
+    shared_ptr<FileAsset> fileAsset = GetFileAssetFromDb(
+        PhotoColumn::MEDIA_ID, fileId, OperationObject::FILESYSTEM_PHOTO, columns);
+
+    string fileType = cmd.GetQuerySetParam(IMAGE_FILE_TYPE);
+    if (!fileType.empty()) {
+        SavePicture(stoi(fileType), fileAsset);
+    }
 
     RdbPredicates predicates(PhotoColumn::PHOTOS_TABLE);
     predicates.EqualTo(PhotoColumn::MEDIA_ID, fileId);
@@ -776,11 +791,9 @@ int32_t MediaLibraryPhotoOperations::SaveCameraPhoto(MediaLibraryCommand &cmd)
     }
 
     string needScanStr = cmd.GetQuerySetParam(MEDIA_OPERN_KEYWORD);
-    if (needScanStr.compare("1") == 0) {
-        string path = MediaFileUri::GetPathFromUri(uri, true);
-        if (!path.empty()) {
-            ScanFile(path, false, true, true, stoi(fileId));
-        }
+    string path = MediaFileUri::GetPathFromUri(uri, true);
+    if (!path.empty()) {
+        ScanFile(path, false, true, true, stoi(fileId));
     }
     MEDIA_INFO_LOG("Success, updatedRows: %{public}d, needScanStr: %{public}s", updatedRows, needScanStr.c_str());
     return updatedRows;
@@ -1385,6 +1398,27 @@ static int32_t UpdateEffectMode(int32_t fileId, int32_t effectMode, int32_t phot
     return E_OK;
 }
 
+static int32_t UpdateMimeType(const int32_t &fileId, const std::string mimeType)
+{
+    auto rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Failed to get rdbStore when updating effect mode");
+        return E_HAS_DB_ERROR;
+    }
+    MediaLibraryCommand updateCmd(OperationObject::FILESYSTEM_PHOTO, OperationType::UPDATE);
+    updateCmd.GetAbsRdbPredicates()->EqualTo(MediaColumn::MEDIA_ID, to_string(fileId));
+    ValuesBucket updateValues;
+    updateValues.PutString(MediaColumn::MEDIA_MIME_TYPE, mimeType);
+    updateCmd.SetValueBucket(updateValues);
+    int32_t updateRows = -1;
+    int32_t errCode = rdbStore->Update(updateCmd, updateRows);
+    if (errCode != NativeRdb::E_OK || updateRows < 0) {
+        MEDIA_ERR_LOG("Update mime type failed. errCode:%{public}d, updateRows:%{public}d.", errCode, updateRows);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+
 int32_t MediaLibraryPhotoOperations::CommitEditInsert(MediaLibraryCommand &cmd)
 {
     const ValuesBucket &values = cmd.GetValueBucket();
@@ -1835,25 +1869,141 @@ int32_t MediaLibraryPhotoOperations::SaveSourceAndEditData(
     return E_OK;
 }
 
+std::shared_ptr<FileAsset> MediaLibraryPhotoOperations::GetFileAsset(MediaLibraryCommand& cmd)
+{
+    const ValuesBucket& values = cmd.GetValueBucket();
+    int32_t id = 0;
+    GetInt32FromValuesBucket(values, PhotoColumn::MEDIA_ID, id);
+    vector<string> columns = { PhotoColumn::MEDIA_ID, PhotoColumn::MEDIA_FILE_PATH, PhotoColumn::MEDIA_NAME,
+        PhotoColumn::PHOTO_SUBTYPE, PhotoColumn::MEDIA_TIME_PENDING, PhotoColumn::MEDIA_DATE_TRASHED };
+    shared_ptr<FileAsset> fileAsset = GetFileAssetFromDb(
+        PhotoColumn::MEDIA_ID, to_string(id), OperationObject::FILESYSTEM_PHOTO, columns);
+    return fileAsset;
+}
+
+int32_t MediaLibraryPhotoOperations::GetPicture(const int32_t &fileId, std::shared_ptr<Media::Picture> &picture,
+    bool isCleanImmediately, std::string &photoId)
+{
+    RdbPredicates predicates(PhotoColumn::PHOTOS_TABLE);
+    predicates.EqualTo(MediaColumn::MEDIA_ID, std::to_string(fileId));
+    vector<string> columns = { PhotoColumn::PHOTO_ID };
+    auto resultSet = MediaLibraryRdbStore::Query(predicates, columns);
+    if (resultSet->GoToFirstRow() != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("result set is empty");
+        return E_FILE_EXIST;
+    }
+ 
+    photoId = GetStringVal(PhotoColumn::PHOTO_ID, resultSet);
+    if (photoId.empty()) {
+        MEDIA_ERR_LOG("photoId is emply fileId is: %{public}d", fileId);
+        return E_FILE_EXIST;
+    }
+ 
+    MEDIA_INFO_LOG("photoId: %{public}s", photoId.c_str());
+    auto pictureManagerThread = PictureManagerThread::GetInstance();
+    if (pictureManagerThread != nullptr) {
+        pictureManagerThread->Start();
+        picture = pictureManagerThread->GetDataWithImageId(photoId, isCleanImmediately);
+    }
+    if (picture == nullptr) {
+        MEDIA_ERR_LOG("picture is not exists!");
+        return E_FILE_EXIST;
+    }
+    return E_OK;
+}
+
+int32_t MediaLibraryPhotoOperations::FinishRequestPicture(MediaLibraryCommand &cmd)
+{
+    const ValuesBucket& values = cmd.GetValueBucket();
+    int32_t fileId = 0;
+    GetInt32FromValuesBucket(values, PhotoColumn::MEDIA_ID, fileId);
+
+    RdbPredicates predicates(PhotoColumn::PHOTOS_TABLE);
+    predicates.EqualTo(MediaColumn::MEDIA_ID, std::to_string(fileId));
+    vector<string> columns = { PhotoColumn::PHOTO_ID };
+    auto resultSet = MediaLibraryRdbStore::Query(predicates, columns);
+    if (resultSet->GoToFirstRow() != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("result set is empty");
+        return E_FILE_EXIST;
+    }
+
+    string photoId = GetStringVal(PhotoColumn::PHOTO_ID, resultSet);
+    if (photoId.empty()) {
+        MEDIA_ERR_LOG("photoId is emply fileId is: %{public}d", fileId);
+        return E_FILE_EXIST;
+    }
+
+    MEDIA_INFO_LOG("photoId: %{public}s", photoId.c_str());
+    auto pictureManagerThread = PictureManagerThread::GetInstance();
+    if (pictureManagerThread != nullptr) {
+        pictureManagerThread->Start();
+    }
+    pictureManagerThread->FinishAccessingPicture(photoId);
+    return E_OK;
+}
+
 int32_t MediaLibraryPhotoOperations::AddFilters(MediaLibraryCommand& cmd)
 {
     if (IsCameraEditData(cmd)) {
-        const ValuesBucket& values = cmd.GetValueBucket();
-        int32_t id = 0;
-        GetInt32FromValuesBucket(values, PhotoColumn::MEDIA_ID, id);
-        vector<string> columns = { PhotoColumn::MEDIA_ID, PhotoColumn::MEDIA_FILE_PATH, PhotoColumn::MEDIA_NAME,
-            PhotoColumn::PHOTO_SUBTYPE, PhotoColumn::MEDIA_TIME_PENDING, PhotoColumn::MEDIA_DATE_TRASHED };
-        shared_ptr<FileAsset> fileAsset = GetFileAssetFromDb(
-            PhotoColumn::MEDIA_ID, to_string(id), OperationObject::FILESYSTEM_PHOTO, columns);
+        shared_ptr<FileAsset> fileAsset = GetFileAsset(cmd);
         return AddFiltersExecute(cmd, fileAsset, "");
     }
     return E_OK;
 }
 
+int32_t MediaLibraryPhotoOperations::SavePicture(const int32_t &fileType, const std::shared_ptr<FileAsset> &fileAsset)
+{
+    int32_t fileId = fileAsset->GetId();
+    MEDIA_DEBUG_LOG("fileType is: %{public}d, fileId is: %{public}d", fileType, fileId);
+
+    auto pictureManagerThread = PictureManagerThread::GetInstance();
+    if (pictureManagerThread != nullptr) {
+        pictureManagerThread->Start();
+    }
+    std::shared_ptr<Media::Picture> picture;
+    std::string photoId;
+    if (GetPicture(fileId, picture, false, photoId) != E_OK) {
+        MEDIA_ERR_LOG("Failed to get picture");
+        return E_FILE_EXIST;
+    }
+
+    MEDIA_INFO_LOG("SaveCameraPhotoPicture::begin");
+    {
+        unique_lock<mutex> locker(saveCameraPhotoMutex_);
+        bool ret = condition_.wait_for(locker, chrono::milliseconds(300),
+            [pictureManagerThread]() { return pictureManagerThread->GetPendingTaskSize() < 5; });
+        if (!ret) {
+            MEDIA_INFO_LOG("SaveCameraPhotoPicture::Wait wait for lock timeout");
+        }
+    }
+
+    string assetPath = fileAsset->GetFilePath();
+    CHECK_AND_RETURN_RET_LOG(!assetPath.empty(), E_INVALID_VALUES, "Failed to get asset path");
+
+    ImageFileType type = static_cast<ImageFileType>(fileType);
+    auto itr = IMAGE_FILE_TYPE_MAP.find(type);
+    if (itr == IMAGE_FILE_TYPE_MAP.end()) {
+        MEDIA_ERR_LOG("fileType : %{public} is not support", fileType);
+        return E_INVALID_ARGUMENTS;
+    }
+    std::string format = itr->second;
+    Media::ImagePacker imagePacker;
+    Media::PackOption packOption;
+    packOption.format = format;
+    imagePacker.StartPacking(assetPath, packOption);
+    imagePacker.AddPicture(*(picture));
+    imagePacker.FinalizePacking();
+    MEDIA_DEBUG_LOG("SavePicture end");
+    UpdateMimeType(fileId, format);
+    pictureManagerThread->FinishAccessingPicture(photoId);
+    return E_OK;
+}
+
 int32_t MediaLibraryPhotoOperations::AddFiltersExecute(MediaLibraryCommand& cmd,
     const shared_ptr<FileAsset>& fileAsset, const string& cachePath)
 {
     CHECK_AND_RETURN_RET_LOG(fileAsset != nullptr, E_INVALID_VALUES, "fileAsset is nullptr");
+    int32_t fileId = fileAsset->GetId();
     string assetPath = fileAsset->GetFilePath();
     CHECK_AND_RETURN_RET_LOG(!assetPath.empty(), E_INVALID_VALUES, "Failed to get asset path");
     string editDataDirPath = GetEditDataDirPath(assetPath);
@@ -1875,6 +2025,18 @@ int32_t MediaLibraryPhotoOperations::AddFiltersExecute(MediaLibraryCommand& cmd,
     // 保存editdata_camera文件
     string editData;
     SaveEditDataCamera(cmd, assetPath, editData);
+    std::shared_ptr<Media::Picture> picture;
+    string photoId;
+    if (GetPicture(fileId, picture, false, photoId) == E_OK) {
+        string fileType = cmd.GetQuerySetParam(IMAGE_FILE_TYPE);
+        int32_t ret = AddFiltersToPicture(picture, sourcePath, editData, fileType);
+        auto pictureManagerThread = PictureManagerThread::GetInstance();
+        if (pictureManagerThread != nullptr) {
+            pictureManagerThread->Start();
+        }
+        pictureManagerThread->FinishAccessingPicture(photoId);
+        return ret;
+    }
     // 生成水印
     return AddFiltersToPhoto(sourcePath, assetPath, editData, fileAsset->GetId());
 }
@@ -2088,7 +2250,7 @@ int32_t MediaLibraryPhotoOperations::SubmitCache(MediaLibraryCommand& cmd)
         PhotoColumn::PHOTO_EDIT_TIME };
     shared_ptr<FileAsset> fileAsset = GetFileAssetFromDb(
         PhotoColumn::MEDIA_ID, to_string(id), OperationObject::FILESYSTEM_PHOTO, columns);
-    CHECK_AND_RETURN_RET_LOG(fileAsset != nullptr, E_INVALID_VALUES, "Failed to get FileAsset, fileId=%{public}d", id);
+    CHECK_AND_RETURN_RET_LOG(fileAsset != nullptr, E_INVALID_VALUES, "Failed to getmapmanagerthread:: FileAsset, fileId=%{public}d", id);
     int32_t errCode = SubmitCacheExecute(cmd, fileAsset, cachePath);
     CHECK_AND_RETURN_RET_LOG(errCode == E_OK, errCode, "Failed to submit cache, fileId=%{public}d", id);
     return id;
@@ -2131,6 +2293,41 @@ int32_t MediaLibraryPhotoOperations::ProcessMultistagesPhoto(bool isEdited, cons
     }
 }
 
+int32_t MediaLibraryPhotoOperations::ProcessMultistagesPhotoForPicture(bool isEdited, const std::string &path,
+    std::shared_ptr<Media::Picture> &picture, int32_t fileId, const std::string &mime_type)
+{
+    MediaLibraryTracer tracer;
+    tracer.Start("MediaLibraryPhotoOperations::ProcessMultistagesPhoto");
+    string editDataSourcePath = GetEditDataSourcePath(path);
+    string editDataCameraPath = GetEditDataCameraPath(path);
+
+    if (isEdited) {
+        // 图片编辑过了只替换低质量裸图
+        return FileUtils::SavePicture(editDataSourcePath, picture, mime_type, isEdited);
+    } else {
+        if (!MediaFileUtils::IsFileExists(editDataCameraPath)) {
+            // 图片没编辑过且没有editdata_camera，只落盘在Photo目录
+            return FileUtils::SavePicture(path, picture, mime_type, isEdited);
+        } else {
+            // 图片没编辑过且有editdata_camera
+            MediaLibraryTracer tracer;
+            tracer.Start("MediaLibraryPhotoOperations::ProcessMultistagesPhoto AddFiltersToPhoto");
+            // (1) 先替换低质量裸图
+            int ret = FileUtils::SavePicture(editDataSourcePath, picture, mime_type, isEdited);
+            if (ret != E_OK) {
+                return ret;
+            }
+            // (2) 生成高质量水印滤镜图片
+            string editData;
+            CHECK_AND_RETURN_RET_LOG(ReadEditdataFromFile(editDataCameraPath, editData) == E_OK, E_HAS_FS_ERROR,
+                "Failed to read editdata, path=%{public}s", editDataCameraPath.c_str());
+            CHECK_AND_RETURN_RET_LOG(AddFiltersToPicture(picture, path, editData, mime_type) == E_OK, E_FAIL,
+                "Failed to add filters to photo");
+            return E_OK;
+        }
+    }
+}
+
 int32_t MediaLibraryPhotoOperations::AddFiltersToPhoto(const std::string &inputPath,
     const std::string &outputPath, const std::string &editdata, int32_t fileId, const std::string &photoStatus)
 {
@@ -2171,6 +2368,26 @@ int32_t MediaLibraryPhotoOperations::AddFiltersToPhoto(const std::string &inputP
     return E_OK;
 }
 
+int32_t MediaLibraryPhotoOperations::AddFiltersToPicture(std::shared_ptr<Media::Picture> &inPicture,
+    const std::string &outputPath, string &editdata, const std::string &mime_type)
+{
+    if (inPicture == nullptr) {
+        MEDIA_ERR_LOG("AddFiltersToPicture: picture is null");
+        return E_ERR;
+    }
+    MEDIA_INFO_LOG("AddFiltersToPicture outputPath: %{public}s, editdata: %{public}s",
+        outputPath.c_str(), editdata.c_str());
+    size_t lastSlash = outputPath.rfind('/');
+    CHECK_AND_RETURN_RET_LOG(lastSlash != string::npos && outputPath.size() > (lastSlash + 1), E_INVALID_VALUES,
+        "Failed to check outputPath: %{public}s", outputPath.c_str());
+    int32_t ret = MediaChangeEffect::TakeEffectForPicture(inPicture, editdata);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("MediaLibraryPhotoOperations: AddFiltersToPicture: TakeEffect error. ret = %d", ret);
+        return E_ERR;
+    }
+    return E_OK;
+}
+
 PhotoEditingRecord::PhotoEditingRecord()
 {
 }
diff --git a/frameworks/innerkitsimpl/test/unittest/medialibrary_helper_test/include/photo_proxy_test.h b/frameworks/innerkitsimpl/test/unittest/medialibrary_helper_test/include/photo_proxy_test.h
index db2ad4a..ab6a691 100644
--- a/frameworks/innerkitsimpl/test/unittest/medialibrary_helper_test/include/photo_proxy_test.h
+++ b/frameworks/innerkitsimpl/test/unittest/medialibrary_helper_test/include/photo_proxy_test.h
@@ -121,7 +121,7 @@ public:
     {
     }
 
-    // RGBA、JPG
+    // RGBA、JPG、YUV
     virtual PhotoFormat GetFormat() override
     {
         return PhotoFormat::RGBA;
diff --git a/frameworks/js/src/media_asset_change_request_napi.cpp b/frameworks/js/src/media_asset_change_request_napi.cpp
index 2177c2f..9a6cdc8 100644
--- a/frameworks/js/src/media_asset_change_request_napi.cpp
+++ b/frameworks/js/src/media_asset_change_request_napi.cpp
@@ -458,6 +458,16 @@ string MediaAssetChangeRequestNapi::GetCacheMovingPhotoVideoName() const
     return cacheMovingPhotoVideoName_;
 }
 
+void MediaAssetChangeRequestNapi::SetImageFileType(int32_t imageFileType)
+{
+    imageFileType_ = imageFileType;
+}
+
+int32_t MediaAssetChangeRequestNapi::GetImageFileType()
+{
+    return imageFileType_;
+}
+
 napi_value MediaAssetChangeRequestNapi::JSGetAsset(napi_env env, napi_callback_info info)
 {
     auto asyncContext = make_unique<MediaAssetChangeRequestAsyncContext>();
@@ -1205,12 +1215,19 @@ napi_value MediaAssetChangeRequestNapi::JSSetCameraShotKey(napi_env env, napi_ca
 
 napi_value MediaAssetChangeRequestNapi::JSSaveCameraPhoto(napi_env env, napi_callback_info info)
 {
+    constexpr size_t minArgs = ARGS_ZERO;
+    constexpr size_t maxArgs = ARGS_ONE;
     auto asyncContext = make_unique<MediaAssetChangeRequestAsyncContext>();
     CHECK_COND_WITH_MESSAGE(env,
-        MediaLibraryNapiUtils::AsyncContextSetObjectInfo(env, info, asyncContext, ARGS_ZERO, ARGS_ZERO) == napi_ok,
+        MediaLibraryNapiUtils::AsyncContextSetObjectInfo(env, info, asyncContext, minArgs, maxArgs) == napi_ok,
         "Failed to get object info");
-
     auto changeRequest = asyncContext->objectInfo;
+    if (asyncContext->argc == ARGS_ONE) {
+        int32_t fileType;
+        MediaLibraryNapiUtils::GetInt32Arg(env, asyncContext->argv[PARAM0], fileType);
+        NAPI_DEBUG_LOG("fileType: %{public}d", fileType);
+        changeRequest->SetImageFileType(fileType);
+    }
     auto fileAsset = changeRequest->GetFileAssetInstance();
     CHECK_COND(env, fileAsset != nullptr, JS_INNER_FAIL);
     if (changeRequest->Contains(AssetChangeOperation::SET_EDIT_DATA) &&
@@ -2115,6 +2132,9 @@ static void DiscardHighQualityPhoto(MediaAssetChangeRequestAsyncContext& context
 
 static bool SaveCameraPhotoExecute(MediaAssetChangeRequestAsyncContext& context)
 {
+    MediaLibraryTracer tracer;
+    tracer.Start("SaveCameraPhotoExecute");
+
     auto changeOpreations = context.assetChangeOperations;
     bool containsAddResource = std::find(changeOpreations.begin(), changeOpreations.end(),
         AssetChangeOperation::ADD_RESOURCE) != changeOpreations.end();
@@ -2144,6 +2164,7 @@ static bool SaveCameraPhotoExecute(MediaAssetChangeRequestAsyncContext& context)
     MediaLibraryNapiUtils::UriAppendKeyValue(uriStr, PhotoColumn::MEDIA_ID, to_string(fileAsset->GetId()));
     MediaLibraryNapiUtils::UriAppendKeyValue(uriStr, PhotoColumn::PHOTO_SUBTYPE,
         to_string(fileAsset->GetPhotoSubType()));
+    MediaLibraryNapiUtils::UriAppendKeyValue(uriStr, IMAGE_FILE_TYPE, to_string(context.objectInfo->GetImageFileType()));
     Uri uri(uriStr);
     DataShare::DataShareValuesBucket valuesBucket;
     valuesBucket.Put(PhotoColumn::PHOTO_IS_TEMP, false);
diff --git a/frameworks/js/src/media_asset_data_handler.cpp b/frameworks/js/src/media_asset_data_handler.cpp
index 62ef382..1ecde07 100644
--- a/frameworks/js/src/media_asset_data_handler.cpp
+++ b/frameworks/js/src/media_asset_data_handler.cpp
@@ -116,5 +116,50 @@ void NapiMediaAssetDataHandler::JsOnDataPrepared(napi_env env, napi_value arg, n
         NapiError::ThrowError(env, JS_INNER_FAIL, "calling onDataPrepared failed");
     }
 }
+
+void NapiMediaAssetDataHandler::JsOnDataPrepared(napi_env env, napi_value pictures, napi_value arg,
+    napi_value extraInfo)
+{
+    if (dataHandlerRef_ == nullptr) {
+        NAPI_ERR_LOG("JsOnDataPrepared js function is null");
+        return;
+    }
+
+    napi_value callback;
+    napi_status status = napi_get_reference_value(env, dataHandlerRef_, &callback);
+    if (status != napi_ok) {
+        NAPI_ERR_LOG("JsOnDataPrepared napi_get_reference_value fail, napi status: %{public}d",
+            static_cast<int>(status));
+        return;
+    }
+
+    napi_value jsOnDataPrepared;
+    status = napi_get_named_property(env, callback, ON_DATA_PREPARED_FUNC, &jsOnDataPrepared);
+    if (status != napi_ok) {
+        NAPI_ERR_LOG("JsOnDataPrepared napi_get_named_property fail, napi status: %{public}d",
+            static_cast<int>(status));
+        return;
+    }
+
+    constexpr size_t maxArgs = 3;
+    napi_value argv[maxArgs];
+    size_t argc = 0;
+    if (extraInfo != nullptr) {
+        argv[PARAM0] = pictures;
+        argv[PARAM1] = arg;
+        argv[PARAM2] = extraInfo;
+        argc = ARGS_THREE;
+    } else {
+        argv[PARAM0] = pictures;
+        argv[PARAM1] = arg;
+        argc = ARGS_TWO;
+    }
+    napi_value promise;
+    status = napi_call_function(env, nullptr, jsOnDataPrepared, argc, argv, &promise);
+    if (status != napi_ok) {
+        NAPI_ERR_LOG("call js function failed %{public}d", static_cast<int32_t>(status));
+        NapiError::ThrowError(env, JS_INNER_FAIL, "calling onDataPrepared failed");
+    }
+}
 } // namespace Media
 } // namespace OHOS
diff --git a/frameworks/js/src/media_asset_manager_napi.cpp b/frameworks/js/src/media_asset_manager_napi.cpp
index 459276f..136cd76 100644
--- a/frameworks/js/src/media_asset_manager_napi.cpp
+++ b/frameworks/js/src/media_asset_manager_napi.cpp
@@ -44,6 +44,7 @@
 #include "medialibrary_tracer.h"
 #include "moving_photo_napi.h"
 #include "permission_utils.h"
+#include "picture_handle_client.h"
 #include "ui_extension_context.h"
 #include "userfile_client.h"
 
@@ -81,6 +82,7 @@ napi_value MediaAssetManagerNapi::Init(napi_env env, napi_value exports)
             DECLARE_NAPI_STATIC_FUNCTION("requestVideoFile", JSRequestVideoFile),
             DECLARE_NAPI_STATIC_FUNCTION("cancelRequest", JSCancelRequest),
             DECLARE_NAPI_STATIC_FUNCTION("loadMovingPhoto", JSLoadMovingPhoto),
+            DECLARE_NAPI_STATIC_FUNCTION("requestEfficientImage", JSRequestEfficientIImage)
         }};
         MediaLibraryNapiUtils::NapiDefineClass(env, exports, info);
         return exports;
@@ -415,6 +417,53 @@ napi_status ParseArgGetDestPath(napi_env env, napi_value arg, std::string &destP
     return napi_ok;
 }
 
+napi_status ParseArgGetEfficientImageDataHandler(napi_env env, napi_value arg, napi_value& dataHandler,
+    bool& needsExtraInfo)
+{
+    CHECK_COND_LOG_THROW_RETURN_RET(env, arg != nullptr, OHOS_INVALID_PARAM_CODE, "efficient handler invalid argument",
+        napi_invalid_arg, "efficient data handler is nullptr");
+
+    napi_valuetype valueType;
+    napi_status status = napi_typeof(env, arg, &valueType);
+    CHECK_COND_LOG_THROW_RETURN_RET(env, status == napi_ok, OHOS_INVALID_PARAM_CODE, "invalid efficient data handler",
+        napi_invalid_arg, "failed to get type of efficient data handler, napi status: %{public}d",
+        static_cast<int>(status));
+    CHECK_COND_LOG_THROW_RETURN_RET(env, valueType == napi_object, OHOS_INVALID_PARAM_CODE,
+        "efficient data handler not a object", napi_invalid_arg, "efficient data handler not a object");
+
+    dataHandler = arg;
+
+    napi_value onDataPrepared;
+    status = napi_get_named_property(env, arg, ON_DATA_PREPARED_FUNC, &onDataPrepared);
+    CHECK_COND_LOG_THROW_RETURN_RET(env, status == napi_ok, OHOS_INVALID_PARAM_CODE,
+        "unable to get onDataPrepared function", napi_invalid_arg,
+        "failed to get type of efficient data handler, napi status: %{public}d", static_cast<int>(status));
+    status = napi_typeof(env, onDataPrepared, &valueType);
+    CHECK_COND_LOG_THROW_RETURN_RET(env, status == napi_ok, OHOS_INVALID_PARAM_CODE, "invalid onDataPrepared",
+        napi_invalid_arg, "failed to get type of onDataPrepared, napi status: %{public}d", static_cast<int>(status));
+    CHECK_COND_LOG_THROW_RETURN_RET(env, valueType == napi_function, OHOS_INVALID_PARAM_CODE,
+        "onDataPrepared not a function", napi_invalid_arg, "onDataPrepared not a function");
+
+    napi_value paramCountNapi;
+    status = napi_get_named_property(env, onDataPrepared, "length", &paramCountNapi);
+    CHECK_COND_LOG_THROW_RETURN_RET(env, status == napi_ok, OHOS_INVALID_PARAM_CODE, "invalid onDataPrepared",
+        napi_invalid_arg, "get onDataPrepared arg count fail, napi status: %{public}d", static_cast<int>(status));
+    int32_t paramCount = -1;
+    constexpr int paramCountMin = 2;
+    constexpr int paramCountMax = 3;
+    status = napi_get_value_int32(env, paramCountNapi, &paramCount);
+    CHECK_COND_LOG_THROW_RETURN_RET(env, status == napi_ok, OHOS_INVALID_PARAM_CODE, "invalid onDataPrepared",
+        napi_invalid_arg, "get onDataPrepared arg count value fail, napi status: %{public}d", static_cast<int>(status));
+    CHECK_COND_LOG_THROW_RETURN_RET(env, (paramCount >= paramCountMin && paramCount <= paramCountMax),
+        OHOS_INVALID_PARAM_CODE, "onDataPrepared has wrong number of parameters",
+        napi_invalid_arg, "onDataPrepared has wrong number of parameters");
+
+    if (paramCount == ARGS_THREE) {
+        needsExtraInfo = true;
+    }
+    return napi_ok;
+}
+
 napi_status ParseArgGetDataHandler(napi_env env, napi_value arg, napi_value& dataHandler, bool& needsExtraInfo)
 {
     CHECK_COND_LOG_THROW_RETURN_RET(env, arg != nullptr, OHOS_INVALID_PARAM_CODE, "data handler invalid argument",
@@ -531,6 +580,57 @@ napi_status MediaAssetManagerNapi::ParseRequestMediaArgs(napi_env env, napi_call
     return napi_ok;
 }
 
+napi_status MediaAssetManagerNapi::ParseEfficentRequestMediaArgs(napi_env env, napi_callback_info info,
+    unique_ptr<MediaAssetManagerAsyncContext> &asyncContext)
+{
+    napi_value thisVar = nullptr;
+    GET_JS_ARGS(env, info, asyncContext->argc, asyncContext->argv, thisVar);
+    if (asyncContext->argc != ARGS_FOUR && asyncContext->argc != ARGS_FIVE) {
+        NAPI_ERR_LOG("requestMedia argc error");
+        NapiError::ThrowError(env, OHOS_INVALID_PARAM_CODE, "requestMedia argc invalid");
+        return napi_invalid_arg;
+    }
+    if (ParseArgGetCallingPackageName(env, asyncContext->argv[PARAM0], asyncContext->callingPkgName) != napi_ok) {
+        NAPI_ERR_LOG("requestMedia ParseArgGetCallingPackageName error");
+        NapiError::ThrowError(env, OHOS_INVALID_PARAM_CODE, "requestMedia ParseArgGetPhotoAsset error");
+        return napi_invalid_arg;
+    }
+    if (ParseArgGetPhotoAsset(env, asyncContext->argv[PARAM1], asyncContext->fileId, asyncContext->photoUri,
+        asyncContext->displayName) != napi_ok) {
+        NAPI_ERR_LOG("requestMedia ParseArgGetPhotoAsset error");
+        NapiError::ThrowError(env, OHOS_INVALID_PARAM_CODE, "requestMedia ParseArgGetPhotoAsset error");
+        return napi_invalid_arg;
+    }
+    if (ParseArgGetRequestOption(env, asyncContext->argv[PARAM2], asyncContext->deliveryMode,
+        asyncContext->sourceMode) != napi_ok) {
+        NAPI_ERR_LOG("requestMedia ParseArgGetRequestOption error");
+        NapiError::ThrowError(env, OHOS_INVALID_PARAM_CODE, "requestMedia ParseArgGetRequestOption error");
+        return napi_invalid_arg;
+    }
+    if (asyncContext->argc == ARGS_FOUR) {
+        if (ParseArgGetEfficientImageDataHandler(env, asyncContext->argv[PARAM3], asyncContext->dataHandler,
+            asyncContext->needsExtraInfo) != napi_ok) {
+            NAPI_ERR_LOG("requestMedia ParseArgGetEfficientImageDataHandler error");
+            NapiError::ThrowError(env, OHOS_INVALID_PARAM_CODE, "requestMedia ParseArgGetEfficientImageDataHandler error");
+            return napi_invalid_arg;
+        }
+    } else if (asyncContext->argc == ARGS_FIVE) {
+        if (ParseArgGetDestPath(env, asyncContext->argv[PARAM3], asyncContext->destUri) != napi_ok) {
+            NapiError::ThrowError(env, OHOS_INVALID_PARAM_CODE, "requestMedia ParseArgGetDestPath error");
+            return napi_invalid_arg;
+        }
+        if (ParseArgGetEfficientImageDataHandler(env, asyncContext->argv[PARAM4], asyncContext->dataHandler,
+            asyncContext->needsExtraInfo) != napi_ok) {
+            NAPI_ERR_LOG("requestMedia ParseArgGetEfficientImageDataHandler error");
+            NapiError::ThrowError(env, OHOS_INVALID_PARAM_CODE,
+                "requestMedia ParseArgGetEfficientImageDataHandler error");
+            return napi_invalid_arg;
+        }
+    }
+    asyncContext->hasReadPermission = HasReadPermission();
+    return napi_ok;
+}
+
 bool MediaAssetManagerNapi::InitUserFileClient(napi_env env, napi_callback_info info)
 {
     if (UserFileClient::IsValid()) {
@@ -603,6 +703,7 @@ napi_value MediaAssetManagerNapi::JSRequestImageData(napi_env env, napi_callback
 
 napi_value MediaAssetManagerNapi::JSRequestImage(napi_env env, napi_callback_info info)
 {
+    NAPI_DEBUG_LOG("JSRequestImage");
     if (env == nullptr || info == nullptr) {
         NAPI_ERR_LOG("JSRequestImage js arg invalid");
         NapiError::ThrowError(env, JS_INNER_FAIL, "JSRequestImage js arg invalid");
@@ -642,6 +743,48 @@ napi_value MediaAssetManagerNapi::JSRequestImage(napi_env env, napi_callback_inf
         JSRequestComplete);
 }
 
+napi_value MediaAssetManagerNapi::JSRequestEfficientIImage(napi_env env, napi_callback_info info)
+{
+    NAPI_DEBUG_LOG("JSRequestEfficientIImage");
+    if (env == nullptr || info == nullptr) {
+        NAPI_ERR_LOG("JSRequestEfficientIImage js arg invalid");
+        NapiError::ThrowError(env, JS_INNER_FAIL, "JSRequestEfficientIImage js arg invalid");
+        return nullptr;
+    }
+    if (!InitUserFileClient(env, info)) {
+        NAPI_ERR_LOG("JSRequestEfficientIImage init user file client failed");
+        NapiError::ThrowError(env, JS_INNER_FAIL, "handler is invalid");
+        return nullptr;
+    }
+
+    MediaLibraryTracer tracer;
+    tracer.Start("JSRequestEfficientIImage");
+
+    unique_ptr<MediaAssetManagerAsyncContext> asyncContext = make_unique<MediaAssetManagerAsyncContext>();
+    asyncContext->returnDataType = ReturnDataType::TYPE_PICTURE;
+    if (ParseEfficentRequestMediaArgs(env, info, asyncContext) != napi_ok) {
+        NAPI_ERR_LOG("failed to parse JSRequestEfficientIImage args");
+        NapiError::ThrowError(env, OHOS_INVALID_PARAM_CODE, "failed to parse JSRequestEfficientIImage args");
+        return nullptr;
+    }
+    if (CreateDataHandlerRef(env, asyncContext, asyncContext->dataHandlerRef) != napi_ok
+            || CreateOnDataPreparedThreadSafeFunc(env, asyncContext, asyncContext->onDataPreparedPtr) != napi_ok) {
+        NAPI_ERR_LOG("CreateDataHandlerRef or CreateOnDataPreparedThreadSafeFunc failed");
+        return nullptr;
+    }
+    if (CreateDataHandlerRef(env, asyncContext, asyncContext->dataHandlerRef2) != napi_ok
+            || CreateOnDataPreparedThreadSafeFunc(env, asyncContext, asyncContext->onDataPreparedPtr2) != napi_ok) {
+        NAPI_ERR_LOG("CreateDataHandlerRef or CreateOnDataPreparedThreadSafeFunc failed");
+        return nullptr;
+    }
+
+    asyncContext->requestId = GenerateRequestId();
+    asyncContext->subType = static_cast<PhotoSubType>(GetPhotoSubtype(env, asyncContext->argv[PARAM1]));
+
+    return MediaLibraryNapiUtils::NapiCreateAsyncWork(env, asyncContext, "JSRequestEfficientIImage", JSRequestExecute,
+        JSRequestComplete);
+}
+
 napi_value MediaAssetManagerNapi::JSRequestVideoFile(napi_env env, napi_callback_info info)
 {
     if (env == nullptr || info == nullptr) {
@@ -800,8 +943,10 @@ static napi_value GetInfoMapNapiValue(napi_env env, AssetHandler* assetHandler)
     return mapNapiValue;
 }
 
-static napi_value GetNapiValueOfMedia(napi_env env, const std::shared_ptr<NapiMediaAssetDataHandler>& dataHandler)
+static napi_value GetNapiValueOfMedia(napi_env env, const std::shared_ptr<NapiMediaAssetDataHandler>& dataHandler,
+    bool& isPicture)
 {
+    NAPI_DEBUG_LOG("GetNapiValueOfMedia");
     napi_value napiValueOfMedia = nullptr;
     if (dataHandler->GetReturnDataType() == ReturnDataType::TYPE_ARRAY_BUFFER) {
         MediaAssetManagerNapi::GetByteArrayNapiObject(dataHandler->GetRequestUri(), napiValueOfMedia,
@@ -815,6 +960,9 @@ static napi_value GetNapiValueOfMedia(napi_env env, const std::shared_ptr<NapiMe
     } else if (dataHandler->GetReturnDataType() == ReturnDataType::TYPE_MOVING_PHOTO) {
         napiValueOfMedia = MovingPhotoNapi::NewMovingPhotoNapi(
             env, dataHandler->GetRequestUri(), dataHandler->GetSourceMode());
+    } else if (dataHandler->GetReturnDataType() == ReturnDataType::TYPE_PICTURE) {
+        MediaAssetManagerNapi::GetPictureNapiObject(dataHandler->GetRequestUri(), napiValueOfMedia,
+            dataHandler->GetSourceMode() == SourceMode::ORIGINAL_MODE, env, isPicture);
     } else {
         NAPI_ERR_LOG("source mode type invalid");
     }
@@ -823,6 +971,7 @@ static napi_value GetNapiValueOfMedia(napi_env env, const std::shared_ptr<NapiMe
 
 void MediaAssetManagerNapi::OnDataPrepared(napi_env env, napi_value cb, void *context, void *data)
 {
+    NAPI_DEBUG_LOG("OnDataPrepared");
     AssetHandler *assetHandler = reinterpret_cast<AssetHandler *>(data);
     CHECK_NULL_PTR_RETURN_VOID(assetHandler, "assetHandler is nullptr");
     auto dataHandler = assetHandler->dataHandler;
@@ -850,12 +999,23 @@ void MediaAssetManagerNapi::OnDataPrepared(napi_env env, napi_value cb, void *co
             napi_get_undefined(env, &napiValueOfInfoMap);
         }
     }
-    napi_value napiValueOfMedia = GetNapiValueOfMedia(env, dataHandler);
-    if (napiValueOfMedia == nullptr) {
-        napi_get_undefined(env, &napiValueOfMedia);
+    bool isPicture = true;
+    napi_value napiValueOfMedia = GetNapiValueOfMedia(env, dataHandler, isPicture);
+    if (dataHandler->GetReturnDataType() == ReturnDataType::TYPE_PICTURE) {
+        if (isPicture) {
+            dataHandler->JsOnDataPrepared(env, napiValueOfMedia, nullptr, napiValueOfInfoMap);
+        } else {
+            if (napiValueOfMedia == nullptr) {
+                napi_get_undefined(env, &napiValueOfMedia);
+            }
+            dataHandler->JsOnDataPrepared(env, nullptr, napiValueOfMedia, napiValueOfInfoMap);
+        }
+    } else {
+        if (napiValueOfMedia == nullptr) {
+            napi_get_undefined(env, &napiValueOfMedia);
+        }
+        dataHandler->JsOnDataPrepared(env, napiValueOfMedia, napiValueOfInfoMap);
     }
-    dataHandler->JsOnDataPrepared(env, napiValueOfMedia, napiValueOfInfoMap);
-
     DeleteDataHandler(notifyMode, assetHandler->requestUri, assetHandler->requestId);
     NAPI_INFO_LOG("delete assetHandler: %{public}p", assetHandler);
     DeleteAssetHandlerSafe(assetHandler, env);
@@ -941,6 +1101,39 @@ void MediaAssetManagerNapi::GetImageSourceNapiObject(const std::string &fileUri,
     imageSourceNapiObj = tempImageSourceNapi;
 }
 
+void MediaAssetManagerNapi::GetPictureNapiObject(const std::string &fileUri, napi_value &pictureNapiObj,
+    bool isSource, napi_env env,  bool& isPicture)
+{
+    if (env == nullptr) {
+        NAPI_ERR_LOG(" create image source object failed, need to initialize js env");
+        return;
+    }
+    NAPI_DEBUG_LOG("GetPictureNapiObject");
+
+    std::string tempStr = fileUri.substr(PhotoColumn::PHOTO_URI_PREFIX.length());
+    std::size_t index = tempStr.find("/");
+    std::string fileId = tempStr.substr(0, index);
+    auto pic = PictureHandlerClient::RequestPicture(std::atoi(fileId.c_str()));
+    if (pic == nullptr) {
+        NAPI_ERR_LOG("picture is null");
+        isPicture = false;
+        GetImageSourceNapiObject(fileUri, pictureNapiObj, isSource, env);
+        return;
+    }
+    NAPI_ERR_LOG("picture is not null");
+    napi_value tempPictureNapi;
+    PictureNapi::CreatePictureNapi(env, &tempPictureNapi);
+    PictureNapi* pictureNapi = nullptr;
+    napi_unwrap(env, tempPictureNapi, reinterpret_cast<void**>(&pictureNapi));
+    if (pictureNapi == nullptr) {
+        NAPI_ERR_LOG("GetPictureNapiObject unwrap image napi object failed");
+        return;
+    }
+    pictureNapi->SetNativePicture(pic);
+    pictureNapiObj = tempPictureNapi;
+}
+
+
 void MediaAssetManagerNapi::GetByteArrayNapiObject(const std::string &requestUri, napi_value &arrayBuffer,
     bool isSource, napi_env env)
 {
@@ -1249,6 +1442,7 @@ napi_status MediaAssetManagerNapi::CreateDataHandlerRef(napi_env env,
 napi_status MediaAssetManagerNapi::CreateOnDataPreparedThreadSafeFunc(napi_env env,
     const unique_ptr<MediaAssetManagerAsyncContext> &context, napi_threadsafe_function &threadSafeFunc)
 {
+    NAPI_DEBUG_LOG("CreateOnDataPreparedThreadSafeFunc");
     napi_value workName = nullptr;
     napi_create_string_utf8(env, "Data Prepared", NAPI_AUTO_LENGTH, &workName);
     napi_status status = napi_create_threadsafe_function(env, context->dataHandler, NULL, workName, 0, 1,
diff --git a/frameworks/js/src/media_library_napi.cpp b/frameworks/js/src/media_library_napi.cpp
index c50d9bf..37f8664 100644
--- a/frameworks/js/src/media_library_napi.cpp
+++ b/frameworks/js/src/media_library_napi.cpp
@@ -174,6 +174,7 @@ thread_local napi_ref MediaLibraryNapi::sResourceTypeEnumRef_ = nullptr;
 thread_local napi_ref MediaLibraryNapi::sHighlightAlbumInfoType_ = nullptr;
 thread_local napi_ref MediaLibraryNapi::sHighlightUserActionType_ = nullptr;
 thread_local napi_ref MediaLibraryNapi::sMovingPhotoEffectModeEnumRef_ = nullptr;
+thread_local napi_ref MediaLibraryNapi::sImageFileTypeEnumEnumRef_ = nullptr;
 
 constexpr int32_t DEFAULT_REFCOUNT = 1;
 constexpr int32_t DEFAULT_ALBUM_COUNT = 1;
@@ -351,6 +352,7 @@ napi_value MediaLibraryNapi::PhotoAccessHelperInit(napi_env env, napi_value expo
         DECLARE_NAPI_PROPERTY("HighlightAlbumInfoType", CreateHighlightAlbumInfoTypeEnum(env)),
         DECLARE_NAPI_PROPERTY("HighlightUserActionType", CreateHighlightUserActionTypeEnum(env)),
         DECLARE_NAPI_PROPERTY("MovingPhotoEffectMode", CreateMovingPhotoEffectModeEnum(env)),
+        DECLARE_NAPI_PROPERTY("ImageFileType", CreateImageFileTypeEnum(env)),
     };
     MediaLibraryNapiUtils::NapiAddStaticProps(env, exports, staticProps);
     return exports;
@@ -6303,6 +6305,12 @@ napi_value MediaLibraryNapi::CreateAlbumKeyEnum(napi_env env)
     return CreateStringEnumProperty(env, ALBUMKEY_ENUM_PROPERTIES, sAlbumKeyEnumRef_);
 }
 
+napi_value MediaLibraryNapi::CreateImageFileTypeEnum(napi_env env)
+{
+    const int32_t startIdx = 1;
+    return CreateNumberEnumProperty(env, imageFileTypeEnum, sImageFileTypeEnumEnumRef_, startIdx);
+}
+
 napi_value MediaLibraryNapi::CreateAlbumTypeEnum(napi_env env)
 {
     napi_value result = nullptr;
diff --git a/frameworks/js/src/photoaccesshelperinf.js b/frameworks/js/src/photoaccesshelperinf.js
index 1009856..32d30eb 100644
--- a/frameworks/js/src/photoaccesshelperinf.js
+++ b/frameworks/js/src/photoaccesshelperinf.js
@@ -720,4 +720,5 @@ export default {
   MovingPhoto: photoAccessHelper.MovingPhoto,
   MovingPhotoEffectMode: photoAccessHelper.MovingPhotoEffectMode,
   CompleteButtonText: CompleteButtonText,
+  ImageFileType: photoAccessHelper.ImageFileType,
 };
diff --git a/frameworks/js/src/userfile_client.cpp b/frameworks/js/src/userfile_client.cpp
index 8dcb4ac..7b20da3 100644
--- a/frameworks/js/src/userfile_client.cpp
+++ b/frameworks/js/src/userfile_client.cpp
@@ -21,6 +21,7 @@
 #include "medialibrary_errno.h"
 #include "medialibrary_napi_log.h"
 #include "medialibrary_helper_container.h"
+#include "media_file_utils.h"
 
 using namespace std;
 using namespace OHOS::DataShare;
diff --git a/frameworks/services/media_multistages_capture/include/deferred_processing/multistages_capture_deferred_proc_session_callback.h b/frameworks/services/media_multistages_capture/include/deferred_processing/multistages_capture_deferred_proc_session_callback.h
index 34a5722..fdb5bad 100644
--- a/frameworks/services/media_multistages_capture/include/deferred_processing/multistages_capture_deferred_proc_session_callback.h
+++ b/frameworks/services/media_multistages_capture/include/deferred_processing/multistages_capture_deferred_proc_session_callback.h
@@ -32,8 +32,10 @@ public:
     EXPORT ~MultiStagesCaptureDeferredProcSessionCallback();
 
     void OnProcessImageDone(const std::string &imageId, const uint8_t *addr, const long bytes) override;
+    void OnProcessImageDone(const std::string &imageId, std::shared_ptr<Media::Picture> picture) override;
+    void OnDeliveryLowQualityImage(const std::string &imageId, std::shared_ptr<Media::Picture> picture) override;
     EXPORT void OnError(const std::string &imageId, const CameraStandard::DpsErrorCode error) override;
-    void OnStateChanged(const CameraStandard::DpsStatusCode state) override;
+    void OnStateChanged(const CameraStandard::DpsStatusCode state) override;\
 
 private:
     EXPORT int32_t UpdatePhotoQuality(const std::string &photoId);
diff --git a/frameworks/services/media_multistages_capture/include/multistages_capture_manager.h b/frameworks/services/media_multistages_capture/include/multistages_capture_manager.h
index 1326931..d867cf0 100644
--- a/frameworks/services/media_multistages_capture/include/multistages_capture_manager.h
+++ b/frameworks/services/media_multistages_capture/include/multistages_capture_manager.h
@@ -25,6 +25,7 @@
 #include "medialibrary_type_const.h"
 #include "medialibrary_command.h"
 #include "result_set.h"
+#include "picture_manager_thread.h"
 
 namespace OHOS {
 namespace Media {
@@ -58,6 +59,11 @@ public:
 
     void AddImageInternal(int32_t fileId, const std::string &photoId, int32_t deferredProcType,
         bool discardable = false);
+    bool IsHighQualityPhotoExist(const std::string &uri);
+    void DealHighQualityPicture(const std::string &imageId, std::shared_ptr<Media::Picture> picture, bool isEdited = false);
+    void DealLowQualityPicture(const std::string &imageId, std::shared_ptr<Media::Picture> picture, bool isEdited = false);
+    void SaveLowQualityImageInfo(MediaLibraryCommand &cmd);
 
     EXPORT bool IsPhotoDeleted(const std::string &photoId);
 
@@ -78,6 +84,8 @@ private:
     std::unordered_set<int32_t> setOfDeleted_;
 
     std::shared_ptr<DeferredProcessingAdapter> deferredProcSession_;
+
+    std::mutex deferredProcMutex_;
 };
 } // namespace Media
 } // namespace OHOS
diff --git a/frameworks/services/media_multistages_capture/include/utils/file_utils.h b/frameworks/services/media_multistages_capture/include/utils/file_utils.h
index 1a8ecca..bc064a8 100644
--- a/frameworks/services/media_multistages_capture/include/utils/file_utils.h
+++ b/frameworks/services/media_multistages_capture/include/utils/file_utils.h
@@ -17,6 +17,7 @@
 #define FRAMEWORKS_SERVICES_MEDIA_MULTI_STAGES_CAPTURE_INCLUDE_FILE_UTILS_H
 
 #include <string>
+#include "picture.h"
 
 namespace OHOS {
 namespace Media {
@@ -26,6 +27,9 @@ public:
     FileUtils();
     ~FileUtils();
     EXPORT static int32_t SaveImage(const std::string &filePath, void *output, size_t writeSize);
+    EXPORT static int32_t SavePicture(const std::string &imageId, std::shared_ptr<Media::Picture> &picture, bool isEdited = false);
+    EXPORT static int32_t SavePicture(const std::string &path, std::shared_ptr<Media::Picture> &picture,
+        const std::string &mime_type, bool isEdited = false);
 
 private:
     EXPORT static int DeleteFile(const std::string &fileName);
diff --git a/frameworks/services/media_multistages_capture/src/deferred_processing/multistages_capture_deferred_proc_session_callback.cpp b/frameworks/services/media_multistages_capture/src/deferred_processing/multistages_capture_deferred_proc_session_callback.cpp
index 69f2033..20ace1b 100644
--- a/frameworks/services/media_multistages_capture/src/deferred_processing/multistages_capture_deferred_proc_session_callback.cpp
+++ b/frameworks/services/media_multistages_capture/src/deferred_processing/multistages_capture_deferred_proc_session_callback.cpp
@@ -32,6 +32,8 @@
 #include "multistages_capture_dfx_result.h"
 #include "multistages_capture_dfx_total_time.h"
 #include "multistages_capture_request_task_manager.h"
+#include "result_set_utils.h"
+#include "media_change_effect.h"
 
 using namespace std;
 using namespace OHOS::CameraStandard;
@@ -132,6 +134,107 @@ void MultiStagesCaptureDeferredProcSessionCallback::OnError(const string &imageI
     }
 }
 
+void MultiStagesCaptureDeferredProcSessionCallback::OnProcessImageDone(const std::string &imageId,
+    std::shared_ptr<Media::Picture> picture)
+{
+    MediaLibraryTracer tracer;
+    tracer.Start("OnProcessImageDone " + imageId);
+    if (picture == nullptr || picture->GetMainPixel() == nullptr) {
+        tracer.Finish();
+        MEDIA_ERR_LOG("OnProcessImageDone picture is null");
+        return;
+    }
+    // 1. 分段式拍照已经处理完成，保存全质量图
+    MEDIA_INFO_LOG("photoid: %{public}s enter", imageId.c_str());
+    MediaLibraryCommand cmd(OperationObject::FILESYSTEM_PHOTO, OperationType::QUERY);
+    string where = PhotoColumn::PHOTO_ID + " = ? ";
+    vector<string> whereArgs { imageId };
+    cmd.GetAbsRdbPredicates()->SetWhereClause(where);
+    cmd.GetAbsRdbPredicates()->SetWhereArgs(whereArgs);
+    vector<string> columns { MediaColumn::MEDIA_ID, MediaColumn::MEDIA_FILE_PATH, PhotoColumn::PHOTO_EDIT_TIME,
+        PhotoColumn::PHOTO_SUBTYPE,  MediaColumn::MEDIA_MIME_TYPE};
+    tracer.Start("Query");
+    auto resultSet = DatabaseAdapter::Query(cmd, columns);
+    if (resultSet == nullptr || resultSet->GoToFirstRow() != E_OK) {
+        tracer.Finish();
+        MEDIA_INFO_LOG("result set is empty");
+        MultiStagesCaptureDfxTotalTime::GetInstance().RemoveStartTime(imageId);
+        MultiStagesCaptureDfxResult::Report(imageId, static_cast<int32_t>(MultiStagesCaptureResultErrCode::SQL_ERR));
+        return;
+    }
+    tracer.Finish();
+    string data = GetStringVal(MediaColumn::MEDIA_FILE_PATH, resultSet);
+    bool isEdited = (GetInt64Val(PhotoColumn::PHOTO_EDIT_TIME, resultSet) > 0);
+    int32_t fileId = GetInt32Val(MediaColumn::MEDIA_ID, resultSet);
+    string mime_type = GetStringVal(MediaColumn::MEDIA_MIME_TYPE, resultSet);
+    // 如果有低质量图，落盘处理
+    MultiStagesCaptureManager::GetInstance().DealLowQualityPicture(imageId, picture, isEdited);
+    // 裸picture落盘处理
+    int ret = MediaLibraryPhotoOperations::ProcessMultistagesPhotoForPicture(isEdited, data, picture, fileId, mime_type);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("Save high quality image failed. ret: %{public}d, errno: %{public}d", ret, errno);
+        MultiStagesCaptureDfxResult::Report(imageId,
+            static_cast<int32_t>(MultiStagesCaptureResultErrCode::SAVE_IMAGE_FAIL));
+        return;
+    }
+    MultiStagesCaptureManager::GetInstance().DealHighQualityPicture(imageId, std::move(picture), isEdited);
+    MediaLibraryObjectUtils::ScanFileAsync(data, to_string(fileId), MediaLibraryApi::API_10);
+
+    // 2. 更新数据库 photoQuality 到高质量
+    int32_t subType = GetInt32Val(PhotoColumn::PHOTO_SUBTYPE, resultSet);
+    UpdatePhotoQuality(imageId);
+
+    MultiStagesCaptureDfxTotalTime::GetInstance().Report(imageId);
+    MultiStagesCaptureDfxResult::Report(imageId, static_cast<int32_t>(MultiStagesCaptureResultErrCode::SUCCESS));
+
+    // delete raw file
+    MultiStagesCaptureManager::GetInstance().RemoveImage(imageId, false);
+    MEDIA_INFO_LOG("success photoid: %{public}s", imageId.c_str());
+}
+
+void MultiStagesCaptureDeferredProcSessionCallback::OnDeliveryLowQualityImage(const std::string &imageId,
+    std::shared_ptr<Media::Picture> picture)
+{
+    MEDIA_INFO_LOG("photoid: %{public}s", imageId.c_str());
+    if (picture != nullptr && picture->GetMainPixel() != nullptr) {
+        MEDIA_INFO_LOG("OnDeliveryLowQualityImage picture is not null");
+    } else {
+        MEDIA_INFO_LOG("OnDeliveryLowQualityImage picture is null");
+        return;
+    }
+    auto pictureManagerThread = PictureManagerThread::GetInstance();
+    if (pictureManagerThread != nullptr) {
+        pictureManagerThread->Start();
+    }
+
+    MediaLibraryTracer tracer;
+    tracer.Start("OnDeliveryLowQualityImage " + imageId);
+    MediaLibraryCommand cmd(OperationObject::FILESYSTEM_PHOTO, OperationType::QUERY);
+    string where = PhotoColumn::PHOTO_ID + " = ? ";
+    vector<string> whereArgs { imageId };
+    cmd.GetAbsRdbPredicates()->SetWhereClause(where);
+    cmd.GetAbsRdbPredicates()->SetWhereArgs(whereArgs);
+    vector<string> columns { MediaColumn::MEDIA_ID, MediaColumn::MEDIA_FILE_PATH, PhotoColumn::PHOTO_EDIT_TIME,
+        PhotoColumn::PHOTO_SUBTYPE, PhotoColumn::PHOTO_QUALITY};
+    tracer.Start("Query");
+    auto resultSet = DatabaseAdapter::Query(cmd, columns);
+    if (resultSet == nullptr || resultSet->GoToFirstRow() != E_OK) {
+        tracer.Finish();
+        MEDIA_INFO_LOG("result set is empty");
+        return;
+    }
+    tracer.Finish();
+    int32_t photoQuality = GetInt32Val(PhotoColumn::PHOTO_QUALITY, resultSet);
+    string data = GetStringVal(MediaColumn::MEDIA_FILE_PATH, resultSet);
+    bool isEdited = (GetInt64Val(PhotoColumn::PHOTO_EDIT_TIME, resultSet) > 0);
+    if (photoQuality == static_cast<int32_t>(MultiStagesPhotoQuality::FULL)) {
+        FileUtils::SavePicture(imageId, picture, isEdited);
+        return;
+    }
+    MultiStagesCaptureManager::GetInstance().DealLowQualityPicture(imageId, std::move(picture), isEdited);
+    MEDIA_INFO_LOG("save low quality image end");
+}
+
 void MultiStagesCaptureDeferredProcSessionCallback::OnProcessImageDone(const string &imageId, const uint8_t *addr,
     const long bytes)
 {
diff --git a/frameworks/services/media_multistages_capture/src/multistages_capture_manager.cpp b/frameworks/services/media_multistages_capture/src/multistages_capture_manager.cpp
index 1fe3dc2..f25adda 100644
--- a/frameworks/services/media_multistages_capture/src/multistages_capture_manager.cpp
+++ b/frameworks/services/media_multistages_capture/src/multistages_capture_manager.cpp
@@ -18,6 +18,7 @@
 #include "multistages_capture_manager.h"
 
 #include "database_adapter.h"
+#include "image_packer.h"
 #include "exif_utils.h"
 #include "medialibrary_bundle_manager.h"
 #include "medialibrary_command.h"
@@ -25,7 +26,11 @@
 #include "medialibrary_rdbstore.h"
 #include "medialibrary_type_const.h"
 #include "medialibrary_tracer.h"
+#include "media_file_uri.h"
+#include "media_file_utils.h"
 #include "media_log.h"
+#include "medialibrary_formmap_operations.h"
+#include "picture_manager_thread.h"
 #include "multistages_capture_dfx_first_visit.h"
 #include "multistages_capture_dfx_request_policy.h"
 #include "multistages_capture_dfx_total_time.h"
@@ -38,6 +43,9 @@ using namespace std;
 #ifdef ABILITY_CAMERA_SUPPORT
 using namespace OHOS::CameraStandard;
 #endif
+
+#define SAVE_PICTURE_TIMEOUT_SEC 20
+
 namespace OHOS {
 namespace Media {
 
@@ -108,17 +116,95 @@ shared_ptr<OHOS::NativeRdb::ResultSet> MultiStagesCaptureManager::HandleMultiSta
             CancelRequestAndRemoveImage(columns);
             break;
         }
+        case OperationType::ADD_LOWQUALITY_IMAGE: {
+            MEDIA_DEBUG_LOG("save low quality Image");
+            SaveLowQualityImageInfo(cmd);
+            break;
+        }
         default:
             break;
     }
     return nullptr;
 }
 
+void MultiStagesCaptureManager::SaveLowQualityImageInfo(MediaLibraryCommand &cmd)
+{
+    auto values = cmd.GetValueBucket();
+    string photoId = "";
+    ValueObject valueObject;
+    if (values.GetObject(PhotoColumn::PHOTO_ID, valueObject)) {
+        valueObject.GetString(photoId);
+    }
+    int32_t deferredProcType = -1;
+    if (values.GetObject(PhotoColumn::PHOTO_DEFERRED_PROC_TYPE, valueObject)) {
+        valueObject.GetInt(deferredProcType);
+    }
+    int32_t fileId = 0;
+    if (values.GetObject(MediaColumn::MEDIA_ID, valueObject)) {
+        valueObject.GetInt(fileId);
+    }
+
+    string path = MediaLibraryFormMapOperations::GetFilePathById(ToString(fileId));
+    string uri = MediaLibraryFormMapOperations::GetUriByFileId(fileId, path.c_str());
+    auto pictureManagerThread = PictureManagerThread::GetInstance();
+    if (pictureManagerThread != nullptr) {
+        pictureManagerThread->Start();
+    }
+
+    //如果存在低质量图触发前一个落盘/20S超时落盘/二阶段图像到来落盘
+    if (pictureManagerThread->IsExsitDataForPictureType(LOW_QUALITY_PICTURE)) {
+        pictureManagerThread->SaveLowQualityPicture();
+    }
+}
+
+// 低质量入缓存
+void MultiStagesCaptureManager::DealLowQualityPicture(const std::string &imageId, std::shared_ptr<Media::Picture> picture,
+    bool isEdited)
+{
+    auto pictureManagerThread = PictureManagerThread::GetInstance();
+    if (pictureManagerThread != nullptr) {
+        pictureManagerThread->Start();
+    }
+    if (pictureManagerThread->IsExsitPictureByImageId(imageId)) {
+        return;
+    }
+    // 将新的低质量图存入缓存
+    time_t currentTime = time(NULL);
+    time_t expireTime = currentTime + SAVE_PICTURE_TIMEOUT_SEC;
+    std::string imageIdInPair = imageId;
+    sptr<PicturePair> picturePair = new PicturePair(std::move(picture), imageIdInPair, expireTime, true, false);
+    // 存低质量裸picture
+    pictureManagerThread->InsertPictureData(imageId, picturePair, LOW_QUALITY_PICTURE);
+    MEDIA_INFO_LOG("photoid: %{public}s", imageId.c_str());
+}
+
+bool MultiStagesCaptureManager::IsHighQualityPhotoExist(const std::string &uri)
+{
+    string filePath = MediaFileUri::GetPathFromUri(uri, true);
+    string filePathTemp = filePath + ".high";
+    return MediaFileUtils::IsFileExists(filePathTemp) || MediaFileUtils::IsFileExists(filePath);
+}
+
+// 高质量编辑图片存20S
+void MultiStagesCaptureManager::DealHighQualityPicture(const std::string &imageId,
+    std::shared_ptr<Media::Picture> picture, bool isEdited)
+{
+    MEDIA_INFO_LOG("photoid: %{public}s", imageId.c_str());
+    auto pictureManagerThread = PictureManagerThread::GetInstance();
+    if (pictureManagerThread != nullptr) {
+        pictureManagerThread->Start();
+    }
+    time_t currentTime = time(NULL);
+    time_t expireTime = currentTime + SAVE_PICTURE_TIMEOUT_SEC;
+    std::string imageIdInPair = imageId;
+    sptr<PicturePair> picturePair= new PicturePair(std::move(picture), imageIdInPair, expireTime, true, isEdited);
+    pictureManagerThread->InsertPictureData(imageId, picturePair, HIGH_QUALITY_PICTURE);
+}
+
 int32_t MultiStagesCaptureManager::UpdateLowQualityDbInfo(MediaLibraryCommand &cmd)
 {
     MediaLibraryCommand cmdLocal (OperationObject::FILESYSTEM_PHOTO, OperationType::UPDATE);
     auto values = cmd.GetValueBucket();
-    values.PutInt(MEDIA_DATA_DB_PHOTO_QUALITY, static_cast<int32_t>(MultiStagesPhotoQuality::LOW));
     int32_t subType = 0;
     ValueObject valueObject;
     if (values.GetObject(PhotoColumn::PHOTO_SUBTYPE, valueObject)) {
@@ -188,8 +274,15 @@ void MultiStagesCaptureManager::AddImage(MediaLibraryCommand &cmd)
     MEDIA_DEBUG_LOG("calling addImage");
     UpdateLowQualityDbInfo(cmd);
     auto values = cmd.GetValueBucket();
-    string photoId = "";
     ValueObject valueObject;
+    int32_t photoQuality = static_cast<int32_t>(MultiStagesPhotoQuality::LOW);
+    if (values.GetObject(PhotoColumn::PHOTO_QUALITY, valueObject)) {
+        valueObject.GetInt(photoQuality);
+    }
+    if (photoQuality == static_cast<int32_t>(MultiStagesPhotoQuality::FULL)) {
+        return;
+    }
+    string photoId = "";
     if (values.GetObject(PhotoColumn::PHOTO_ID, valueObject)) {
         valueObject.GetString(photoId);
     }
@@ -201,9 +294,14 @@ void MultiStagesCaptureManager::AddImage(MediaLibraryCommand &cmd)
     if (values.GetObject(MediaColumn::MEDIA_ID, valueObject)) {
         valueObject.GetInt(fileId);
     }
+
     AddImage(fileId, photoId, deferredProcType);
     MultiStagesCaptureDfxTotalTime::GetInstance().AddStartTime(photoId);
     MultiStagesCaptureDfxTriggerRatio::GetInstance().SetTrigger(MultiStagesCaptureTriggerType::AUTO);
+    if (OPRN_ADD_LOWQUALITY_IMAGE == cmd.GetQuerySetParam("save_picture")) {
+        MEDIA_DEBUG_LOG("save last low quality Image");
+        SaveLowQualityImageInfo(cmd);
+    }
 }
 
 void MultiStagesCaptureManager::SyncWithDeferredProcSessionInternal()
diff --git a/frameworks/services/media_multistages_capture/src/utils/file_utils.cpp b/frameworks/services/media_multistages_capture/src/utils/file_utils.cpp
index 707debd..e647145 100644
--- a/frameworks/services/media_multistages_capture/src/utils/file_utils.cpp
+++ b/frameworks/services/media_multistages_capture/src/utils/file_utils.cpp
@@ -20,9 +20,16 @@
 #include <sys/stat.h>
 
 #include "media_log.h"
+#include "database_adapter.h"
+#include "result_set_utils.h"
+#include "media_column.h"
+#include "image_packer.h"
 #include "medialibrary_errno.h"
 #include "medialibrary_tracer.h"
 #include "medialibrary_type_const.h"
+#include "medialibrary_operation.h"
+#include "medialibrary_object_utils.h"
+#include "picture.h"
 
 using namespace std;
 
@@ -78,5 +85,58 @@ int32_t FileUtils::SaveImage(const string &filePath, void *output, size_t writeS
     return ret;
 }
 
+int32_t FileUtils::SavePicture(const string &imageId, std::shared_ptr<Media::Picture> &picture, bool isEdited)
+{
+    MediaLibraryTracer tracer;
+    // 通过imageid获取fileid 获取uri
+    MEDIA_INFO_LOG("photoid: %{public}s", imageId.c_str());
+    MediaLibraryCommand cmd(OperationObject::FILESYSTEM_PHOTO, OperationType::QUERY);
+    string where = PhotoColumn::PHOTO_ID + " = ? ";
+    vector<string> whereArgs { imageId };
+    cmd.GetAbsRdbPredicates()->SetWhereClause(where);
+    cmd.GetAbsRdbPredicates()->SetWhereArgs(whereArgs);
+    vector<string> columns { MediaColumn::MEDIA_ID, MediaColumn::MEDIA_FILE_PATH, PhotoColumn::PHOTO_EDIT_TIME,
+        PhotoColumn::PHOTO_SUBTYPE, MediaColumn::MEDIA_MIME_TYPE};
+    tracer.Start("Query");
+    auto resultSet = DatabaseAdapter::Query(cmd, columns);
+    if (resultSet == nullptr || resultSet->GoToFirstRow() != E_OK) {
+        tracer.Finish();
+        MEDIA_INFO_LOG("result set is empty");
+        return -1;
+    }
+    tracer.Finish();
+    string path = GetStringVal(MediaColumn::MEDIA_FILE_PATH, resultSet);
+    int fileId = GetInt32Val(MediaColumn::MEDIA_ID, resultSet);
+    //查询是否编辑 编辑目录下
+    string mime_type = GetStringVal(MediaColumn::MEDIA_MIME_TYPE, resultSet);
+    if (mime_type == "") {
+        mime_type = "image/jpeg";
+    }
+    Media::ImagePacker imagePacker;
+    Media::PackOption packOption;
+    packOption.format = mime_type;
+    imagePacker.StartPacking(path, packOption);
+    imagePacker.AddPicture(*(picture));
+    imagePacker.FinalizePacking();
+    MediaLibraryObjectUtils::ScanFileAsync(path, to_string(fileId), MediaLibraryApi::API_10);
+    MEDIA_INFO_LOG("SavePicture end");
+    return 0;
+}
+
+int32_t FileUtils::SavePicture(const string &path, std::shared_ptr<Media::Picture> &picture,
+    const std::string &mime_type, bool isEdited)
+{
+    MEDIA_INFO_LOG("SavePicture width %{public}d, heigh %{public}d",
+        picture->GetMainPixel()->GetWidth(), picture->GetMainPixel()->GetHeight());
+    Media::ImagePacker imagePacker;
+    Media::PackOption packOption;
+    packOption.format = mime_type;
+    imagePacker.StartPacking(path, packOption);
+
+    imagePacker.AddPicture(*(picture));
+    imagePacker.FinalizePacking();
+    MEDIA_INFO_LOG("SavePicture end");
+    return 0;
+}
 } // namespace Media
 } // namespace OHOS
\ No newline at end of file
diff --git a/frameworks/services/media_scanner/src/scanner/media_scanner_db.cpp b/frameworks/services/media_scanner/src/scanner/media_scanner_db.cpp
index 3040def..3866672 100644
--- a/frameworks/services/media_scanner/src/scanner/media_scanner_db.cpp
+++ b/frameworks/services/media_scanner/src/scanner/media_scanner_db.cpp
@@ -211,7 +211,6 @@ static void SetValuesFromMetaDataApi10(const Metadata &metadata, ValuesBucket &v
     MediaType mediaType = metadata.GetFileMediaType();
 
     values.PutString(MediaColumn::MEDIA_FILE_PATH, metadata.GetFilePath());
-    values.PutString(MediaColumn::MEDIA_MIME_TYPE, metadata.GetFileMimeType());
     values.PutInt(MediaColumn::MEDIA_TYPE, mediaType);
     if (skipPhoto) {
         values.PutString(MediaColumn::MEDIA_NAME, metadata.GetFileName());
diff --git a/interfaces/inner_api/media_library_helper/include/media_asset_data_handler_capi.h b/interfaces/inner_api/media_library_helper/include/media_asset_data_handler_capi.h
index ae1eb13..c3f8f78 100644
--- a/interfaces/inner_api/media_library_helper/include/media_asset_data_handler_capi.h
+++ b/interfaces/inner_api/media_library_helper/include/media_asset_data_handler_capi.h
@@ -116,6 +116,7 @@ enum class ReturnDataType {
     TYPE_IMAGE_SOURCE = 0,
     TYPE_ARRAY_BUFFER,
     TYPE_TARGET_FILE,
+    TYPE_PICTURE,
 };
 
 class CapiMediaAssetDataHandler {
diff --git a/interfaces/inner_api/media_library_helper/include/media_change_effect.h b/interfaces/inner_api/media_library_helper/include/media_change_effect.h
index 2d9ca0e..fef336e 100644
--- a/interfaces/inner_api/media_library_helper/include/media_change_effect.h
+++ b/interfaces/inner_api/media_library_helper/include/media_change_effect.h
@@ -17,6 +17,7 @@
 #define MEDIA_LIBRARY_MEDIA_CHANGE_EFFECT_H
  
 #include <string>
+#include "picture.h"
  
 using std::string;
  
@@ -26,6 +27,7 @@ namespace Media {
 class MediaChangeEffect {
 public:
     static int32_t TakeEffect(const string &inputPath, const string &outputPath, string &editdata);
+    static int32_t TakeEffectForPicture(std::shared_ptr<Media::Picture>& inPicture, string &editdata);
 };
  
 } // end of namespace
diff --git a/interfaces/inner_api/media_library_helper/include/media_column.h b/interfaces/inner_api/media_library_helper/include/media_column.h
index eb7418c..f5cdd33 100644
--- a/interfaces/inner_api/media_library_helper/include/media_column.h
+++ b/interfaces/inner_api/media_library_helper/include/media_column.h
@@ -191,6 +191,12 @@ public:
     // cloud sync uri
     static const std::string PHOTO_CLOUD_URI_PREFIX EXPORT;
 
+    // cloud notify uri
+    static const std::string PHOTO_HEIGHT_ERROR_URI_PREFIX EXPORT;
+    static const std::string PHOTO_DOWNLOAD_SUCCEED_URI_PREFIX EXPORT;
+    // yuv uri
+    static const std::string PHOTO_REQUEST_PICTURE EXPORT;
+    static const std::string PHOTO_REQUEST_PICTURE_BUFFER EXPORT;
     // all columns
     static const std::set<std::string> PHOTO_COLUMNS EXPORT;
 
diff --git a/interfaces/inner_api/media_library_helper/include/media_photo_asset_proxy.h b/interfaces/inner_api/media_library_helper/include/media_photo_asset_proxy.h
index caa80b4..68f6ed1 100644
--- a/interfaces/inner_api/media_library_helper/include/media_photo_asset_proxy.h
+++ b/interfaces/inner_api/media_library_helper/include/media_photo_asset_proxy.h
@@ -62,6 +62,8 @@ private:
     static int PackAndSaveImage(int fd, const std::string &uri, const sptr<PhotoProxy> &photoProxy);
     static int32_t UpdatePhotoQuality(std::shared_ptr<DataShare::DataShareHelper> &dataShareHelper,
         const sptr<PhotoProxy> &photoProxy, int32_t fileId, int32_t subType);
+    static int SaveLowQualityPhoto(std::shared_ptr<DataShare::DataShareHelper> &dataShareHelper,
+    const sptr<PhotoProxy> &photoProxy, int32_t fileId, int32_t subType);
     static void DealWithLowQualityPhoto(std::shared_ptr<DataShare::DataShareHelper> &dataShareHelper, int fd,
         const std::string &uri, const sptr<PhotoProxy> &photoProxy);
     static void SetShootingModeAndGpsInfo(const uint8_t *data, uint32_t size,
diff --git a/interfaces/inner_api/media_library_helper/include/medialibrary_db_const.h b/interfaces/inner_api/media_library_helper/include/medialibrary_db_const.h
index c9c7bc4..e3a7755 100644
--- a/interfaces/inner_api/media_library_helper/include/medialibrary_db_const.h
+++ b/interfaces/inner_api/media_library_helper/include/medialibrary_db_const.h
@@ -381,6 +381,8 @@ const std::string MEDIA_DB_DIR = "/data/medialibrary/database";
 
 // requestId for generating thumbnail in batches
 const std::string THUMBNAIL_BATCH_GENERATE_REQUEST_ID = "thumbnail_request_id";
+const std::string IMAGE_FILE_TYPE = "image_file_type";
+
 } // namespace Media
 } // namespace OHOS
 
diff --git a/interfaces/inner_api/media_library_helper/include/photo_proxy.h b/interfaces/inner_api/media_library_helper/include/photo_proxy.h
index 43d0a69..d736e55 100644
--- a/interfaces/inner_api/media_library_helper/include/photo_proxy.h
+++ b/interfaces/inner_api/media_library_helper/include/photo_proxy.h
@@ -25,6 +25,8 @@ enum class PhotoFormat : int32_t {
     RGBA = 0,
     JPG,
     MP4,
+    HEIF,
+    YUV,
 };
 
 enum class PhotoQuality : int32_t {
diff --git a/interfaces/inner_api/media_library_helper/include/userfile_manager_types.h b/interfaces/inner_api/media_library_helper/include/userfile_manager_types.h
index 1f433f0..69a4f5a 100644
--- a/interfaces/inner_api/media_library_helper/include/userfile_manager_types.h
+++ b/interfaces/inner_api/media_library_helper/include/userfile_manager_types.h
@@ -183,6 +183,20 @@ enum class CoverSatisfiedType : int32_t {
     USER_SETTING = 2,
     ANALYSIS_SETTING = 4
 };
+
+enum ImageFileType : int32_t {
+    JPEG = 1,
+    HEIF = 2
+};
+
+const std::string MIME_TYPE_JPEG = "image/jpeg";
+
+const std::string MIME_TYPE_HEIF = "image/heif";
+
+const std::unordered_map<ImageFileType, std::string> IMAGE_FILE_TYPE_MAP = {
+    {JPEG, MIME_TYPE_JPEG},
+    {HEIF, MIME_TYPE_HEIF},
+};
 } // namespace Media
 } // namespace OHOS
 #endif // OHOS_FILEMANAGEMENT_USERFILEMGR_TYPES_H
diff --git a/interfaces/inner_api/media_library_helper/include/userfilemgr_uri.h b/interfaces/inner_api/media_library_helper/include/userfilemgr_uri.h
index 430caff..dad4aee 100644
--- a/interfaces/inner_api/media_library_helper/include/userfilemgr_uri.h
+++ b/interfaces/inner_api/media_library_helper/include/userfilemgr_uri.h
@@ -76,7 +76,7 @@ const std::string OPRN_DISCARD_CAMERA_PHOTO = "discard_camera_photo";
 const std::string OPRN_SAVE_CAMERA_PHOTO = "save_camera_photo";
 const std::string OPRN_REMOVE_MSC_TASK = "remove_msc_task"; // remove multistages capture task
 const std::string OPRN_SCAN_WITHOUT_ALBUM_UPDATE = "scan_without_album_update";
-
+const std::string OPRN_ADD_LOWQUALITY_IMAGE = "add_lowquality_image";
 // Asset operations constants
 const std::string MEDIA_FILEOPRN = "file_operation";
 const std::string MEDIA_PHOTOOPRN = "photo_operation";
@@ -271,6 +271,8 @@ const std::string PAH_START_GENERATE_THUMBNAILS =
     MEDIALIBRARY_DATA_URI + "/" + PAH_BATCH_THUMBNAIL_OPERATE + "/" + OPRN_START_GENERATE_THUMBNAILS;
 const std::string PAH_STOP_GENERATE_THUMBNAILS =
     MEDIALIBRARY_DATA_URI + "/" + PAH_BATCH_THUMBNAIL_OPERATE + "/" + OPRN_STOP_GENERATE_THUMBNAILS;
+const std::string PAH_ADD_LOWQUALITY_IMAGE = MEDIALIBRARY_DATA_URI + "/" +
+    PAH_MULTISTAGES_CAPTURE + "/" + OPRN_ADD_LOWQUALITY_IMAGE;
 
 // PhotoAccessHelper album operation constants
 const std::string PAH_CREATE_PHOTO_ALBUM = MEDIALIBRARY_DATA_URI + "/" + PAH_ALBUM + "/" + OPRN_CREATE;
@@ -366,6 +368,10 @@ const std::string MISC_OPERATION = "miscellaneous_operation";
 const std::string OPRN_LOG_MOVING_PHOTO = "log_moving_photo";
 
 const std::string LOG_MOVING_PHOTO = MEDIALIBRARY_DATA_URI + "/" + MISC_OPERATION + "/" + OPRN_LOG_MOVING_PHOTO;
+
+const std::string OPRN_FINISH_REQUEST_PICTURE = "finish_request_picture";
+const std::string PAH_FINISH_REQUEST_PICTURE = MEDIALIBRARY_DATA_URI + "/" + PAH_PHOTO + "/"
+    + OPRN_FINISH_REQUEST_PICTURE;
 } // namespace Media
 } // namespace OHOS
 
diff --git a/interfaces/kits/js/BUILD.gn b/interfaces/kits/js/BUILD.gn
index d54428a..3241179 100644
--- a/interfaces/kits/js/BUILD.gn
+++ b/interfaces/kits/js/BUILD.gn
@@ -129,6 +129,7 @@ ohos_shared_library("medialibrary_nutils") {
     "${MEDIALIB_JS_PATH}/src/napi_error.cpp",
     "${MEDIALIB_JS_PATH}/src/photo_album_napi.cpp",
     "${MEDIALIB_JS_PATH}/src/photo_proxy_napi.cpp",
+    "${MEDIALIB_JS_PATH}/src/picture_handle_client.cpp",
     "${MEDIALIB_JS_PATH}/src/smart_album_napi.cpp",
     "${MEDIALIB_JS_PATH}/src/thumbnail_manager.cpp",
     "${MEDIALIB_JS_PATH}/src/userfile_client.cpp",
@@ -172,6 +173,7 @@ ohos_shared_library("medialibrary_nutils") {
     "ipc:ipc_single",
     "ipc:rpc",
     "kv_store:distributeddata_inner",
+    "libexif:libexif",
     "napi:ace_napi",
     "player_framework:media_client",
     "relational_store:native_rdb",
@@ -253,6 +255,10 @@ ohos_shared_library("medialibrary") {
   if (defined(medialibrary_mtp_enable)) {
     defines += [ "MEDIALIBRARY_MTP_ENABLE=1" ]
   }
+  if (defined(global_parts_info) &&
+      defined(global_parts_info.open_source_libyuv)) {
+    defines += [ "EXT_PIXEL" ]
+  }
   if (!media_library_link_opt) {
     sanitize = {
       cfi = true
diff --git a/interfaces/kits/js/include/media_asset_change_request_napi.h b/interfaces/kits/js/include/media_asset_change_request_napi.h
index 95236e5..322b03e 100644
--- a/interfaces/kits/js/include/media_asset_change_request_napi.h
+++ b/interfaces/kits/js/include/media_asset_change_request_napi.h
@@ -27,6 +27,7 @@
 #include "media_change_request_napi.h"
 #include "photo_proxy.h"
 #include "unique_fd.h"
+#include "userfile_manager_types.h"
 #include "values_bucket.h"
 
 namespace OHOS {
@@ -105,6 +106,8 @@ public:
     int32_t CreateAssetBySecurityComponent(std::string& assetUri);
     napi_value ApplyChanges(napi_env env, napi_callback_info info) override;
     int32_t PutMediaAssetEditData(DataShare::DataShareValuesBucket& valuesBucket);
+    void SetImageFileType(int32_t imageFileType);
+    int32_t GetImageFileType();
 
     sptr<PhotoProxy> GetPhotoProxyObj();
     void ReleasePhotoProxyObj();
@@ -160,6 +163,7 @@ private:
     int32_t currentEffectMode_;
     std::vector<ResourceType> addResourceTypes_; // support adding resource multiple times
     std::vector<AssetChangeOperation> assetChangeOperations_;
+    int32_t imageFileType_;
 };
 
 struct MediaAssetChangeRequestAsyncContext : public NapiError {
diff --git a/interfaces/kits/js/include/media_asset_data_handler.h b/interfaces/kits/js/include/media_asset_data_handler.h
index 1835f88..95ab203 100644
--- a/interfaces/kits/js/include/media_asset_data_handler.h
+++ b/interfaces/kits/js/include/media_asset_data_handler.h
@@ -25,6 +25,7 @@ enum class ReturnDataType {
     TYPE_ARRAY_BUFFER,
     TYPE_MOVING_PHOTO,
     TYPE_TARGET_PATH,
+    TYPE_PICTURE,
 };
 
 enum class DeliveryMode {
@@ -56,7 +57,8 @@ public:
     SourceMode GetSourceMode();
     void SetNotifyMode(NotifyMode trigger);
     NotifyMode GetNotifyMode();
-    void JsOnDataPrepared(napi_env env, napi_value exports, napi_value extraInfo = nullptr);
+    void JsOnDataPrepared(napi_env env, napi_value exports, napi_value extraInfo);
+    void JsOnDataPrepared(napi_env env, napi_value pictures, napi_value exports, napi_value extraInfo);
 
 private:
     napi_env env_ = nullptr;
diff --git a/interfaces/kits/js/include/media_asset_manager_napi.h b/interfaces/kits/js/include/media_asset_manager_napi.h
index fb79bba..eb1d827 100644
--- a/interfaces/kits/js/include/media_asset_manager_napi.h
+++ b/interfaces/kits/js/include/media_asset_manager_napi.h
@@ -109,6 +109,8 @@ public:
         napi_env env);
     static void GetImageSourceNapiObject(const std::string &fileUri, napi_value &imageSourceNapiObj, bool isSource,
         napi_env env);
+    static void GetPictureNapiObject(const std::string &fileUri, napi_value &imageSourceNapiObj, bool isSource,
+        napi_env env, bool& isPicture);
     static void WriteDataToDestPath(std::string requestUri, std::string destUri, napi_value& resultNapiValue,
         bool isSource, napi_env env);
 
@@ -118,7 +120,10 @@ private:
     static bool InitUserFileClient(napi_env env, napi_callback_info info);
     static napi_status ParseRequestMediaArgs(napi_env env, napi_callback_info info,
         unique_ptr<MediaAssetManagerAsyncContext> &asyncContext);
+    static napi_status ParseEfficentRequestMediaArgs(napi_env env, napi_callback_info info,
+        unique_ptr<MediaAssetManagerAsyncContext> &asyncContext);
     static napi_value JSRequestImage(napi_env env, napi_callback_info info);
+    static napi_value JSRequestEfficientIImage(napi_env env, napi_callback_info info);
     static napi_value JSRequestImageData(napi_env env, napi_callback_info info);
     static napi_value JSRequestMovingPhoto(napi_env env, napi_callback_info info);
     static napi_value JSRequestVideoFile(napi_env env, napi_callback_info info);
diff --git a/interfaces/kits/js/include/media_library_napi.h b/interfaces/kits/js/include/media_library_napi.h
index 105518b..93b5f11 100644
--- a/interfaces/kits/js/include/media_library_napi.h
+++ b/interfaces/kits/js/include/media_library_napi.h
@@ -309,6 +309,7 @@ private:
     EXPORT static napi_value CreateHighlightAlbumInfoTypeEnum(napi_env env);
     EXPORT static napi_value CreateHighlightUserActionTypeEnum(napi_env env);
     EXPORT static napi_value CreateMovingPhotoEffectModeEnum(napi_env env);
+    EXPORT static napi_value CreateImageFileTypeEnum(napi_env env);
 
     EXPORT static napi_value CreatePhotoAlbum(napi_env env, napi_callback_info info);
     EXPORT static napi_value DeletePhotoAlbums(napi_env env, napi_callback_info info);
@@ -361,6 +362,7 @@ private:
     static thread_local napi_ref sHighlightAlbumInfoType_;
     static thread_local napi_ref sHighlightUserActionType_;
     static thread_local napi_ref sMovingPhotoEffectModeEnumRef_;
+    static thread_local napi_ref sImageFileTypeEnumEnumRef_;
 
     static std::mutex sOnOffMutex_;
 };
diff --git a/interfaces/kits/js/include/medialibrary_napi_utils.h b/interfaces/kits/js/include/medialibrary_napi_utils.h
index 540dee0..14db445 100644
--- a/interfaces/kits/js/include/medialibrary_napi_utils.h
+++ b/interfaces/kits/js/include/medialibrary_napi_utils.h
@@ -331,6 +331,10 @@ const std::vector<std::string> movingPhotoEffectModeEnum {
     "DEFAULT", "BOUNCE_PLAY", "LOOP_PLAY", "LONG_EXPOSURE", "MULTI_EXPOSURE", "CINEMA_GRAPH"
 };
 
+const std::vector<std::string> imageFileTypeEnum {
+    "JPEG", "HEIF"
+};
+
 const std::vector<std::string> fileKeyEnumValues {
     MEDIA_DATA_DB_ID,
     MEDIA_DATA_DB_RELATIVE_PATH,
