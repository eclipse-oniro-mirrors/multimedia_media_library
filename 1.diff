From c8dfb0f75b4c268375cc94e4255686de7e39750e Mon Sep 17 00:00:00 2001
From: l30040612 <l30040612@notesmail.huawei.com/>
Date: Wed, 11 Jun 2025 15:47:47 +0800
Subject: [PATCH] =?UTF-8?q?=E5=BC=BA=E5=9F=BA=E6=9F=A5=E8=AF=A2=E7=B1=BB?=
 =?UTF-8?q?=E6=8E=A5=E5=8F=A3=E4=BA=A4=E4=BB=98=E7=89=88=E6=9C=AC=20Change?=
 =?UTF-8?q?-Id:=20I1a3121f2cf97a984f9fc46b5f09c2427957b1666?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 .../medialibrary_data_extension/BUILD.gn      |  27 +
 .../include/ipc/medialibrary_business_code.h  |  30 +
 .../include/medialibrary_command.h            |   1 +
 .../include/medialibrary_data_manager.h       |   5 +-
 .../include/medialibrary_photo_operations.h   |   5 +
 .../src/medialibrary_command.cpp              |   5 +
 .../src/medialibrary_data_manager.cpp         |   5 +-
 .../src/medialibrary_photo_operations.cpp     |   8 +-
 .../BUILD.gn                                  |  18 +
 .../include/album_get_assets_test.h           |  32 +
 .../include/get_albums_by_ids_test.h          |  32 +
 .../include/get_data_analysis_process_test.h  |  32 +
 .../include/get_face_id_test.h                |  32 +
 .../include/get_highlight_album_info_test.h   |  32 +
 .../include/get_order_position_test.h         |  32 +
 .../include/get_photo_index_test.h            |  32 +
 .../include/media_albums_controller_test.h    |  32 +
 .../include/query_albums_test.h               |  32 +
 .../src/album_add_assets_test.cpp             |  13 +
 .../src/album_commit_modify_test.cpp          |  13 +
 .../src/album_delete_assets_test.cpp          |  13 +
 .../src/album_get_assets_test.cpp             | 241 ++++++
 .../src/album_recover_assets_test.cpp         |  13 +
 .../src/album_remove_assets_test.cpp          |  14 +
 .../src/album_set_cover_uri_test.cpp          |  13 +
 .../src/change_assets_test.cpp                | 145 ++++
 .../src/create_album_test.cpp                 |   4 -
 .../src/get_albums_by_ids_test.cpp            | 124 +++
 .../src/get_data_analysis_process_test.cpp    | 319 +++++++
 .../src/get_face_id_test.cpp                  | 186 ++++
 .../src/get_highlight_album_info_test.cpp     | 105 +++
 .../src/get_order_position_test.cpp           | 234 +++++
 .../src/get_photo_index_test.cpp              | 239 ++++++
 .../src/media_albums_controller_test.cpp      | 111 +++
 .../src/query_albums_test.cpp                 | 291 +++++++
 .../BUILD.gn                                  |  23 +
 .../include/get_asset_analysis_data_test.h    |  32 +
 .../include/get_assets_test.h                 |  32 +
 .../include/get_cloud_enhancement_pair_test.h |  32 +
 .../get_index_construct_progress_test.h       |  32 +
 .../include/media_assets_controller_test.h    |  32 +
 .../query_cloud_enhancement_task_state_test.h |  32 +
 .../include/queue_edit_asset_status_test.h    |  32 +
 .../include/request_content_test.h            |  32 +
 .../include/request_image_test.h              |  32 +
 .../sync_cloud_enhancement_task_status_test.h |  32 +
 .../src/asset_change_request_test.cpp         |   6 -
 .../src/cloud_media_change_test.cpp           |  23 +-
 .../src/create_asset_test.cpp                 | 144 ++--
 .../src/get_asset_analysis_data_test.cpp      | 284 ++++++
 .../src/get_assets_test.cpp                   | 357 ++++++++
 .../src/get_cloud_enhancement_pair_test.cpp   | 213 +++++
 .../src/get_index_construct_progress_test.cpp | 179 ++++
 .../src/media_assets_controller_test.cpp      | 111 +++
 ...uery_cloud_enhancement_task_state_test.cpp | 194 +++++
 .../src/queue_edit_asset_status_test.cpp      | 289 +++++++
 .../src/request_content_test.cpp              | 185 ++++
 .../src/request_image_test.cpp                | 158 ++++
 .../src/set_favorite_test.cpp                 |  13 +
 .../src/set_hidden_test.cpp                   |  13 +
 .../src/stop_thumbnail_creation_task_test.cpp |   7 +-
 ...ync_cloud_enhancement_task_status_test.cpp |  89 ++
 .../src/media_permission_check_test.cpp       |  12 +
 frameworks/js/src/cloud_enhancement_napi.cpp  |  60 +-
 .../js/src/cloud_media_asset_manager_napi.cpp |  14 +-
 frameworks/js/src/file_asset_napi.cpp         | 234 +++--
 frameworks/js/src/highlight_album_napi.cpp    |  90 +-
 .../src/media_asset_change_request_napi.cpp   |   1 -
 .../js/src/media_asset_manager_napi.cpp       |  75 +-
 .../src/media_assets_change_request_napi.cpp  |   2 +-
 frameworks/js/src/media_library_napi.cpp      | 807 +++++++++++-------
 frameworks/js/src/moving_photo_napi.cpp       |  33 +
 frameworks/js/src/photo_album_napi.cpp        |  50 +-
 frameworks/js/src/userfile_client.cpp         |  10 +
 frameworks/utils/include/parameter_utils.h    |   1 +
 frameworks/utils/src/parameter_utils.cpp      |  17 +
 interfaces/kits/js/BUILD.gn                   |  23 +-
 .../kits/js/include/media_library_napi.h      |   7 +-
 interfaces/kits/js/include/photo_album_napi.h |   1 +
 interfaces/kits/js/include/userfile_client.h  |   3 +
 .../media_albums_controller_service.h         |   9 +
 .../include/dto/album_get_assets_dto.h        |  30 +
 .../include/dto/get_order_position_dto.h      |  32 +
 .../include/dto/query_albums_dto.h            |  38 +
 .../include/media_albums_rdb_operations.h     |   1 +
 .../include/media_albums_service.h            |  17 +
 .../include/vo/album_get_assets_vo.h          |  41 +
 .../include/vo/get_albums_by_ids_vo.h         |  54 ++
 .../include/vo/get_analysis_process_vo.h      |  35 +
 .../include/vo/get_face_id_vo.h               |  47 +
 .../include/vo/get_highlight_album_info_vo.h  |  37 +
 .../include/vo/get_order_position_vo.h        |  45 +
 .../include/vo/get_photo_index_vo.h           |  37 +
 .../include/vo/query_albums_vo.h              |  50 ++
 .../include/vo/query_result_vo.h              |  35 +
 .../media_albums_controller_service.cpp       | 305 ++++++-
 .../media_albums_permission_policy.cpp        |  18 +
 .../src/dto/album_get_assets_dto.cpp          |  26 +
 .../src/dto/get_order_position_dto.cpp        |  40 +
 .../src/media_albums_rdb_operations.cpp       |  14 +
 .../src/media_albums_service.cpp              | 432 +++++++++-
 .../src/vo/album_get_assets_vo.cpp            |  54 ++
 .../src/vo/get_albums_by_ids_vo.cpp           |  81 ++
 .../src/vo/get_analysis_process_vo.cpp        |  34 +
 .../src/vo/get_face_id_vo.cpp                 |  57 ++
 .../src/vo/get_highlight_album_info_vo.cpp    |  46 +
 .../src/vo/get_order_position_vo.cpp          |  66 ++
 .../src/vo/get_photo_index_vo.cpp             |  53 ++
 .../src/vo/query_albums_vo.cpp                |  61 ++
 .../src/vo/query_result_vo.cpp                |  46 +
 .../media_assets_controller_service.h         |  13 +-
 .../include/dto/create_asset_dto.h            |   7 +
 .../include/dto/get_asset_analysis_data_dto.h |  36 +
 .../include/dto/get_assets_dto.h              |  30 +
 .../query_cloud_enhancement_task_state_dto.h  |  34 +
 .../include/media_assets_rdb_operations.h     |   2 +
 .../include/media_assets_service.h            |  17 +
 .../include/vo/adapted_vo.h                   |  33 +
 .../include/vo/create_asset_vo.h              |   8 -
 .../include/vo/get_asset_analysis_data_vo.h   |  49 ++
 .../include/vo/get_assets_vo.h                |  42 +
 .../vo/get_cloud_enhancement_pair_vo.h        |  45 +
 .../vo/get_cloudmedia_asset_status_vo.h       |  36 +
 .../include/vo/get_edit_data_vo.h             |  51 ++
 .../vo/get_index_construct_progress_vo.h      |  30 +
 .../include/vo/is_edited_vo.h                 |  48 ++
 .../include/vo/modify_assets_vo.h             |   1 -
 .../query_cloud_enhancement_task_state_vo.h   |  50 ++
 .../include/vo/query_photo_vo.h               |  44 +
 .../include/vo/request_content_vo.h           |  42 +
 .../include/vo/request_edit_data_vo.h         |  51 ++
 .../include/vo/start_asset_analysis_vo.h      |  51 ++
 .../media_assets_controller_service.cpp       | 556 +++++++++++-
 .../media_assets_permission_policy.cpp        |  25 +-
 .../src/dto/create_asset_dto.cpp              |  50 ++
 .../src/dto/get_assets_dto.cpp                |  26 +
 ...query_cloud_enhancement_task_state_dto.cpp |  36 +
 .../src/media_assets_rdb_operations.cpp       |  22 +
 .../src/media_assets_service.cpp              | 345 ++++++--
 .../src/vo/adapted_vo.cpp                     |  31 +
 .../src/vo/create_asset_vo.cpp                |  29 -
 .../src/vo/get_asset_analysis_data_vo.cpp     |  56 ++
 .../src/vo/get_assets_vo.cpp                  |  54 ++
 .../src/vo/get_cloud_enhancement_pair_vo.cpp  |  63 ++
 .../src/vo/get_cloudmedia_asset_status_vo.cpp |  42 +
 .../src/vo/get_edit_data_vo.cpp               |  75 ++
 .../vo/get_index_construct_progress_vo.cpp    |  31 +
 .../src/vo/is_edited_vo.cpp                   |  65 ++
 .../query_cloud_enhancement_task_state_vo.cpp |  87 ++
 .../src/vo/query_photo_vo.cpp                 |  46 +
 .../src/vo/request_content_vo.cpp             |  54 ++
 .../src/vo/request_edit_data_vo.cpp           |  74 ++
 .../src/vo/start_asset_analysis_vo.cpp        |  75 ++
 .../include/media_cloud_permission_check.h    |  31 +
 .../include/media_permission_policy_type.h    |   4 +-
 .../media_business_code_permission_map.cpp    |  28 +-
 .../src/media_cloud_permission_check.cpp      |  40 +
 .../src/media_permission_check.cpp            |   5 +-
 158 files changed, 10301 insertions(+), 728 deletions(-)
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/album_get_assets_test.h
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_albums_by_ids_test.h
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_data_analysis_process_test.h
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_face_id_test.h
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_highlight_album_info_test.h
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_order_position_test.h
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_photo_index_test.h
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/media_albums_controller_test.h
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/query_albums_test.h
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_get_assets_test.cpp
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_albums_by_ids_test.cpp
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_data_analysis_process_test.cpp
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_face_id_test.cpp
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_highlight_album_info_test.cpp
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_order_position_test.cpp
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_photo_index_test.cpp
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/media_albums_controller_test.cpp
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/query_albums_test.cpp
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_asset_analysis_data_test.h
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_assets_test.h
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_cloud_enhancement_pair_test.h
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_index_construct_progress_test.h
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/media_assets_controller_test.h
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/query_cloud_enhancement_task_state_test.h
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/queue_edit_asset_status_test.h
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/request_content_test.h
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/request_image_test.h
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/sync_cloud_enhancement_task_status_test.h
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_asset_analysis_data_test.cpp
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_assets_test.cpp
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_cloud_enhancement_pair_test.cpp
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_index_construct_progress_test.cpp
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/media_assets_controller_test.cpp
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/query_cloud_enhancement_task_state_test.cpp
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/queue_edit_asset_status_test.cpp
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/request_content_test.cpp
 create mode 100644 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/request_image_test.cpp
 create mode 100755 frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/sync_cloud_enhancement_task_status_test.cpp
 create mode 100755 services/media_albums_manager/include/dto/album_get_assets_dto.h
 create mode 100755 services/media_albums_manager/include/dto/get_order_position_dto.h
 create mode 100644 services/media_albums_manager/include/dto/query_albums_dto.h
 create mode 100755 services/media_albums_manager/include/vo/album_get_assets_vo.h
 create mode 100644 services/media_albums_manager/include/vo/get_albums_by_ids_vo.h
 create mode 100644 services/media_albums_manager/include/vo/get_analysis_process_vo.h
 create mode 100644 services/media_albums_manager/include/vo/get_face_id_vo.h
 create mode 100644 services/media_albums_manager/include/vo/get_highlight_album_info_vo.h
 create mode 100755 services/media_albums_manager/include/vo/get_order_position_vo.h
 create mode 100644 services/media_albums_manager/include/vo/get_photo_index_vo.h
 create mode 100644 services/media_albums_manager/include/vo/query_albums_vo.h
 create mode 100644 services/media_albums_manager/include/vo/query_result_vo.h
 create mode 100755 services/media_albums_manager/src/dto/album_get_assets_dto.cpp
 create mode 100755 services/media_albums_manager/src/dto/get_order_position_dto.cpp
 create mode 100644 services/media_albums_manager/src/vo/album_get_assets_vo.cpp
 create mode 100644 services/media_albums_manager/src/vo/get_albums_by_ids_vo.cpp
 create mode 100755 services/media_albums_manager/src/vo/get_analysis_process_vo.cpp
 create mode 100644 services/media_albums_manager/src/vo/get_face_id_vo.cpp
 create mode 100644 services/media_albums_manager/src/vo/get_highlight_album_info_vo.cpp
 create mode 100755 services/media_albums_manager/src/vo/get_order_position_vo.cpp
 create mode 100755 services/media_albums_manager/src/vo/get_photo_index_vo.cpp
 create mode 100644 services/media_albums_manager/src/vo/query_albums_vo.cpp
 create mode 100755 services/media_albums_manager/src/vo/query_result_vo.cpp
 create mode 100644 services/media_assets_manager/include/dto/get_asset_analysis_data_dto.h
 create mode 100755 services/media_assets_manager/include/dto/get_assets_dto.h
 create mode 100644 services/media_assets_manager/include/dto/query_cloud_enhancement_task_state_dto.h
 create mode 100644 services/media_assets_manager/include/vo/adapted_vo.h
 create mode 100644 services/media_assets_manager/include/vo/get_asset_analysis_data_vo.h
 create mode 100755 services/media_assets_manager/include/vo/get_assets_vo.h
 create mode 100644 services/media_assets_manager/include/vo/get_cloud_enhancement_pair_vo.h
 create mode 100644 services/media_assets_manager/include/vo/get_cloudmedia_asset_status_vo.h
 create mode 100644 services/media_assets_manager/include/vo/get_edit_data_vo.h
 create mode 100755 services/media_assets_manager/include/vo/get_index_construct_progress_vo.h
 create mode 100644 services/media_assets_manager/include/vo/is_edited_vo.h
 create mode 100644 services/media_assets_manager/include/vo/query_cloud_enhancement_task_state_vo.h
 create mode 100644 services/media_assets_manager/include/vo/query_photo_vo.h
 create mode 100755 services/media_assets_manager/include/vo/request_content_vo.h
 create mode 100644 services/media_assets_manager/include/vo/request_edit_data_vo.h
 create mode 100644 services/media_assets_manager/include/vo/start_asset_analysis_vo.h
 create mode 100644 services/media_assets_manager/src/dto/create_asset_dto.cpp
 create mode 100755 services/media_assets_manager/src/dto/get_assets_dto.cpp
 create mode 100644 services/media_assets_manager/src/dto/query_cloud_enhancement_task_state_dto.cpp
 create mode 100644 services/media_assets_manager/src/vo/adapted_vo.cpp
 create mode 100644 services/media_assets_manager/src/vo/get_asset_analysis_data_vo.cpp
 create mode 100644 services/media_assets_manager/src/vo/get_assets_vo.cpp
 create mode 100644 services/media_assets_manager/src/vo/get_cloud_enhancement_pair_vo.cpp
 create mode 100644 services/media_assets_manager/src/vo/get_cloudmedia_asset_status_vo.cpp
 create mode 100644 services/media_assets_manager/src/vo/get_edit_data_vo.cpp
 create mode 100644 services/media_assets_manager/src/vo/get_index_construct_progress_vo.cpp
 create mode 100644 services/media_assets_manager/src/vo/is_edited_vo.cpp
 create mode 100644 services/media_assets_manager/src/vo/query_cloud_enhancement_task_state_vo.cpp
 create mode 100644 services/media_assets_manager/src/vo/query_photo_vo.cpp
 create mode 100755 services/media_assets_manager/src/vo/request_content_vo.cpp
 create mode 100644 services/media_assets_manager/src/vo/request_edit_data_vo.cpp
 create mode 100644 services/media_assets_manager/src/vo/start_asset_analysis_vo.cpp
 create mode 100755 services/media_permission/include/media_cloud_permission_check.h
 create mode 100755 services/media_permission/src/media_cloud_permission_check.cpp

diff --git a/frameworks/innerkitsimpl/medialibrary_data_extension/BUILD.gn b/frameworks/innerkitsimpl/medialibrary_data_extension/BUILD.gn
index 457b8dde63..bae483d61c 100644
--- a/frameworks/innerkitsimpl/medialibrary_data_extension/BUILD.gn
+++ b/frameworks/innerkitsimpl/medialibrary_data_extension/BUILD.gn
@@ -404,6 +404,8 @@ ohos_shared_library("medialibrary_data_extension") {
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/add_image_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/save_camera_photo_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/trash_photos_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_assets_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_index_construct_progress_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/revert_to_original_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/cloud_enhancement_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/modify_assets_vo.cpp",
@@ -414,9 +416,21 @@ ohos_shared_library("medialibrary_data_extension") {
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/cancel_photo_uri_permission_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/start_thumbnail_creation_task_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/stop_thumbnail_creation_task_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_asset_analysis_data_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/is_edited_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/request_edit_data_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_edit_data_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/start_asset_analysis_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_cloudmedia_asset_status_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/request_content_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_cloud_enhancement_pair_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/query_cloud_enhancement_task_state_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/query_photo_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/adapted_vo.cpp",
   ]
 
   media_assets_manager_dto_source = [
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/dto/create_asset_dto.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/dto/commit_edited_asset_dto.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/dto/form_info_dto.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/dto/cloud_enhancement_dto.cpp",
@@ -425,6 +439,7 @@ ohos_shared_library("medialibrary_data_extension") {
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/dto/submit_cache_dto.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/dto/add_image_dto.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/dto/save_camera_photo_dto.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/dto/get_assets_dto.cpp",
   ]
 
   media_albums_manager_source = [
@@ -459,6 +474,15 @@ ohos_shared_library("medialibrary_data_extension") {
     "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/album_remove_assets_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/album_recover_assets_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/album_photo_query_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/album_get_assets_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/query_albums_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_albums_by_ids_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_order_position_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_face_id_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_analysis_process_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_highlight_album_info_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_photo_index_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/query_result_vo.cpp",
   ]
 
   media_albums_manager_dto_source = [
@@ -469,6 +493,8 @@ ohos_shared_library("medialibrary_data_extension") {
     "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/dto/album_add_assets_dto.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/dto/album_remove_assets_dto.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/dto/album_recover_assets_dto.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/dto/album_get_assets_dto.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/dto/get_order_position_dto.cpp",
   ]
 
   media_permission_check_source = [
@@ -482,6 +508,7 @@ ohos_shared_library("medialibrary_data_extension") {
     "${MEDIALIB_BUSINESS_PATH}/media_permission/src/media_cloudfile_sync_permission_check.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_permission/src/media_db_permission_check.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_permission/src/media_permission_header_req.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_permission/src/media_cloud_permission_check.cpp",
   ]
 
   sources = [
diff --git a/frameworks/innerkitsimpl/medialibrary_data_extension/include/ipc/medialibrary_business_code.h b/frameworks/innerkitsimpl/medialibrary_data_extension/include/ipc/medialibrary_business_code.h
index fd1cd40405..e4e4a4dd30 100755
--- a/frameworks/innerkitsimpl/medialibrary_data_extension/include/ipc/medialibrary_business_code.h
+++ b/frameworks/innerkitsimpl/medialibrary_data_extension/include/ipc/medialibrary_business_code.h
@@ -32,6 +32,11 @@ enum class MediaLibraryBusinessCode : uint32_t {
     PAH_OPEN,
     PAH_START_THUMBNAIL_CREATION_TASK,
     PAH_STOP_THUMBNAIL_CREATION_TASK,
+    GET_CLOUD_ENHANCEMENT_PAIR,
+    QUERY_CLOUD_ENHANCEMENT_TASK_STATE,
+    SYNC_CLOUD_ENHANCEMENT_TASK_STATUS,
+    GET_ANALYSIS_PROCESS,
+    MEDIA_BUSINESS_CODE_END,
     ASSETS_BUSINESS_CODE_START = 10000,
     CLONE_ASSET,
     REVERT_TO_ORIGINAL,
@@ -50,6 +55,7 @@ enum class MediaLibraryBusinessCode : uint32_t {
     PAH_SYSTEM_BATCH_SET_FAVORITE,
     PAH_SYSTEM_BATCH_SET_RECENT_SHOW,
     PAH_SYSTEM_BATCH_SET_USER_COMMENT,
+    PAH_GET_ASSET_ANALYSIS_DATA,
     PAH_SYS_TRASH_PHOTOS,
     PAH_TRASH_PHOTOS,
     PAH_DELETE_PHOTOS,
@@ -77,10 +83,26 @@ enum class MediaLibraryBusinessCode : uint32_t {
     SET_ORIENTATION,
     SET_VIDEO_ENHANCEMENT_ATTR,
     SET_SUPPORTED_WATERMARK_TYPE,
+    PAH_GET_ASSETS,
+    GET_BURST_ASSETS,
+    FIND_ALL_DUPLICATE_ASSETS,
+    FIND_DUPLICATE_ASSETS_TO_DELETE,
+    GET_INDEX_CONSTRUCT_PROGRESS,
+    QUEUE_IS_EDITED,
+    QUEUE_REQUEST_EDIT_DATA,
+    QUEUE_GET_EDIT_DATA,
+    QUEUE_GET_CLOUDMEDIA_ASSET_STATUS,
+    QUEUE_START_ASSET_ANALYSIS,
+    PAH_REQUEST_CONTENT,
+    QUERY_PHOTO_STATUS,
+    LOG_MOVING_PHOTO,
+    ASSETS_BUSINESS_CODE_END,
     ALBUMS_BUSINESS_CODE_START = 20000,
     DELETE_HIGH_LIGHT_ALBUMS,
     PAH_SYSTEM_CREATE_ALBUM,
     PAH_DELETE_PHOTO_ALBUMS,
+    ALBUM_SYS_GET_ASSETS,
+    ALBUM_GET_ASSETS,
     CHANGE_REQUEST_SET_ALBUM_NAME,
     CHANGE_REQUEST_SET_COVER_URI,
     CHANGE_REQUEST_SET_IS_ME,
@@ -102,6 +124,14 @@ enum class MediaLibraryBusinessCode : uint32_t {
     PAH_REMOVE_ASSETS,
     PAH_RECOVER_ASSETS,
     PAH_SET_COVER_URI,
+    PAH_QUERY_PHOTO_ALBUMS,
+    PAH_QUERY_HIDDEN_ALBUMS,
+    PAH_GET_ORDER_POSITION,
+    PAH_QUEUE_GET_ALBUMS_BY_IDS,
+    GET_FACE_ID,
+    GET_PHOTO_INDEX,
+    GET_HIGHLIGHT_ALBUM_INFO,
+    ALBUMS_BUSINESS_CODE_END,
     MEDIA_CLOUD_CODE_START = 30000,
     MEDIA_CLOUD_CODE_END = 39999,
 };
diff --git a/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_command.h b/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_command.h
index 6eeecbd16d..51ccc6f761 100644
--- a/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_command.h
+++ b/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_command.h
@@ -44,6 +44,7 @@ public:
         const std::string &networkId, MediaLibraryApi api = MediaLibraryApi::API_OLD);
     MediaLibraryCommand(const std::string &tableName);
     EXPORT MediaLibraryCommand(const NativeRdb::ValuesBucket &value) : insertValue_(value) {}
+    MediaLibraryCommand(const DataShare::DataSharePredicates &pred);
     EXPORT MediaLibraryCommand() = delete;
     EXPORT ~MediaLibraryCommand();
     EXPORT MediaLibraryCommand(const MediaLibraryCommand &) = delete;
diff --git a/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_data_manager.h b/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_data_manager.h
index 577d8d2fed..6316fd4396 100644
--- a/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_data_manager.h
+++ b/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_data_manager.h
@@ -75,7 +75,10 @@ public:
     EXPORT void NotifyChange(const Uri &uri);
     EXPORT int32_t GenerateThumbnailBackground();
     EXPORT int32_t GenerateHighlightThumbnailBackground();
-
+    EXPORT static std::shared_ptr<NativeRdb::ResultSet> QueryAnalysisAlbum(MediaLibraryCommand &cmd,
+        const std::vector<std::string> &columns, const DataShare::DataSharePredicates &predicates);
+    EXPORT static std::shared_ptr<NativeRdb::ResultSet> QueryGeo(const NativeRdb::RdbPredicates &rdbPredicates,
+        const std::vector<std::string> &columns);
     // upgrade existed thumbnails to fix such as size, rotation and quality etc. problems
     EXPORT int32_t UpgradeThumbnailBackground(bool isWifiConnected);
 
diff --git a/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_photo_operations.h b/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_photo_operations.h
index 4a313de45d..38bee9ad33 100644
--- a/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_photo_operations.h
+++ b/frameworks/innerkitsimpl/medialibrary_data_extension/include/medialibrary_photo_operations.h
@@ -26,6 +26,7 @@
 #include "medialibrary_asset_operations.h"
 #include "medialibrary_command.h"
 #include "picture.h"
+#include "rdb_predicates.h"
 
 namespace OHOS {
 namespace Media {
@@ -112,6 +113,10 @@ public:
     static int32_t SaveCameraPhoto(MediaLibraryCommand &cmd);
     static int32_t DiscardCameraPhoto(MediaLibraryCommand &cmd);
 
+    EXPORT static std::shared_ptr<NativeRdb::ResultSet> HandleIndexOfUri(MediaLibraryCommand &cmd,
+        NativeRdb::RdbPredicates &predicates, const std::string &photoId, const std::string &albumId);
+    EXPORT static std::shared_ptr<NativeRdb::ResultSet> HandleAnalysisIndex(MediaLibraryCommand &cmd,
+        const std::string &photoId, const std::string &albumId);
 private:
     static int32_t CreateV9(MediaLibraryCommand &cmd);
     static int32_t CreateV10(MediaLibraryCommand &cmd);
diff --git a/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_command.cpp b/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_command.cpp
index 7571f77153..232b07a24a 100644
--- a/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_command.cpp
+++ b/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_command.cpp
@@ -85,6 +85,11 @@ MediaLibraryCommand::MediaLibraryCommand(const string& tableName)
     this->SetTableName(tableName);
 }
 
+MediaLibraryCommand::MediaLibraryCommand(const DataShare::DataSharePredicates &pred)
+{
+    this->SetDataSharePred(pred);
+}
+
 MediaLibraryCommand::~MediaLibraryCommand() {}
 
 // set functions
diff --git a/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_data_manager.cpp b/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_data_manager.cpp
index 0d059dc2c3..3fdaf2dbb3 100644
--- a/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_data_manager.cpp
+++ b/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_data_manager.cpp
@@ -2034,7 +2034,7 @@ shared_ptr<NativeRdb::ResultSet> MediaLibraryDataManager::QuerySet(MediaLibraryC
     return QueryInternal(cmd, columns, predicates);
 }
 
-shared_ptr<NativeRdb::ResultSet> QueryAnalysisAlbum(MediaLibraryCommand &cmd,
+shared_ptr<NativeRdb::ResultSet> MediaLibraryDataManager::QueryAnalysisAlbum(MediaLibraryCommand &cmd,
     const vector<string> &columns, const DataSharePredicates &predicates)
 {
     if (cmd.GetOprnType() == OperationType::QUERY_HIGHLIGHT_DIRECTORY_SIZE) {
@@ -2059,7 +2059,8 @@ inline bool CheckLatitudeAndLongitude(const string &latitude, const string &long
     return latitude != "" && longitude != "" && !(latitude == "0" && longitude == "0");
 }
 
-shared_ptr<NativeRdb::ResultSet> QueryGeo(const RdbPredicates &rdbPredicates, const vector<string> &columns)
+shared_ptr<NativeRdb::ResultSet> MediaLibraryDataManager::QueryGeo(const RdbPredicates &rdbPredicates,
+    const vector<string> &columns)
 {
     auto queryResult = MediaLibraryRdbStore::QueryWithFilter(rdbPredicates, columns);
     CHECK_AND_RETURN_RET_LOG(queryResult != nullptr, queryResult,
diff --git a/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_photo_operations.cpp b/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_photo_operations.cpp
index f887e523b6..0abd812369 100644
--- a/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_photo_operations.cpp
+++ b/frameworks/innerkitsimpl/medialibrary_data_extension/src/medialibrary_photo_operations.cpp
@@ -334,8 +334,8 @@ static shared_ptr<NativeRdb::ResultSet> HandleAlbumIndexOfUri(MediaLibraryComman
     return MediaLibraryRdbStore::GetIndexOfUri(predicates, columns, photoId);
 }
 
-static shared_ptr<NativeRdb::ResultSet> HandleIndexOfUri(MediaLibraryCommand &cmd, RdbPredicates &predicates,
-    const string &photoId, const string &albumId)
+shared_ptr<NativeRdb::ResultSet> MediaLibraryPhotoOperations::HandleIndexOfUri(
+    MediaLibraryCommand &cmd, RdbPredicates &predicates, const string &photoId, const string &albumId)
 {
     CHECK_AND_RETURN_RET(albumId.empty(), HandleAlbumIndexOfUri(cmd, photoId, albumId));
     string indexClause = " COUNT(*) as " + PHOTO_INDEX;
@@ -349,7 +349,7 @@ static shared_ptr<NativeRdb::ResultSet> HandleIndexOfUri(MediaLibraryCommand &cm
     return MediaLibraryRdbStore::GetIndexOfUriForPhotos(predicates, columns, photoId);
 }
 
-static shared_ptr<NativeRdb::ResultSet> HandleAnalysisIndex(MediaLibraryCommand &cmd,
+shared_ptr<NativeRdb::ResultSet> MediaLibraryPhotoOperations::HandleAnalysisIndex(MediaLibraryCommand &cmd,
     const string &photoId, const string &albumId)
 {
     string orderClause;
@@ -380,7 +380,7 @@ shared_ptr<NativeRdb::ResultSet> MediaLibraryPhotoOperations::Query(
         if (cmd.GetOprnType() == OperationType::ANALYSIS_INDEX) {
             return HandleAnalysisIndex(cmd, photoId, albumId);
         }
-        return HandleIndexOfUri(cmd, predicates, photoId, albumId);
+        return MediaLibraryPhotoOperations::HandleIndexOfUri(cmd, predicates, photoId, albumId);
     }
     CHECK_AND_RETURN_RET(cmd.GetOprnType() != OperationType::FIND_DUPLICATE_ASSETS,
         DuplicatePhotoOperation::GetAllDuplicateAssets(predicates, columns));
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/BUILD.gn b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/BUILD.gn
index 8e03cd733b..fc3c870eb3 100644
--- a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/BUILD.gn
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/BUILD.gn
@@ -76,12 +76,22 @@ ohos_unittest("media_albums_controller_service_test") {
     "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/set_subtitle_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/create_asset_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/delete_photos_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/album_get_assets_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/query_albums_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_albums_by_ids_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_order_position_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_analysis_process_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_highlight_album_info_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_photo_index_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/query_result_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_face_id_vo.cpp",
     "${MEDIALIB_INNERKITS_PATH}/medialibrary_data_extension/src/medialibrary_album_operations.cpp",
     "${MEDIALIB_SERVICES_PATH}/media_analysis_extension/src/media_analysis_proxy.cpp",
     "../medialibrary_unittest_utils/src/medialibrary_unittest_utils.cpp",
     "./src/album_add_assets_test.cpp",
     "./src/album_commit_modify_test.cpp",
     "./src/album_delete_assets_test.cpp",
+    "./src/album_get_assets_test.cpp",
     "./src/album_recover_assets_test.cpp",
     "./src/album_remove_assets_test.cpp",
     "./src/album_set_cover_uri_test.cpp",
@@ -90,6 +100,14 @@ ohos_unittest("media_albums_controller_service_test") {
     "./src/create_album_test.cpp",
     "./src/delete_albums_test.cpp",
     "./src/delete_highlight_albums_test.cpp",
+    "./src/query_albums_test.cpp",
+    "./src/get_albums_by_ids_test.cpp",
+    "./src/get_order_position_test.cpp",
+    "./src/get_data_analysis_process_test.cpp",
+    "./src/get_photo_index_test.cpp",
+    "./src/get_highlight_album_info_test.cpp",
+    "./src/get_face_id_test.cpp",
+    "./src/media_albums_controller_test.cpp",
   ]
   deps = [
     "${MEDIALIB_INNERKITS_PATH}/media_library_helper:media_library",
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/album_get_assets_test.h b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/album_get_assets_test.h
new file mode 100755
index 0000000000..7c098de774
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/album_get_assets_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ALBUM_GET_ASSETS_TEST_H
+#define ALBUM_GET_ASSETS_TEST_H
+
+#include <gtest/gtest.h>
+
+namespace OHOS {
+namespace Media {
+class AlbumGetAssetsTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif  // ALBUM_GET_ASSETS_TEST_H
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_albums_by_ids_test.h b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_albums_by_ids_test.h
new file mode 100644
index 0000000000..d6cf6b8a62
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_albums_by_ids_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef GET_ALBUM_BY_IDS_TEST_H
+#define GET_ALBUM_BY_IDS_TEST_H
+
+#include <gtest/gtest.h>
+
+namespace OHOS {
+namespace Media {
+class GetAlbumsByIdsTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // GET_ALBUM_BY_IDS_TEST_H
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_data_analysis_process_test.h b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_data_analysis_process_test.h
new file mode 100644
index 0000000000..74ddf7c627
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_data_analysis_process_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#ifndef GET_DATA_ANALYSIS_PROCESS_TEST
+#define GET_DATA_ANALYSIS_PROCESS_TEST
+ 
+#include <gtest/gtest.h>
+ 
+namespace OHOS {
+namespace Media {
+class GetDataAnalysisProcessTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // GET_DATA_ANALYSIS_PROCESS_TEST
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_face_id_test.h b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_face_id_test.h
new file mode 100755
index 0000000000..14a1af977d
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_face_id_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef GET_FACE_ID_TEST_H
+#define GET_FACE_ID_TEST_H
+
+#include <gtest/gtest.h>
+
+namespace OHOS {
+namespace Media {
+class GetFaceIdTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // GET_FACE_ID_TEST_H
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_highlight_album_info_test.h b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_highlight_album_info_test.h
new file mode 100644
index 0000000000..4aa871f628
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_highlight_album_info_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#ifndef GET_HIGHLIGHT_ALBUM_INFO_TEST
+#define GET_HIGHLIGHT_ALBUM_INFO_TEST
+ 
+#include <gtest/gtest.h>
+ 
+namespace OHOS {
+namespace Media {
+class GetHightlightAlbumInfoTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // GET_HIGHLIGHT_ALBUM_INFO_TEST
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_order_position_test.h b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_order_position_test.h
new file mode 100755
index 0000000000..0695f75ff7
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_order_position_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef GET_ORDER_POSITION_TEST_H
+#define GET_ORDER_POSITION_TEST_H
+
+#include <gtest/gtest.h>
+
+namespace OHOS {
+namespace Media {
+class GetOrderPositionTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // GET_ORDER_POSITION_TEST_H
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_photo_index_test.h b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_photo_index_test.h
new file mode 100644
index 0000000000..517f329a30
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/get_photo_index_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#ifndef GET_PHOTO_INDEX_TEST
+#define GET_PHOTO_INDEX_TEST
+ 
+#include <gtest/gtest.h>
+ 
+namespace OHOS {
+namespace Media {
+class GetPhotoIndexTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // GET_PHOTO_INDEX_TEST
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/media_albums_controller_test.h b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/media_albums_controller_test.h
new file mode 100755
index 0000000000..ec608cbd59
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/media_albums_controller_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MEDIA_ALBUMS_CONTROLLER_TEST_H
+#define MEDIA_ALBUMS_CONTROLLER_TEST_H
+
+#include <gtest/gtest.h>
+
+namespace OHOS {
+namespace Media {
+class MediaAlbumsControllerTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif  // MEDIA_ALBUMS_CONTROLLER_TEST_H
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/query_albums_test.h b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/query_albums_test.h
new file mode 100644
index 0000000000..ca7ef483e2
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/include/query_albums_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef QUERY_ALBUMS_TEST_H
+#define QUERY_ALBUMS_TEST_H
+
+#include <gtest/gtest.h>
+
+namespace OHOS {
+namespace Media {
+class QueryAlbumsTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // QUERY_ALBUMS_TEST_H
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_add_assets_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_add_assets_test.cpp
index 69b65e74a5..d90d5cd3bd 100755
--- a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_add_assets_test.cpp
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_add_assets_test.cpp
@@ -175,4 +175,17 @@ HWTEST_F(AlbumAddAssetsTest, AddAssets_Test_001, TestSize.Level0)
     MEDIA_INFO_LOG("end AddAssets_Test_001");
 }
 
+HWTEST_F(AlbumAddAssetsTest, AddAssets_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start AddAssets_Test_002");
+    MessageParcel data;
+    MessageParcel reply;
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->AlbumAddAssets(data, reply);
+
+    IPC::MediaRespVo<AlbumPhotoQueryRespBody> resp;
+    ASSERT_EQ(resp.Unmarshalling(reply), true);
+    ASSERT_LT(resp.GetErrCode(), 0);
+    MEDIA_INFO_LOG("end AddAssets_Test_002");
+}
 }  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_commit_modify_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_commit_modify_test.cpp
index 59ac0ba9d7..a2921a0fa3 100755
--- a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_commit_modify_test.cpp
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_commit_modify_test.cpp
@@ -171,4 +171,17 @@ HWTEST_F(AlbumCommitModifyTest, CommitModify_Test_001, TestSize.Level0)
     MEDIA_INFO_LOG("end CommitModify_Test_001");
 }
 
+HWTEST_F(AlbumCommitModifyTest, CommitModify_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start CommitModify_Test_002");
+    MessageParcel data;
+    MessageParcel reply;
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->AlbumCommitModify(data, reply);
+
+    IPC::MediaRespVo<MediaEmptyObjVo> resp;
+    ASSERT_EQ(resp.Unmarshalling(reply), true);
+    ASSERT_LT(resp.GetErrCode(), 0);
+    MEDIA_INFO_LOG("end CommitModify_Test_002");
+}
 }  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_delete_assets_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_delete_assets_test.cpp
index 8edda539fa..39be8cbeb1 100755
--- a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_delete_assets_test.cpp
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_delete_assets_test.cpp
@@ -169,4 +169,17 @@ HWTEST_F(AlbumDeleteAssetsTest, DeleteAssets_Test_001, TestSize.Level0)
     MEDIA_INFO_LOG("end DeleteAssets_Test_001");
 }
 
+HWTEST_F(AlbumDeleteAssetsTest, DeleteAssets_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start DeleteAssets_Test_002");
+    MessageParcel data;
+    MessageParcel reply;
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->DeletePhotos(data, reply);
+
+    IPC::MediaRespVo<MediaEmptyObjVo> resp;
+    ASSERT_EQ(resp.Unmarshalling(reply), true);
+    ASSERT_LT(resp.GetErrCode(), 0);
+    MEDIA_INFO_LOG("end DeleteAssets_Test_002");
+}
 }  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_get_assets_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_get_assets_test.cpp
new file mode 100755
index 0000000000..802563994c
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_get_assets_test.cpp
@@ -0,0 +1,241 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaAlbumsControllerServiceTest"
+
+#include "album_get_assets_test.h"
+
+#include <string>
+#include <vector>
+
+#define private public
+#define protected public
+#include "media_albums_controller_service.h"
+#undef private
+#undef protected
+
+#include "album_get_assets_vo.h"
+#include "album_get_assets_dto.h"
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "result_set_utils.h"
+#include "media_file_uri.h"
+
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+using namespace IPC;
+
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 1;
+
+static int32_t ClearTable(const string &table)
+{
+    RdbPredicates predicates(table);
+
+    int32_t rows = 0;
+    int32_t err = g_rdbStore->Delete(rows, predicates);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to clear album table, err: %{public}d", err);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+
+void AlbumGetAssetsTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start MediaLibraryPhotoOperationsTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+    ClearTable(PhotoAlbumColumns::TABLE);
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+
+void AlbumGetAssetsTest::TearDownTestCase(void)
+{
+    ClearTable(PhotoAlbumColumns::TABLE);
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+
+void AlbumGetAssetsTest::SetUp()
+{
+    MEDIA_INFO_LOG("SetUp");
+}
+
+void AlbumGetAssetsTest::TearDown(void)
+{
+    MEDIA_INFO_LOG("TearDown");
+}
+
+static const string SQL_CREATE_ALBUM = "INSERT INTO " + PhotoAlbumColumns::TABLE + "(" + PhotoAlbumColumns::ALBUM_TYPE +
+                                       ", " + PhotoAlbumColumns::ALBUM_SUBTYPE + ", " + PhotoAlbumColumns::ALBUM_NAME +
+                                       ", " + PhotoAlbumColumns::ALBUM_DATE_MODIFIED + ", " +
+                                       PhotoAlbumColumns::ALBUM_IS_LOCAL + ", " + PhotoAlbumColumns::ALBUM_DATE_ADDED +
+                                       ", " + PhotoAlbumColumns::ALBUM_LPATH + ", " +
+                                       PhotoAlbumColumns::ALBUM_PRIORITY + ")";
+
+static void CreateUserAlbum(const std::string &albumName)
+{
+    // album_type, album_subtype, album_name, date_modified, is_local, date_added, lpath, priority
+    g_rdbStore->ExecuteSql(SQL_CREATE_ALBUM + "VALUES (0, 1, '" + albumName +
+                           "', 1748354341383, 1 , 1748354341383, '/Pictures/Users/" + albumName + "', 1)");
+}
+
+static const string SQL_INSERT_PHOTO =
+    "INSERT INTO " + PhotoColumn::PHOTOS_TABLE + "(" + MediaColumn::MEDIA_FILE_PATH + ", " + MediaColumn::MEDIA_SIZE +
+    ", " + MediaColumn::MEDIA_TITLE + ", " + MediaColumn::MEDIA_NAME + ", " + MediaColumn::MEDIA_TYPE + ", " +
+    MediaColumn::MEDIA_OWNER_PACKAGE + ", " + MediaColumn::MEDIA_PACKAGE_NAME + ", " + MediaColumn::MEDIA_DATE_ADDED +
+    ", " + MediaColumn::MEDIA_DATE_MODIFIED + ", " + MediaColumn::MEDIA_DATE_TAKEN + ", " +
+    MediaColumn::MEDIA_DURATION + ", " + MediaColumn::MEDIA_IS_FAV + ", " + MediaColumn::MEDIA_DATE_TRASHED + ", " +
+    MediaColumn::MEDIA_HIDDEN + ", " + PhotoColumn::PHOTO_HEIGHT + ", " + PhotoColumn::PHOTO_WIDTH + ", " +
+    PhotoColumn::PHOTO_EDIT_TIME + ", " + PhotoColumn::PHOTO_POSITION + ", " + PhotoColumn::PHOTO_SHOOTING_MODE + ", " +
+    PhotoColumn::PHOTO_OWNER_ALBUM_ID + ")";
+
+static void InsertAssetIntoPhotosTable(const string &data, const string &title, int32_t albumId)
+{
+    // data, size, title, display_name, media_type,position
+    // owner_package, package_name, date_added, date_modified, date_taken, duration, is_favorite, date_trashed, hidden
+    // height, width, edit_time, position, shooting_mode, owner_album_id
+    g_rdbStore->ExecuteSql(
+        SQL_INSERT_PHOTO + "VALUES ('" + data + "', 175258, '" + title + "', '" + title +
+        ".jpg', 1, 'com.ohos.camera', '相机', 1748423617814, 1748424146785, 1748424146785, 0, 0, 0, 0, " +
+        "1280, 960, 0, 1, '1', " + to_string(albumId) + ")");  // cam, pic, shootingmode = 1
+}
+
+static shared_ptr<NativeRdb::ResultSet> QueryAsset(
+    const string &table, const string &key, const string &value, const vector<string> &columns)
+{
+    RdbPredicates rdbPredicates(table);
+    rdbPredicates.EqualTo(key, value);
+    auto resultSet = MediaLibraryRdbStore::Query(rdbPredicates, columns);
+    if (resultSet == nullptr || resultSet->GoToFirstRow() != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("Can not get file asset");
+        return nullptr;
+    }
+    return resultSet;
+}
+
+static void AlbumGetAssetsPrepare(int32_t &albumId, string &uri)
+{
+    // 1、创建用户相册
+    string albumName = "test01";
+    CreateUserAlbum(albumName);
+    vector<string> columns;
+    auto resultSet = QueryAsset(PhotoAlbumColumns::TABLE, PhotoAlbumColumns::ALBUM_NAME, albumName, columns);
+    if (resultSet == nullptr) {
+        return;
+    }
+
+    albumId = GetInt32Val(PhotoAlbumColumns::ALBUM_ID, resultSet);
+    if (albumId <= 0) {
+        return;
+    }
+
+    // 2、插入一条数据照片到相册
+    string title = "cam_pic";
+    string data = "/storage/cloud/files/Photo/9/IMG_1748505946_009.jpg";
+    InsertAssetIntoPhotosTable(data, title, albumId);
+    resultSet = QueryAsset(PhotoColumn::PHOTOS_TABLE, MediaColumn::MEDIA_NAME, title + ".jpg", columns);
+    if (resultSet == nullptr) {
+        return;
+    }
+
+    string displayName = GetStringVal(MediaColumn::MEDIA_NAME, resultSet);
+    if (displayName.size() <= 0) {
+        return;
+    }
+
+    int32_t fileId = GetInt32Val(PhotoColumn::MEDIA_ID, resultSet);
+    string path = GetStringVal(PhotoColumn::MEDIA_FILE_PATH, resultSet);
+    uri = MediaFileUri::GetPhotoUri(to_string(fileId), path, displayName);
+}
+
+static int32_t AlbumGetAssets(string albumId, int32_t byPassCode = E_SUCCESS)
+{
+    AlbumGetAssetsReqBody reqBody;
+    reqBody.predicates.EqualTo(PhotoColumn::PHOTO_OWNER_ALBUM_ID, albumId);
+
+    MessageParcel data;
+    if (reqBody.Marshalling(data) != true) {
+        MEDIA_ERR_LOG("reqBody.Marshalling failed");
+        return -1;
+    }
+
+    auto service = make_shared<MediaAlbumsControllerService>();
+    MessageParcel reply;
+    MessageOption option;
+    IPCContext context(option, byPassCode);
+    service->AlbumGetAssets(data, reply, context);
+
+    IPC::MediaRespVo<AlbumGetAssetsRespBody> resp;
+    if (resp.Unmarshalling(reply) != true) {
+        MEDIA_ERR_LOG("resp.Unmarshalling failed");
+        return -1;
+    }
+    auto err = resp.GetErrCode();
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("resp.GetErrCode is not E_OK");
+        return -1;
+    }
+    AlbumGetAssetsRespBody respBody = resp.GetBody();
+    if (respBody.resultSet == nullptr) {
+        MEDIA_ERR_LOG("respBody.resultSet is nullptr");
+        return -1;
+    }
+    int count = -1;
+
+    auto errCode = respBody.resultSet->GetRowCount(count);
+    if (errCode != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("ResultSet GetRowCount failed, errCode=%{public}d", errCode);
+        return -1;
+    }
+    return count;
+}
+
+HWTEST_F(AlbumGetAssetsTest, GetAssets_Test_001, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start GetAssets_Test_001");
+    // 1、前置条件准备
+    int32_t albumId = -1;
+    string uri = "";
+    AlbumGetAssetsPrepare(albumId, uri);
+    EXPECT_GT(albumId, 0);
+    EXPECT_FALSE(uri.empty());
+
+    // 2、获取相册资产
+    int32_t count = AlbumGetAssets(to_string(albumId));
+    EXPECT_GT(count, 0);
+
+    count = AlbumGetAssets("invalid_album_id");
+    EXPECT_EQ(count, 0);
+
+    count = AlbumGetAssets(to_string(albumId), E_PERMISSION_DB_BYPASS);
+    EXPECT_LT(count, 0);
+
+    count = AlbumGetAssets("invalid_album_id", E_PERMISSION_DB_BYPASS);
+    EXPECT_LT(count, 0);
+
+    MEDIA_INFO_LOG("end GetAssets_Test_001");
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_recover_assets_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_recover_assets_test.cpp
index f3ca219c83..7250f57b5e 100755
--- a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_recover_assets_test.cpp
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_recover_assets_test.cpp
@@ -179,4 +179,17 @@ HWTEST_F(AlbumRecoverAssetsTest, RecoverAssets_Test_001, TestSize.Level0)
     MEDIA_INFO_LOG("end RecoverAssets_Test_001");
 }
 
+HWTEST_F(AlbumRecoverAssetsTest, RecoverAssets_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start RecoverAssets_Test_002");
+    MessageParcel data;
+    MessageParcel reply;
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->AlbumRecoverAssets(data, reply);
+
+    IPC::MediaRespVo<MediaEmptyObjVo> resp;
+    ASSERT_EQ(resp.Unmarshalling(reply), true);
+    ASSERT_LT(resp.GetErrCode(), 0);
+    MEDIA_INFO_LOG("end RecoverAssets_Test_002");
+}
 }  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_remove_assets_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_remove_assets_test.cpp
index 8e21b2e812..42b4f4ca19 100755
--- a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_remove_assets_test.cpp
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_remove_assets_test.cpp
@@ -225,4 +225,18 @@ HWTEST_F(AlbumRemoveAssetsTest, RemoveAssets_Test_001, TestSize.Level0)
     EXPECT_GT(changedRows, 0);
     MEDIA_INFO_LOG("end RemoveAssets_Test_001");
 }
+
+HWTEST_F(AlbumRemoveAssetsTest, RemoveAssets_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start RemoveAssets_Test_002");
+    MessageParcel data;
+    MessageParcel reply;
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->AlbumRemoveAssets(data, reply);
+
+    IPC::MediaRespVo<MediaEmptyObjVo> resp;
+    ASSERT_EQ(resp.Unmarshalling(reply), true);
+    ASSERT_LT(resp.GetErrCode(), 0);
+    MEDIA_INFO_LOG("end RemoveAssets_Test_002");
+}
 }  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_set_cover_uri_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_set_cover_uri_test.cpp
index 6f2e7272a4..efce789a1f 100755
--- a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_set_cover_uri_test.cpp
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/album_set_cover_uri_test.cpp
@@ -165,4 +165,17 @@ HWTEST_F(AlbumSetCoverUriTest, SetCoverUri_Test_001, TestSize.Level0)
     MEDIA_INFO_LOG("end SetCoverUri_Test_001");
 }
 
+HWTEST_F(AlbumSetCoverUriTest, SetCoverUri_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start SetCoverUri_Test_002");
+    MessageParcel data;
+    MessageParcel reply;
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->AlbumCommitModify(data, reply);
+
+    IPC::MediaRespVo<MediaEmptyObjVo> resp;
+    ASSERT_EQ(resp.Unmarshalling(reply), true);
+    ASSERT_LT(resp.GetErrCode(), 0);
+    MEDIA_INFO_LOG("end SetCoverUri_Test_002");
+}
 }  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/change_assets_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/change_assets_test.cpp
index d942884de7..ab519dfb22 100644
--- a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/change_assets_test.cpp
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/change_assets_test.cpp
@@ -163,6 +163,22 @@ HWTEST_F(ChangeAssetsTest, AddAssets_Test_001, TestSize.Level0)
     EXPECT_EQ(result, 0);
 }
 
+/**
+ * @tc.name  : AddAssets_ShouldReturnError_WhenReadRequestBodyFails
+ * @tc.number: AddAssets_Test_002
+ * @tc.desc  : 测试当读取请求体失败时,AddAssets 函数应返回错误
+ */
+HWTEST_F(ChangeAssetsTest, AddAssets_Test_002, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->AddAssets(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_EQ(respVo.GetErrCode(), 0);
+}
+
 /**
  * @tc.name  : RemoveAssets_ShouldHandleHiddenOnlyFlag_WhenIsHiddenOnlyIsTrue
  * @tc.number: RemoveAssetsTest_001
@@ -176,6 +192,22 @@ HWTEST_F(ChangeAssetsTest, RemoveAssetsTest_001, TestSize.Level0)
     ASSERT_LT(result, 0);
 }
 
+/**
+ * @tc.name  : RemoveAssets_ShouldReturnError_WhenReadRequestBodyFails
+ * @tc.number: RemoveAssets_Test_002
+ * @tc.desc  : 测试当读取请求体失败时,RemoveAssets 函数应返回错误
+ */
+HWTEST_F(ChangeAssetsTest, RemoveAssets_Test_002, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->RemoveAssets(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_EQ(respVo.GetErrCode(), 0);
+}
+
 /**
  * @tc.name  : MoveAssets_ShouldReturnError_WhenReadRequestBodyFails
  * @tc.number: MoveAssetsTest_001
@@ -200,6 +232,22 @@ HWTEST_F(ChangeAssetsTest, MoveAssetsTest_001, TestSize.Level0) {
     EXPECT_EQ(true, ret);
 }
 
+/**
+ * @tc.name  : MoveAssets_ShouldReturnError_WhenReadRequestBodyFails
+ * @tc.number: MoveAssets_Test_002
+ * @tc.desc  : 测试当读取请求体失败时,MoveAssets 函数应返回错误
+ */
+HWTEST_F(ChangeAssetsTest, MoveAssets_Test_002, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->MoveAssets(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_LT(respVo.GetErrCode(), 0);
+}
+
 /**
  * @tc.name  : RecoverAssets_ShouldReturnError_WhenReadRequestBodyFails
  * @tc.number: RecoverAssetsTest_001
@@ -222,6 +270,22 @@ HWTEST_F(ChangeAssetsTest, RecoverAssetsTest_001, TestSize.Level0) {
     EXPECT_EQ(true, ret);
 }
 
+/**
+ * @tc.name  : RecoverAssetsTest_ShouldReturnError_WhenReadRequestBodyFails
+ * @tc.number: RecoverAssetsTest_Test_002
+ * @tc.desc  : 测试当读取请求体失败时,RecoverAssets 函数应返回错误
+ */
+HWTEST_F(ChangeAssetsTest, RecoverAssets_Test_002, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->RecoverAssets(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_EQ(respVo.GetErrCode(), 0);
+}
+
 /**
  * @tc.name  : DeleteAssets_ShouldReturnError_WhenReadRequestBodyFails
  * @tc.number: DeleteAssetsTest_001
@@ -243,6 +307,23 @@ HWTEST_F(ChangeAssetsTest, DeleteAssetsTest_001, TestSize.Level0) {
     ret = respVo.Unmarshalling(reply);
     EXPECT_EQ(true, ret);
 }
+
+/**
+ * @tc.name  : DeleteAssetsTest_ShouldReturnError_WhenReadRequestBodyFails
+ * @tc.number: DeleteAssetsTest_Test_002
+ * @tc.desc  : 测试当读取请求体失败时,DeleteAssets 函数应返回错误
+ */
+HWTEST_F(ChangeAssetsTest, DeleteAssetsTest_002, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->DeleteAssets(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_EQ(respVo.GetErrCode(), 0);
+}
+
 /**
  * @tc.name  : DismissAsset_ShouldReturnError_WhenRecoverPhotoAssetsFails
  * @tc.number: DismissAssetsTest_001
@@ -269,6 +350,22 @@ HWTEST_F(ChangeAssetsTest, DismissAssetsTest_001, TestSize.Level0) {
     EXPECT_EQ(true, ret);
 }
 
+/**
+ * @tc.name  : DismissAssetsTest_ShouldReturnError_WhenReadRequestBodyFails
+ * @tc.number: DismissAssetsTest_002
+ * @tc.desc  : 测试当读取请求体失败时,DismissAssets 函数应返回错误
+ */
+HWTEST_F(ChangeAssetsTest, DismissAssetsTest_002, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->DismissAssets(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_LT(respVo.GetErrCode(), 0);
+}
+
 HWTEST_F(ChangeAssetsTest, MergeAlbumTest_001, TestSize.Level0) {
     MessageParcel data;
     MessageParcel reply;
@@ -290,6 +387,22 @@ HWTEST_F(ChangeAssetsTest, MergeAlbumTest_001, TestSize.Level0) {
     EXPECT_EQ(true, ret);
 }
 
+/**
+ * @tc.name  : MergeAlbumTest_ShouldReturnError_WhenReadRequestBodyFails
+ * @tc.number: MergeAlbumTest_002
+ * @tc.desc  : 测试当读取请求体失败时,DismissAssets 函数应返回错误
+ */
+HWTEST_F(ChangeAssetsTest, MergeAlbumTest_002, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->MergeAlbum(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_LT(respVo.GetErrCode(), 0);
+}
+
 HWTEST_F(ChangeAssetsTest, PlaceBeforeTest_001, TestSize.Level0) {
     MessageParcel data;
     MessageParcel reply;
@@ -312,6 +425,22 @@ HWTEST_F(ChangeAssetsTest, PlaceBeforeTest_001, TestSize.Level0) {
     EXPECT_EQ(true, ret);
 }
 
+/**
+ * @tc.name  : PlaceBeforeTest_ShouldReturnError_WhenReadRequestBodyFails
+ * @tc.number: PlaceBeforeTest_002
+ * @tc.desc  : 测试当读取请求体失败时,PlaceBefore 函数应返回错误
+ */
+HWTEST_F(ChangeAssetsTest, PlaceBeforeTest_002, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->PlaceBefore(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_LT(respVo.GetErrCode(), 0);
+}
+
 HWTEST_F(ChangeAssetsTest, SetOrderPositionTest_001, TestSize.Level0) {
     MessageParcel data;
     MessageParcel reply;
@@ -333,4 +462,20 @@ HWTEST_F(ChangeAssetsTest, SetOrderPositionTest_001, TestSize.Level0) {
     ret = respVo.Unmarshalling(reply);
     EXPECT_EQ(true, ret);
 }
+
+/**
+ * @tc.name  : SetOrderPositionTest_ShouldReturnError_WhenReadRequestBodyFails
+ * @tc.number: SetOrderPositionTest_002
+ * @tc.desc  : 测试当读取请求体失败时,PlaceBefore 函数应返回错误
+ */
+HWTEST_F(ChangeAssetsTest, SetOrderPositionTest_002, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->SetOrderPosition(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_LT(respVo.GetErrCode(), 0);
+}
 }  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/create_album_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/create_album_test.cpp
index 7e7230c9f5..3802cf6938 100644
--- a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/create_album_test.cpp
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/create_album_test.cpp
@@ -20,11 +20,7 @@
 #include <memory>
 #include <string>
 
-#define private public
-#define protected public
 #include "media_albums_controller_service.h"
-#undef private
-#undef protected
 
 #include "create_album_vo.h"
 #include "user_define_ipc_client.h"
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_albums_by_ids_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_albums_by_ids_test.cpp
new file mode 100644
index 0000000000..915eaf221c
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_albums_by_ids_test.cpp
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaAlbumsControllerServiceTest"
+
+#include "get_albums_by_ids_test.h"
+
+#include <memory>
+#include <string>
+
+#define private public
+#define protected public
+#include "media_albums_controller_service.h"
+#undef private
+#undef protected
+
+#include "get_albums_by_ids_vo.h"
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 1;
+
+static int32_t ClearUserAlbums()
+{
+    RdbPredicates predicates(PhotoAlbumColumns::TABLE);
+    predicates.EqualTo(PhotoAlbumColumns::ALBUM_TYPE, to_string(PhotoAlbumType::USER));
+
+    int32_t rows = 0;
+    int32_t err = g_rdbStore->Delete(rows, predicates);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to clear album table, err: %{public}d", err);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+
+void GetAlbumsByIdsTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start MediaLibraryPhotoOperationsTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+    ClearUserAlbums();
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+
+void GetAlbumsByIdsTest::TearDownTestCase(void)
+{
+    ClearUserAlbums();
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+
+void GetAlbumsByIdsTest::SetUp()
+{
+    MEDIA_INFO_LOG("SetUp");
+}
+
+void GetAlbumsByIdsTest::TearDown(void)
+{
+    MEDIA_INFO_LOG("TearDown");
+}
+
+/**
+ * @tc.name  : GetAlbumsByIds_ShouldReturnError_WhenReadRequestBodyFails
+ * @tc.number: GetAlbumsByIdsTest_001
+ * @tc.desc  : 测试当读取请求体失败时,GetAlbumsByIds 函数应返回错误
+ */
+HWTEST_F(GetAlbumsByIdsTest, GetAlbumsByIdsTest_001, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->GetAlbumsByIds(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_LT(respVo.GetErrCode(), 0);
+}
+
+/**
+ * @tc.name  : GetAlbumsByIds_ShouldReturnSuccess_WhenQueryWithFilterSucceeds
+ * @tc.number: GetAlbumsByIdsTest_002
+ * @tc.desc  : 测试当数据库查询成功时,GetAlbumsByIds 函数应返回成功
+ */
+HWTEST_F(GetAlbumsByIdsTest, GetAlbumsByIdsTest_002, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+    GetAlbumsByIdsReqBody reqBody;
+    reqBody.columns = { "album_id", "album_name", "album_path", "date_modified", "is_visible", "timestamp" };
+
+    auto ret = reqBody.Marshalling(data);
+    EXPECT_EQ(ret, true);
+
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->GetAlbumsByIds(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ret = respVo.Unmarshalling(reply);
+
+    EXPECT_EQ(ret, true);
+    EXPECT_EQ(respVo.GetErrCode(), 0);
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_data_analysis_process_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_data_analysis_process_test.cpp
new file mode 100644
index 0000000000..5775167241
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_data_analysis_process_test.cpp
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#define MLOG_TAG "MediaAlbumsControllerServiceTest"
+ 
+#include "get_data_analysis_process_test.h"
+ 
+#include <string>
+#include <vector>
+ 
+#define private public
+#define protected public
+#include "datashare_result_set.h"
+#include "media_albums_controller_service.h"
+#include "rdb_utils.h"
+#undef private
+#undef protected
+ 
+#include "media_column.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "result_set_utils.h"
+#include "story_album_column.h"
+#include "user_define_ipc_client.h"
+#include "user_photography_info_column.h"
+#include "vision_column.h"
+#include "get_analysis_process_vo.h"
+#include "query_result_vo.h"
+ 
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+ 
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore = nullptr;
+static constexpr int32_t SLEEP_SECONDS = 1;
+
+static int32_t DeleteDatabaseData()
+{
+    if (g_rdbStore == nullptr) {
+        std::cout << "g_rdbStore == nullptr" << std::endl;
+        return E_ERR;
+    }
+    std::cout << "DeleteDatabaseData" << std::endl;
+    // delete photo
+    std::string deletePhotoData = "DELETE FROM " + PhotoColumn::PHOTOS_TABLE;
+    int32_t ret = g_rdbStore->ExecuteSql(deletePhotoData);
+    if (ret != NativeRdb::E_OK) {
+        std::cout << "Delete Photos Data Failed:" << deletePhotoData;
+        return E_ERR;
+    }
+    std::cout << "Delete Photos Data success." << std::endl;
+
+    // tab_analysis_total
+    std::string deleteAnalysisTotalSql = "DELETE FROM tab_analysis_total;";
+    ret = g_rdbStore->ExecuteSql(deleteAnalysisTotalSql);
+    if (ret != NativeRdb::E_OK) {
+        std::cout << "Delete tab_analysis_total Data Failed:" << deleteAnalysisTotalSql;
+        return E_ERR;
+    }
+    std::cout << "Delete tab_analysis_total Data success." << std::endl;
+
+    // tab_user_photography_info
+    std::string deleteUserPhotographyInfo = "DELETE FROM tab_user_photography_info;";
+    ret = g_rdbStore->ExecuteSql(deleteUserPhotographyInfo);
+    if (ret != NativeRdb::E_OK) {
+        std::cout << "Delete tab_user_photography_info Data Failed:" << deleteAnalysisTotalSql;
+        return E_ERR;
+    }
+    std::cout << "Delete tab_user_photography_info Data success." << std::endl;
+
+    // tab_highlight_album
+    std::string deleteHightlightAlbum = "DELETE FROM tab_highlight_album;";
+    ret = g_rdbStore->ExecuteSql(deleteHightlightAlbum);
+    if (ret != NativeRdb::E_OK) {
+        std::cout << "Delete tab_highlight_album Data Failed:" << deleteAnalysisTotalSql;
+        return E_ERR;
+    }
+    std::cout << "Delete tab_highlight_album Data success." << std::endl;
+
+    return E_OK;
+}
+ 
+void GetDataAnalysisProcessTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    DeleteDatabaseData();
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+ 
+void GetDataAnalysisProcessTest::TearDownTestCase(void)
+{
+    DeleteDatabaseData();
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+ 
+void GetDataAnalysisProcessTest::SetUp()
+{
+    MEDIA_INFO_LOG("SetUp");
+    DeleteDatabaseData();
+}
+ 
+void GetDataAnalysisProcessTest::TearDown(void)
+{
+    MEDIA_INFO_LOG("TearDown");
+    DeleteDatabaseData();
+}
+ 
+static void InsertAssetIntoPhotosTable(const std::string &filePath)
+{
+    const std::string sqlInsertPhoto = "INSERT INTO " + PhotoColumn::PHOTOS_TABLE + "("  +
+        MediaColumn::MEDIA_FILE_PATH + ", " + MediaColumn::MEDIA_SIZE + ", " + MediaColumn::MEDIA_TITLE + ", " +
+        MediaColumn::MEDIA_NAME + ", " + MediaColumn::MEDIA_TYPE + ", " + MediaColumn::MEDIA_OWNER_PACKAGE + ", " +
+        MediaColumn::MEDIA_PACKAGE_NAME + ", " + MediaColumn::MEDIA_DATE_ADDED + ", "  +
+        MediaColumn::MEDIA_DATE_MODIFIED + ", " + MediaColumn::MEDIA_DATE_TAKEN + ", " +
+        MediaColumn::MEDIA_DURATION + ", " + MediaColumn::MEDIA_IS_FAV + ", " + MediaColumn::MEDIA_DATE_TRASHED + ", " +
+        MediaColumn::MEDIA_HIDDEN + ", " + PhotoColumn::PHOTO_HEIGHT + ", " + PhotoColumn::PHOTO_WIDTH + ", " +
+        PhotoColumn::PHOTO_EDIT_TIME + ", " + PhotoColumn::PHOTO_SHOOTING_MODE + ")";
+    g_rdbStore->ExecuteSql(sqlInsertPhoto + "VALUES (" +
+        "'" + filePath + "', 175258, 'cam_pic', 'cam_pic.jpg', 1, " +
+        "'com.ohos.camera', '相机', 1501924205218, 0, 1501924205, 0, 0, 0, 0, " +
+        "1280, 960, 0, '1' )");
+}
+
+static void InsertTabAnalysisTotal()
+{
+    int ret = g_rdbStore->ExecuteSql(
+        "INSERT INTO tab_analysis_total "
+        "(file_id, ocr, label, aesthetics_score, face, segmentation, saliency, head) "
+        "VALUES (100001, 1, 1, 1, 1, 1, 1, 1)");
+    std::cout << "InsertTabAnalysisTotal, ret = " << ret << std::endl;
+}
+
+static void InsertTabUserPhotographyInfo()
+{
+    int ret = g_rdbStore->ExecuteSql(
+        "insert into tab_user_photography_info(highlight_analysis_progress) values"
+        "(\"{'cvFinishedCount':11097,'geoFinishedCount':13164,'searchFinishedCount':6610,'totalCount':11631}\");");
+    std::cout << "InsertTabUserPhotographyInfo, ret = " << ret << std::endl;
+}
+
+// HIGHLIGHT_ALBUM_TABLE tab_highlight_album
+static void InsertHighLightAlbumTable()
+{
+    int ret = g_rdbStore->ExecuteSql(
+        "insert into tab_highlight_album"
+        "(highlight_status, cluster_type, cluster_sub_type, cluster_condition, highlight_version) "
+        "values(1, 'TYPE_DBSCAN', 'DBScan_Default', '[{\"end\":\"1538816165000\",\"start\":\"1538814215000\"}]', 3);");
+    std::cout << "InsertHighLightAlbumTable, ret = " << ret << std::endl;
+}
+
+HWTEST_F(GetDataAnalysisProcessTest, GetLabelAnalysisProgress_Test_001, TestSize.Level0)
+{
+    bool createDirRes = MediaFileUtils::CreateDirectory("/data/local/tmp");
+    std::string filePath = "/data/local/tmp/IMG_1501924305_001.jpg";
+    if (!MediaFileUtils::IsFileExists(filePath)) {
+        EXPECT_EQ(MediaFileUtils::CreateFile(filePath), true);
+    }
+    InsertAssetIntoPhotosTable(filePath);
+
+    RdbPredicates rdbPredicates(PhotoColumn::PHOTOS_TABLE);
+    rdbPredicates.EqualTo(MediaColumn::MEDIA_FILE_PATH, filePath);
+    std::vector<std::string> columns = { MediaColumn::MEDIA_ID };
+ 
+    shared_ptr<NativeRdb::ResultSet> resSet = MediaLibraryRdbStore::Query(rdbPredicates, columns);
+    EXPECT_NE(resSet, nullptr);
+    EXPECT_EQ(resSet->GoToNextRow(), NativeRdb::E_OK);
+    EXPECT_GT(GetInt32Val(MediaColumn::MEDIA_ID, resSet), 0);
+
+    string clause = VISION_TOTAL_TABLE + "." + MediaColumn::MEDIA_ID + " = " + PhotoColumn::PHOTOS_TABLE+ "." +
+        MediaColumn::MEDIA_ID;
+    GetAnalysisProcessReqBody reqBody;
+    reqBody.analysisType = AnalysisType::ANALYSIS_LABEL;
+    MessageParcel data;
+    MessageParcel reply;
+    reqBody.Marshalling(data);
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->GetAnalysisProcess(data, reply);
+    IPC::MediaRespVo<QueryResultRspBody> resp;
+    bool isValid = resp.Unmarshalling(reply);
+    ASSERT_EQ(isValid, true);
+    EXPECT_EQ(resp.GetErrCode(), E_SUCCESS);
+    auto resultSet = resp.GetBody().resultSet;
+    int rowsCount = 0;
+    while (resultSet->GoToNextRow() == NativeRdb::E_OK) {
+        ++rowsCount;
+    }
+    EXPECT_EQ(rowsCount, 1);
+}
+
+HWTEST_F(GetDataAnalysisProcessTest, GetFaceAnalysisProgress_TEST_001, TestSize.Level0)
+{
+    InsertTabUserPhotographyInfo();
+    RdbPredicates predicates(USER_PHOTOGRAPHY_INFO_TABLE);
+    std::vector<std::string> columns = { HIGHLIGHT_ANALYSIS_PROGRESS };
+    auto resSet = MediaLibraryRdbStore::Query(predicates, columns);
+    EXPECT_NE(resSet, nullptr);
+    int rowsCount = 0;
+    while (resSet->GoToNextRow() == NativeRdb::E_OK) {
+        for (int i = 0; i < columns.size(); ++i) {
+            std::string val = "";
+            resSet->GetString(i, val);
+            std::cout << columns[i] << "=" << val << std::endl;
+        }
+        ++rowsCount;
+    }
+    EXPECT_EQ(rowsCount, 1);
+}
+
+HWTEST_F(GetDataAnalysisProcessTest, GetFaceAnalysisProgress_TEST_002, TestSize.Level0)
+{
+    InsertTabUserPhotographyInfo();
+    std::vector<std::string> columns = { HIGHLIGHT_ANALYSIS_PROGRESS };
+    GetAnalysisProcessReqBody reqBody;
+    DataShare::DataSharePredicates dataSharePredicates;
+    reqBody.analysisType = AnalysisType::ANALYSIS_FACE;
+    MessageParcel data;
+    MessageParcel reply;
+    reqBody.Marshalling(data);
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->GetAnalysisProcess(data, reply);
+    IPC::MediaRespVo<QueryResultRspBody> resp;
+    bool isValid = resp.Unmarshalling(reply);
+    ASSERT_EQ(isValid, true);
+    EXPECT_EQ(resp.GetErrCode(), E_SUCCESS);
+    auto resultSet = resp.GetBody().resultSet;
+    int rowsCount = 0;
+    while (resultSet->GoToNextRow() == NativeRdb::E_OK) {
+        for (int i = 0; i < columns.size(); ++i) {
+            std::string val = "";
+            resultSet->GetString(i, val);
+            std::cout << columns[i] << "=" << val << std::endl;
+        }
+        ++rowsCount;
+    }
+    EXPECT_EQ(rowsCount, 1);
+}
+
+HWTEST_F(GetDataAnalysisProcessTest, GetHighlightAnalysisProgressTest_TEST_001, TestSize.Level0)
+{
+    InsertHighLightAlbumTable();
+    RdbPredicates predicates(HIGHLIGHT_ALBUM_TABLE);
+    std::vector<std::string> columns = {
+        "SUM(CASE WHEN highlight_status = -3 THEN 1 ELSE 0 END) AS ClearCount",
+        "SUM(CASE WHEN highlight_status = -2 THEN 1 ELSE 0 END) AS DeleteCount",
+        "SUM(CASE WHEN highlight_status = -1 THEN 1 ELSE 0 END) AS NotProduceCount",
+        "SUM(CASE WHEN highlight_status > 0 THEN 1 ELSE 0 END) AS ProduceCount",
+        "SUM(CASE WHEN highlight_status = 1 THEN 1 ELSE 0 END) AS PushCount",
+    };
+    auto resSet = MediaLibraryRdbStore::Query(predicates, columns);
+    EXPECT_NE(resSet, nullptr);
+    int rowsCount = 0;
+    while (resSet->GoToNextRow() == NativeRdb::E_OK) {
+        for (int i = 0; i < columns.size(); ++i) {
+            std::string val = "";
+            resSet->GetString(i, val);
+            std::cout << columns[i] << "=" << val << std::endl;
+        }
+        ++rowsCount;
+    }
+    EXPECT_EQ(rowsCount, 1);
+}
+
+HWTEST_F(GetDataAnalysisProcessTest, GetHighlightAnalysisProgressTest_TEST_002, TestSize.Level0)
+{
+    InsertHighLightAlbumTable();
+    DataShare::DataSharePredicates dataSharePredicates;
+    GetAnalysisProcessReqBody reqBody;
+    std::vector<std::string> columns = {
+        "SUM(CASE WHEN highlight_status = -3 THEN 1 ELSE 0 END) AS ClearCount",
+        "SUM(CASE WHEN highlight_status = -2 THEN 1 ELSE 0 END) AS DeleteCount",
+        "SUM(CASE WHEN highlight_status = -1 THEN 1 ELSE 0 END) AS NotProduceCount",
+        "SUM(CASE WHEN highlight_status > 0 THEN 1 ELSE 0 END) AS ProduceCount",
+        "SUM(CASE WHEN highlight_status = 1 THEN 1 ELSE 0 END) AS PushCount",
+    };
+    reqBody.analysisType = AnalysisType::ANALYSIS_HIGHLIGHT;
+    MessageParcel data;
+    MessageParcel reply;
+    reqBody.Marshalling(data);
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->GetAnalysisProcess(data, reply);
+    IPC::MediaRespVo<QueryResultRspBody> resp;
+    bool isValid = resp.Unmarshalling(reply);
+    ASSERT_EQ(isValid, true);
+    EXPECT_EQ(resp.GetErrCode(), E_SUCCESS);
+    auto resultSet = resp.GetBody().resultSet;
+    int rowsCount = 0;
+    while (resultSet->GoToNextRow() == NativeRdb::E_OK) {
+        for (int i = 0; i < columns.size(); ++i) {
+            int val = 0;
+            resultSet->GetInt(i, val);
+            std::cout << columns[i] << "=" << val << std::endl;
+            if (i == columns.size() - 1) {
+                EXPECT_EQ(val, 1);
+            }
+        }
+        ++rowsCount;
+    }
+    EXPECT_EQ(rowsCount, 1);
+}
+
+
+ 
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_face_id_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_face_id_test.cpp
new file mode 100755
index 0000000000..9f46125122
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_face_id_test.cpp
@@ -0,0 +1,186 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaAlbumsControllerServiceTest"
+
+#include "get_face_id_test.h"
+
+#include <string>
+#include <vector>
+
+#define private public
+#define protected public
+#include "media_albums_controller_service.h"
+#undef private
+#undef protected
+
+#include "get_face_id_vo.h"
+
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "result_set_utils.h"
+#include "media_file_uri.h"
+
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+using OHOS::DataShare::DataSharePredicates;
+
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 1;
+static const string SQL_INSERT_PHOTO =
+    "INSERT INTO " + PhotoColumn::PHOTOS_TABLE + "(" + MediaColumn::MEDIA_FILE_PATH + ", " + MediaColumn::MEDIA_SIZE +
+    ", " + MediaColumn::MEDIA_TITLE + ", " + MediaColumn::MEDIA_NAME + ", " + MediaColumn::MEDIA_TYPE + ", " +
+    MediaColumn::MEDIA_OWNER_PACKAGE + ", " + MediaColumn::MEDIA_PACKAGE_NAME + ", " + MediaColumn::MEDIA_DATE_ADDED +
+    ", " + MediaColumn::MEDIA_DATE_MODIFIED + ", " + MediaColumn::MEDIA_DATE_TAKEN + ", " +
+    MediaColumn::MEDIA_DURATION + ", " + MediaColumn::MEDIA_IS_FAV + ", " + MediaColumn::MEDIA_DATE_TRASHED + ", " +
+    MediaColumn::MEDIA_HIDDEN + ", " + PhotoColumn::PHOTO_HEIGHT + ", " + PhotoColumn::PHOTO_WIDTH + ", " +
+    PhotoColumn::PHOTO_EDIT_TIME + ", " + PhotoColumn::PHOTO_SHOOTING_MODE + ")";
+static const string VALUES_END = ") ";
+
+static int32_t ClearTable(const string &table)
+{
+    RdbPredicates predicates(table);
+
+    int32_t rows = 0;
+    int32_t err = g_rdbStore->Delete(rows, predicates);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to clear photos table, err: %{public}d", err);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+
+void GetFaceIdTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start MediaLibraryPhotoOperationsTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+    ClearTable("AnalysisAlbum");
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+
+void GetFaceIdTest::TearDownTestCase(void)
+{
+    ClearTable("AnalysisAlbum");
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+
+void GetFaceIdTest::SetUp()
+{
+    ClearTable("AnalysisAlbum");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+    MEDIA_INFO_LOG("SetUp");
+}
+
+void GetFaceIdTest::TearDown(void)
+{
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+    MEDIA_INFO_LOG("TearDown");
+}
+
+static int32_t GetFaceId(int32_t albumId, int32_t albumSubType, string &groupTag)
+{
+    GetFaceIdReqBody reqBody;
+    reqBody.albumId = albumId;
+    reqBody.albumSubType = albumSubType;
+
+    MessageParcel data;
+    if (reqBody.Marshalling(data) != true) {
+        MEDIA_ERR_LOG("reqBody.Marshalling failed");
+        return -1;
+    }
+
+    MessageParcel reply;
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->GetFaceId(data, reply);
+
+    IPC::MediaRespVo<GetFaceIdRespBody> respVo;
+    if (respVo.Unmarshalling(reply) != true) {
+        MEDIA_ERR_LOG("respVo.Unmarshalling failed");
+        return -1;
+    }
+    int32_t errCode = respVo.GetErrCode();
+    if (errCode != 0) {
+        MEDIA_ERR_LOG("respVo.GetErrCode: %{public}d", errCode);
+        return errCode;
+    }
+    groupTag = respVo.GetBody().groupTag;
+    return 0;
+}
+
+static void InsertAnalysisAlbum()
+{
+    std::string insertSql = "INSERT INTO AnalysisAlbum (album_name, album_subtype, group_tag) VALUES "
+                            "('newalbum', 4103, 'success')";
+    int32_t ret = g_rdbStore->ExecuteSql(insertSql);
+    if (ret != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("Execute sql %{public}s failed", insertSql.c_str());
+    }
+}
+
+static int32_t QueryAlbumIdByAlbumName(const string &albumName)
+{
+    vector<string> columns;
+    RdbPredicates rdbPredicates("AnalysisAlbum");
+    rdbPredicates.EqualTo("album_name", albumName);
+    auto resultSet = MediaLibraryRdbStore::Query(rdbPredicates, columns);
+    if (resultSet == nullptr || resultSet->GoToFirstRow() != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("Can not get fileId");
+        return -1;
+    }
+    int32_t album_id = GetInt32Val("album_id", resultSet);
+    return album_id;
+}
+
+HWTEST_F(GetFaceIdTest, QueryCloudEnhancementTaskState_Test_001, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("QueryCloudEnhancementTaskState_Test_001 Begin");
+    // invalid albumId
+    string groupTag;
+    int32_t result = GetFaceId(100000, PhotoAlbumSubType::GROUP_PHOTO, groupTag);
+    ASSERT_NE(result, 0);
+}
+
+HWTEST_F(GetFaceIdTest, QueryCloudEnhancementTaskState_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("QueryCloudEnhancementTaskState_Test_002 Begin");
+    // invalid albumSubType
+    InsertAnalysisAlbum();
+    int32_t albumId = QueryAlbumIdByAlbumName("newalbum");
+    string groupTag;
+    int32_t result = GetFaceId(albumId, PhotoAlbumSubType::ANALYSIS_END, groupTag);
+    ASSERT_NE(result, 0);
+}
+
+HWTEST_F(GetFaceIdTest, QueryCloudEnhancementTaskState_Test_003, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("QueryCloudEnhancementTaskState_Test_003 Begin");
+    InsertAnalysisAlbum();
+    int32_t albumId = QueryAlbumIdByAlbumName("newalbum");
+    MEDIA_INFO_LOG("albumId %{public}d", albumId);
+    string groupTag;
+    int32_t result = GetFaceId(albumId, PhotoAlbumSubType::GROUP_PHOTO, groupTag);
+    ASSERT_EQ(result, 0);
+    ASSERT_EQ(groupTag, "success");
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_highlight_album_info_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_highlight_album_info_test.cpp
new file mode 100644
index 0000000000..68a4e70fd0
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_highlight_album_info_test.cpp
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#define MLOG_TAG "MediaAlbumsControllerServiceTest"
+ 
+#include "get_highlight_album_info_test.h"
+ 
+#include <string>
+#include <vector>
+ 
+#define private public
+#define protected public
+#include "datashare_result_set.h"
+#include "media_albums_controller_service.h"
+#include "media_assets_service.h"
+#include "rdb_utils.h"
+#undef private
+#undef protected
+ 
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "result_set_utils.h"
+#include "get_highlight_album_info_vo.h"
+#include "query_result_vo.h"
+ 
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+ 
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 1;
+ 
+static int32_t ClearTable(const string &table)
+{
+    RdbPredicates predicates(table);
+ 
+    int32_t rows = 0;
+    int32_t err = g_rdbStore->Delete(rows, predicates);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to clear album table, err: %{public}d", err);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+ 
+void GetHightlightAlbumInfoTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start GetHightlightAlbumInfoTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+ 
+void GetHightlightAlbumInfoTest::TearDownTestCase(void)
+{
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+ 
+void GetHightlightAlbumInfoTest::SetUp()
+{
+    MEDIA_INFO_LOG("SetUp");
+}
+ 
+void GetHightlightAlbumInfoTest::TearDown(void)
+{
+    MEDIA_INFO_LOG("TearDown");
+}
+ 
+HWTEST_F(GetHightlightAlbumInfoTest, GetHightlightAlbumInfoTest_Test_001, TestSize.Level0)
+{
+    GetHighlightAlbumReqBody reqBody;
+    reqBody.highlightAlbumInfoType = PLAY_INFO;
+    MessageParcel data;
+    MessageParcel reply;
+    reqBody.Marshalling(data);
+
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->GetHighlightAlbumInfo(data, reply);
+    IPC::MediaRespVo<QueryResultRspBody> resp;
+    bool isValid = resp.Unmarshalling(reply);
+    ASSERT_EQ(isValid, true);
+    EXPECT_EQ(resp.GetErrCode(), E_ERR);
+    EXPECT_EQ(resp.GetBody().resultSet, nullptr);
+}
+ 
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_order_position_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_order_position_test.cpp
new file mode 100755
index 0000000000..e97b4b6ccc
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_order_position_test.cpp
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaAlbumsControllerServiceTest"
+
+#include "get_order_position_test.h"
+
+#include <string>
+#include <vector>
+
+#define private public
+#define protected public
+#include "media_albums_controller_service.h"
+#undef private
+#undef protected
+
+#include "get_order_position_vo.h"
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "result_set_utils.h"
+#include "media_file_uri.h"
+#include "vision_photo_map_column.h"
+
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+using namespace IPC;
+
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 1;
+
+static string g_albumName = "test01";
+static string g_data = "/storage/cloud/files/Photo/9/IMG_1748505946_009.jpg";
+static string g_title = "cam_pic";
+
+static int32_t ClearTable(const string &table)
+{
+    RdbPredicates predicates(table);
+
+    int32_t rows = 0;
+    int32_t err = g_rdbStore->Delete(rows, predicates);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to clear album table, err: %{public}d", err);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+
+void GetOrderPositionTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start MediaLibraryPhotoOperationsTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+    ClearTable(PhotoAlbumColumns::TABLE);
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+
+void GetOrderPositionTest::TearDownTestCase(void)
+{
+    ClearTable(PhotoAlbumColumns::TABLE);
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+
+void GetOrderPositionTest::SetUp()
+{
+    MEDIA_INFO_LOG("SetUp");
+}
+
+void GetOrderPositionTest::TearDown(void)
+{
+    MEDIA_INFO_LOG("TearDown");
+}
+
+static const string SQL_CREATE_ALBUM = "INSERT INTO " + ANALYSIS_ALBUM_TABLE + "(" +
+    PhotoAlbumColumns::ALBUM_ID + ", " + PhotoAlbumColumns::ALBUM_TYPE + ", " +
+    PhotoAlbumColumns::ALBUM_SUBTYPE + ", " + PhotoAlbumColumns::ALBUM_NAME + ", " +
+    PhotoAlbumColumns::ALBUM_COUNT + ", " + PhotoAlbumColumns::ALBUM_DATE_MODIFIED + ")";
+
+// (albumType == PhotoAlbumType::SMART) &&
+// (albumSubType >= PhotoAlbumSubType::ANALYSIS_START && albumSubType <= PhotoAlbumSubType::ANALYSIS_END); 4097-4111
+static void CreateAnalysisAlbum(const std::string &albumName)
+{
+    // album_type, album_subtype, album_name, date_modified, is_local, date_added, lpath, priority
+    int32_t count = g_rdbStore->ExecuteSql("SELECT COUNT(*) FROM " + ANALYSIS_ALBUM_TABLE);
+    int32_t albumId = count + 1;
+    g_rdbStore->ExecuteSql(SQL_CREATE_ALBUM + "VALUES (" + to_string(albumId) +
+        ", 4096, 4097, '"+ albumName + "', 2, 1748354341383)");
+}
+
+static const string SQL_INSERT_ASSET_POSITION = "INSERT INTO " + ANALYSIS_PHOTO_MAP_TABLE + "(" +
+    MAP_ALBUM + ", " + MAP_ASSET + ", " + ORDER_POSITION + ")";
+
+static void InsertAssetIntoPhotosTable(int32_t albumId, int32_t mapAsset, int32_t orderPosition)
+{
+    // map_album, map_asset, order_position
+    g_rdbStore->ExecuteSql(SQL_INSERT_ASSET_POSITION + "VALUES (" + to_string(albumId) + ", " +
+        to_string(mapAsset) + ", " + to_string(orderPosition) + ")");
+}
+
+static shared_ptr<NativeRdb::ResultSet> QueryAsset(const string& table, const string& key, const string& value,
+    const vector<string>& columns)
+{
+    RdbPredicates rdbPredicates(table);
+    rdbPredicates.EqualTo(key, value);
+    auto resultSet = MediaLibraryRdbStore::Query(rdbPredicates, columns);
+    if (resultSet == nullptr || resultSet->GoToFirstRow() != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("Can not get file asset");
+        return nullptr;
+    }
+    return resultSet;
+}
+
+static void GetOrderPositionPrepare(int32_t& albumId)
+{
+    // 1、创建AnalysisAlbum
+    CreateAnalysisAlbum(g_albumName);
+    vector<string> columns;
+    auto resultSet = QueryAsset(ANALYSIS_ALBUM_TABLE, PhotoAlbumColumns::ALBUM_NAME, g_albumName, columns);
+    if (resultSet == nullptr) {
+        return;
+    }
+
+    albumId = GetInt32Val(PhotoAlbumColumns::ALBUM_ID, resultSet);
+    if (albumId <= 0) {
+        return;
+    }
+
+    // 2、插入一条数据照片到相册
+    InsertAssetIntoPhotosTable(albumId, 10010, 666);
+    InsertAssetIntoPhotosTable(albumId, 10011, 888);
+    resultSet = QueryAsset(ANALYSIS_PHOTO_MAP_TABLE, MAP_ASSET, to_string(10010), columns);
+    if (resultSet == nullptr) {
+        return;
+    }
+
+    int32_t orderPosition = GetInt32Val(ORDER_POSITION, resultSet);
+    if (orderPosition <= 0) {
+        return;
+    }
+}
+
+static int32_t GetOrderPosition(int32_t albumId, int32_t albumType, int32_t albumSubType,
+    const std::vector<std::string> &assetsArray)
+{
+    GetOrderPositionReqBody reqBody;
+    reqBody.albumId = albumId;
+    reqBody.albumType = albumType;
+    reqBody.albumSubType = albumSubType;
+    reqBody.assetIdArray = assetsArray;
+
+    MessageParcel data;
+    if (reqBody.Marshalling(data) != true) {
+        MEDIA_ERR_LOG("reqBody.Marshalling failed");
+        return -1;
+    }
+
+    MessageParcel reply;
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->GetOrderPosition(data, reply);
+
+    IPC::MediaRespVo<GetOrderPositionRespBody> resp;
+    if (resp.Unmarshalling(reply) != true) {
+        MEDIA_ERR_LOG("resp.Unmarshalling failed");
+        return -1;
+    }
+
+    return resp.GetErrCode();
+}
+
+HWTEST_F(GetOrderPositionTest, GetOrderPositionTest_Test_001, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start GetOrderPositionTest_Test_001");
+    // 1、前置条件准备
+    int32_t albumId = -1;
+    GetOrderPositionPrepare(albumId);
+    EXPECT_GT(albumId, 0);
+
+    // 2、查询资产orderposition
+    vector<string> assetsArray = {"10010", "10011"};
+    int32_t ret = GetOrderPosition(albumId, PhotoAlbumType::USER, PhotoAlbumSubType::CLASSIFY, assetsArray);
+    EXPECT_EQ(ret, E_INVALID_VALUES);
+
+    ret = GetOrderPosition(albumId, PhotoAlbumType::SMART, PhotoAlbumSubType::ANALYSIS_START - 1, assetsArray);
+    EXPECT_EQ(ret, E_INVALID_VALUES);
+
+    ret = GetOrderPosition(albumId, PhotoAlbumType::SMART, PhotoAlbumSubType::ANALYSIS_END + 1, assetsArray);
+    EXPECT_EQ(ret, E_INVALID_VALUES);
+
+    ret = GetOrderPosition(albumId, PhotoAlbumType::SMART, PhotoAlbumSubType::CLASSIFY, {});
+    EXPECT_EQ(ret, E_INVALID_VALUES);
+
+    ret = GetOrderPosition(albumId, PhotoAlbumType::SMART, PhotoAlbumSubType::CLASSIFY, {"10010", "10010"});
+    EXPECT_EQ(ret, E_INVALID_VALUES);
+
+    ret = GetOrderPosition(albumId, PhotoAlbumType::SMART, PhotoAlbumSubType::CLASSIFY, assetsArray);
+    EXPECT_EQ(ret, E_OK);
+    MEDIA_INFO_LOG("end GetOrderPositionTest_Test_001");
+}
+
+HWTEST_F(GetOrderPositionTest, GetOrderPositionTest_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start GetOrderPositionTest_Test_002");
+    MessageParcel data;
+    MessageParcel reply;
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->GetOrderPosition(data, reply);
+
+    IPC::MediaRespVo<GetOrderPositionRespBody> resp;
+    ASSERT_EQ(resp.Unmarshalling(reply), true);
+    ASSERT_LT(resp.GetErrCode(), 0);
+    MEDIA_INFO_LOG("end GetOrderPositionTest_Test_002");
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_photo_index_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_photo_index_test.cpp
new file mode 100644
index 0000000000..626c16ca4f
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/get_photo_index_test.cpp
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#define MLOG_TAG "MediaAssetsControllerServiceTest"
+ 
+#include "get_photo_index_test.h"
+ 
+#include <string>
+#include <vector>
+ 
+#define private public
+#define protected public
+#include "datashare_result_set.h"
+#include "media_albums_controller_service.h"
+#include "media_assets_service.h"
+#include "rdb_utils.h"
+#undef private
+#undef protected
+ 
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "result_set_utils.h"
+#include "get_photo_index_vo.h"
+#include "query_result_vo.h"
+ 
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+ 
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 1;
+ 
+static int32_t DeleteDatabaseData()
+{
+    if (g_rdbStore == nullptr) {
+        std::cout << "g_rdbStore == nullptr" << std::endl;
+        return E_ERR;
+    }
+    std::cout << "DeleteDatabaseData" << std::endl;
+    // delete photo
+    std::string deletePhotoData = "DELETE FROM " + PhotoColumn::PHOTOS_TABLE;
+    int32_t ret = g_rdbStore->ExecuteSql(deletePhotoData);
+    if (ret != NativeRdb::E_OK) {
+        std::cout << "Delete Photos Data Failed:" << deletePhotoData;
+        return E_ERR;
+    }
+    std::cout << "Delete Photos Data success." << std::endl;
+
+    // tab_analysis_total
+    std::string deleteAnalysisTotalSql = "DELETE FROM tab_analysis_total;";
+    ret = g_rdbStore->ExecuteSql(deleteAnalysisTotalSql);
+    if (ret != NativeRdb::E_OK) {
+        std::cout << "Delete tab_analysis_total Data Failed:" << deleteAnalysisTotalSql;
+        return E_ERR;
+    }
+    std::cout << "Delete tab_analysis_total Data success." << std::endl;
+
+    // tab_user_photography_info
+    std::string deleteUserPhotographyInfo = "DELETE FROM tab_user_photography_info;";
+    ret = g_rdbStore->ExecuteSql(deleteUserPhotographyInfo);
+    if (ret != NativeRdb::E_OK) {
+        std::cout << "Delete tab_user_photography_info Data Failed:" << deleteAnalysisTotalSql;
+        return E_ERR;
+    }
+    std::cout << "Delete tab_user_photography_info Data success." << std::endl;
+
+    // tab_highlight_album
+    std::string deleteHightlightAlbum = "DELETE FROM tab_highlight_album;";
+    ret = g_rdbStore->ExecuteSql(deleteHightlightAlbum);
+    if (ret != NativeRdb::E_OK) {
+        std::cout << "Delete tab_highlight_album Data Failed:" << deleteAnalysisTotalSql;
+        return E_ERR;
+    }
+    std::cout << "Delete tab_highlight_album Data success." << std::endl;
+
+    std::string deletePhotoAlbum = "DELETE FROM PhotoAlbum;";
+    ret = g_rdbStore->ExecuteSql(deletePhotoAlbum);
+    if (ret != NativeRdb::E_OK) {
+        std::cout << "Delete PhotoAlbum Data Failed:" << deletePhotoAlbum;
+        return E_ERR;
+    }
+    std::cout << "Delete PhotoAlbum Data success." << std::endl;
+
+    std::string deleteAnalysisPhotoMap = "DELETE FROM AnalysisPhotoMap;";
+    ret = g_rdbStore->ExecuteSql(deleteAnalysisPhotoMap);
+    if (ret != NativeRdb::E_OK) {
+        std::cout << "Delete AnalysisPhotoMap Data Failed:" << deleteAnalysisPhotoMap;
+        return E_ERR;
+    }
+    std::cout << "Delete AnalysisPhotoMap Data success." << std::endl;
+
+    return E_OK;
+}
+ 
+ 
+void GetPhotoIndexTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start GetPhotoIndexTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+    DeleteDatabaseData();
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+ 
+void GetPhotoIndexTest::TearDownTestCase(void)
+{
+    DeleteDatabaseData();
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+ 
+void GetPhotoIndexTest::SetUp()
+{
+    DeleteDatabaseData();
+    MEDIA_INFO_LOG("SetUp");
+}
+ 
+void GetPhotoIndexTest::TearDown(void)
+{
+    DeleteDatabaseData();
+    MEDIA_INFO_LOG("TearDown");
+}
+ 
+static void InsertAssetIntoPhotosTable(const std::string &filePath, const std::string &photoId, int photoQuality)
+{
+    const std::string sqlInsertPhoto = "INSERT INTO " + PhotoColumn::PHOTOS_TABLE + "("  +
+        MediaColumn::MEDIA_FILE_PATH + ", " + MediaColumn::MEDIA_SIZE + ", " + MediaColumn::MEDIA_TITLE + ", " +
+        MediaColumn::MEDIA_NAME + ", " + MediaColumn::MEDIA_TYPE + ", " + MediaColumn::MEDIA_OWNER_PACKAGE + ", " +
+        MediaColumn::MEDIA_PACKAGE_NAME + ", " + MediaColumn::MEDIA_DATE_ADDED + ", "  +
+        MediaColumn::MEDIA_DATE_MODIFIED + ", " + MediaColumn::MEDIA_DATE_TAKEN + ", " +
+        MediaColumn::MEDIA_DURATION + ", " + MediaColumn::MEDIA_IS_FAV + ", " + MediaColumn::MEDIA_DATE_TRASHED + ", " +
+        MediaColumn::MEDIA_HIDDEN + ", " + PhotoColumn::PHOTO_HEIGHT + ", " + PhotoColumn::PHOTO_WIDTH + ", " +
+        PhotoColumn::PHOTO_EDIT_TIME + ", " + PhotoColumn::PHOTO_SHOOTING_MODE + ", " + PhotoColumn::PHOTO_ID + ", " +
+        PhotoColumn::PHOTO_QUALITY + ")";
+    g_rdbStore->ExecuteSql(sqlInsertPhoto + "VALUES (" +
+        "'" + filePath + "', 175258, 'cam_pic', 'cam_pic.jpg', 1, " +
+        "'com.ohos.camera', '相机', 1501924205218, 0, 1501924205, 0, 0, 0, 0, " +
+        "1280, 960, 0, '1', '" + photoId  + "', " + std::to_string(photoQuality) + ")"); // cam, pic, shootingmode = 1
+}
+
+// ANALYSIS_PHOTO_MAP_TABLE
+static int InsertAnalysisPhotoMap(int mediaId)
+{
+    int ret = g_rdbStore->ExecuteSql(
+        "insert into AnalysisPhotoMap(map_album, map_asset) values(" + std::to_string(mediaId) + ", 1000012)");
+    return ret;
+}
+
+// PhotoAlbumColumns::TABLE
+static int InsertPhotoAlbum()
+{
+    int ret = g_rdbStore->ExecuteSql(
+        "insert into PhotoAlbum(album_id, album_type, album_subtype) values(1, 1024, 1025)");
+    return ret;
+}
+
+HWTEST_F(GetPhotoIndexTest, GetPhotoIndexTest_Test_001, TestSize.Level0)
+{
+    bool createDirRes = MediaFileUtils::CreateDirectory("/data/local/tmp");
+    EXPECT_EQ(createDirRes, true);
+    std::string filePath = "/data/local/tmp/IMG_1501924305_001.jpg";
+    if (!MediaFileUtils::IsFileExists(filePath)) {
+        bool createFileRes = MediaFileUtils::CreateFile(filePath);
+        EXPECT_EQ(createFileRes, true);
+    }
+    const std::string photoId = "photo_id_test";
+    int photoQuality = 1;
+    InsertAssetIntoPhotosTable(filePath, photoId, photoQuality);
+ 
+    RdbPredicates rdbPredicates(PhotoColumn::PHOTOS_TABLE);
+    rdbPredicates.EqualTo(MediaColumn::MEDIA_FILE_PATH, filePath);
+    std::vector<std::string> columns = { MediaColumn::MEDIA_ID, PhotoColumn::PHOTO_ID, PhotoColumn::PHOTO_QUALITY };
+ 
+    shared_ptr<NativeRdb::ResultSet> resSet = MediaLibraryRdbStore::Query(rdbPredicates, columns);
+    EXPECT_NE(resSet, nullptr);
+    EXPECT_EQ(resSet->GoToNextRow(), NativeRdb::E_OK);
+    EXPECT_EQ(InsertAnalysisPhotoMap(GetInt32Val(MediaColumn::MEDIA_ID, resSet)), NativeRdb::E_OK) ;
+    RdbPredicates analysisPhotoMapPredicates(ANALYSIS_PHOTO_MAP_TABLE);
+    columns = { "map_album" };
+    resSet = MediaLibraryRdbStore::Query(analysisPhotoMapPredicates, columns);
+    int rowsCount = 0;
+    while (resSet->GoToNextRow() == NativeRdb::E_OK) {
+        std::string val = "";
+        resSet->GetString(0, val);
+        std::cout << "map_album = " << val << std::endl;
+        ++rowsCount;
+    }
+    std::cout << "analysisPhotoMap rowsCount = " << rowsCount << std::endl;
+
+    RdbPredicates photoAlbumPredicates(PhotoAlbumColumns::TABLE);
+    columns = { "album_id", "album_type" };
+    resSet = MediaLibraryRdbStore::Query(photoAlbumPredicates, columns);
+    EXPECT_NE(resSet, nullptr);
+    rowsCount = 0;
+    std::string album_id = "";
+    while (resSet->GoToNextRow() == NativeRdb::E_OK) {
+        resSet->GetString(0, album_id);
+        std::cout << "album_id = " << album_id << std::endl;
+        ++rowsCount;
+    }
+    EXPECT_EQ(rowsCount, 1);
+    std::cout << "photoAlbum rowsCount = " << rowsCount << std::endl;
+    columns = { photoId, album_id };
+    GetPhotoIndexReqBody reqBody;
+    DataShare::DataSharePredicates dataSharePredicates;
+    reqBody.predicates = dataSharePredicates;
+    reqBody.photoId = photoId;
+    reqBody.albumId = album_id;
+    reqBody.isAnalysisAlbum = false;
+    MessageParcel data;
+    MessageParcel reply;
+    reqBody.Marshalling(data);
+    auto service = make_shared<MediaAlbumsControllerService>();
+    service->GetPhotoIndex(data, reply);
+    IPC::MediaRespVo<QueryResultRspBody> resp;
+    bool isValid = resp.Unmarshalling(reply);
+    ASSERT_EQ(isValid, true);
+    EXPECT_NE(resp.GetErrCode(), E_SUCCESS);
+}
+ 
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/media_albums_controller_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/media_albums_controller_test.cpp
new file mode 100644
index 0000000000..ec9a4a1b8f
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/media_albums_controller_test.cpp
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaAlbumsControllerTest"
+
+#include "media_albums_controller_test.h"
+
+#include <memory>
+#include <string>
+
+#define private public
+#define protected public
+#include "media_albums_controller_service.h"
+#undef private
+#undef protected
+
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "result_set_utils.h"
+#include "media_file_uri.h"
+
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 1;
+
+static int32_t ClearTable(const string &table)
+{
+    RdbPredicates predicates(table);
+
+    int32_t rows = 0;
+    int32_t err = g_rdbStore->Delete(rows, predicates);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to clear album table, err: %{public}d", err);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+
+void MediaAlbumsControllerTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start MediaLibraryPhotoOperationsTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+    ClearTable(PhotoAlbumColumns::TABLE);
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+
+void MediaAlbumsControllerTest::TearDownTestCase(void)
+{
+    ClearTable(PhotoAlbumColumns::TABLE);
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+
+void MediaAlbumsControllerTest::SetUp()
+{
+    MEDIA_INFO_LOG("SetUp");
+}
+
+void MediaAlbumsControllerTest::TearDown(void)
+{
+    MEDIA_INFO_LOG("TearDown");
+}
+
+HWTEST_F(MediaAlbumsControllerTest, OnRemoteRequest_Test_001, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("OnRemoteRequest_Test_001 enter");
+
+    auto controller = make_shared<MediaAlbumsControllerService>();
+    uint32_t start = static_cast<uint32_t>(MediaLibraryBusinessCode::ALBUMS_BUSINESS_CODE_START);
+    uint32_t end = static_cast<uint32_t>(MediaLibraryBusinessCode::ALBUMS_BUSINESS_CODE_END);
+    for (uint32_t code = start; code < end; ++code) {
+        MessageParcel data;
+        data.WriteInt32(INT32_MIN);
+        MessageParcel reply;
+        reply.WriteInt32(INT32_MIN);
+        MessageOption option;
+        IPC::IPCContext context(option, E_PERMISSION_DB_BYPASS);
+        controller->OnRemoteRequest(code, data, reply, context);
+        IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+        ASSERT_EQ(respVo.Unmarshalling(reply), true);
+        MEDIA_INFO_LOG("OnRemoteRequest Unmarshalling ErrCode:%{public}d", respVo.GetErrCode());
+        ASSERT_LE(respVo.GetErrCode(), 0);
+    }
+
+    MEDIA_INFO_LOG("OnRemoteRequest_Test_001 end");
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/query_albums_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/query_albums_test.cpp
new file mode 100644
index 0000000000..f5bf796d8b
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_albums_controller_service_test/src/query_albums_test.cpp
@@ -0,0 +1,291 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaAlbumsControllerServiceTest"
+
+#include "query_albums_test.h"
+
+#include <memory>
+#include <string>
+
+#include "media_albums_controller_service.h"
+
+#include "query_albums_vo.h"
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "vision_column.h"
+
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 3;
+static std::vector<std::string> ALBUM_FETCH_COLUMNS = {
+    PhotoAlbumColumns::ALBUM_ID, PhotoAlbumColumns::ALBUM_NAME, PhotoAlbumColumns::ALBUM_SUBTYPE
+};
+
+static std::string Quote(const std::string &str)
+{
+    return "'" + str + "'";
+}
+
+static void ClearTable(const string &table)
+{
+    int32_t rows = 0;
+    RdbPredicates predicates(table);
+    int32_t errCode = g_rdbStore->Delete(rows, predicates);
+    CHECK_AND_RETURN_LOG(errCode == E_OK, "g_rdbStore->Delete errCode:%{public}d", errCode);
+}
+
+static void ShowResultSet(std::shared_ptr<DataShare::DataShareResultSet> resultSet)
+{
+    std::vector<std::string> columns;
+    resultSet->GetAllColumnNames(columns);
+    while (resultSet->GoToNextRow() == NativeRdb::E_OK) {
+        std::string tag;
+        std::string rowData;
+        for (size_t i = 0; i < columns.size(); i++) {
+            std::string value;
+            resultSet->GetString(i, value);
+            rowData += tag + columns[i] + ":'" + value + "'";
+            tag = ",";
+        }
+        MEDIA_INFO_LOG("rowData:[%{public}s]", rowData.c_str());
+    }
+}
+
+static int32_t DeleteAlbum(int32_t albumType, int32_t albumSubType)
+{
+    RdbPredicates predicates(PhotoAlbumColumns::TABLE);
+    predicates.EqualTo(PhotoAlbumColumns::ALBUM_TYPE, to_string(albumType));
+    predicates.EqualTo(PhotoAlbumColumns::ALBUM_SUBTYPE, to_string(albumSubType));
+    int32_t rows = 0;
+    int32_t err = g_rdbStore->Delete(rows, predicates);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to clear album table, err: %{public}d", err);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+
+static int32_t CreateAlbum(int32_t albumType, int32_t albumSubType)
+{
+    int64_t now = MediaFileUtils::UTCTimeMilliSeconds();
+    int32_t hidden = (albumSubType == PhotoAlbumSubType::HIDDEN) ? 1 : 0;
+    const std::string albumName = "albumSubType" + to_string(albumSubType);
+    std::vector<std::pair<std::string, std::string>> items = {
+        {PhotoAlbumColumns::ALBUM_NAME, Quote(albumName)},
+        {PhotoAlbumColumns::ALBUM_TYPE, to_string(albumType)},
+        {PhotoAlbumColumns::ALBUM_SUBTYPE, to_string(albumSubType)},
+        {PhotoAlbumColumns::ALBUM_DATE_MODIFIED, to_string(now)},
+        {PhotoAlbumColumns::ALBUM_DATE_ADDED, to_string(now)},
+        {PhotoAlbumColumns::ALBUM_LPATH, Quote("/Pictures/" + albumName)},
+        {PhotoAlbumColumns::CONTAINS_HIDDEN, to_string(hidden)},
+        {PhotoAlbumColumns::ALBUM_IS_LOCAL, "1"},
+        {PhotoAlbumColumns::ALBUM_PRIORITY, "1"},
+    };
+
+    std::string values;
+    std::string columns;
+    for (const auto &item : items) {
+        if (!columns.empty()) {
+            columns.append(",");
+            values.append(",");
+        }
+        columns.append(item.first);
+        values.append(item.second);
+    }
+    std::string sql = "INSERT INTO " + PhotoAlbumColumns::TABLE + "(" + columns + ") VALUES (" + values + ")";
+    return g_rdbStore->ExecuteSql(sql);
+}
+
+void QueryAlbumsTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start MediaLibraryPhotoOperationsTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+
+    ClearTable(ANALYSIS_ALBUM_TABLE);
+    ClearTable(PhotoAlbumColumns::TABLE);
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+
+void QueryAlbumsTest::TearDownTestCase(void)
+{
+    ClearTable(ANALYSIS_ALBUM_TABLE);
+    ClearTable(PhotoAlbumColumns::TABLE);
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+
+void QueryAlbumsTest::SetUp()
+{
+    MEDIA_INFO_LOG("SetUp");
+}
+
+void QueryAlbumsTest::TearDown(void)
+{
+    MEDIA_INFO_LOG("TearDown");
+}
+
+using ServiceCall = std::function<void(MessageParcel &data, MessageParcel &reply)>;
+
+int32_t ServiceQueryAlbumsCount(QueryAlbumsReqBody &reqBody, ServiceCall call)
+{
+    MessageParcel data;
+    if (reqBody.Marshalling(data) != true) {
+        MEDIA_ERR_LOG("reqBody.Marshalling failed");
+        return -1;
+    }
+
+    MessageParcel reply;
+    call(data, reply);
+
+    IPC::MediaRespVo<QueryAlbumsRspBody> respVo;
+    if (respVo.Unmarshalling(reply) != true) {
+        MEDIA_ERR_LOG("respVo.Unmarshalling failed");
+        return -1;
+    }
+
+    int32_t errCode = respVo.GetErrCode();
+    if (errCode != 0) {
+        MEDIA_ERR_LOG("respVo.GetErrCode: %{public}d", errCode);
+        return errCode;
+    }
+
+    auto resultSet = respVo.GetBody().resultSet;
+    if (resultSet == nullptr) {
+        MEDIA_ERR_LOG("resultSet nullptr");
+        return -1;
+    }
+
+    ShowResultSet(resultSet);
+
+    int32_t rowCount = 0;
+    resultSet->GetRowCount(rowCount);
+    resultSet->Close();
+    return rowCount;
+}
+
+int32_t GetAlbumsCount(int32_t albumType, int32_t albumSubType)
+{
+    ServiceCall call = [](MessageParcel &data, MessageParcel &reply) {
+        auto service = make_shared<MediaAlbumsControllerService>();
+        service->QueryAlbums(data, reply);
+    };
+
+    QueryAlbumsReqBody reqBody;
+    reqBody.albumType = albumType;
+    reqBody.albumSubType = albumSubType;
+    reqBody.columns = ALBUM_FETCH_COLUMNS;
+    return ServiceQueryAlbumsCount(reqBody, call);
+}
+
+int32_t GetHiddenAlbumsCount(int32_t hiddenAlbumFetchMode, const std::vector<std::string> &columns = {})
+{
+    ServiceCall call = [](MessageParcel &data, MessageParcel &reply) {
+        auto service = make_shared<MediaAlbumsControllerService>();
+        service->QueryHiddenAlbums(data, reply);
+    };
+
+    QueryAlbumsReqBody reqBody;
+    reqBody.hiddenAlbumFetchMode = hiddenAlbumFetchMode;
+    reqBody.columns = ALBUM_FETCH_COLUMNS;
+    reqBody.columns.insert(reqBody.columns.end(), columns.begin(), columns.end());
+    return ServiceQueryAlbumsCount(reqBody, call);
+}
+
+int32_t CreateAlbumTest(int32_t albumType, int32_t albumSubType)
+{
+    int32_t count = 0;
+    if (CreateAlbum(albumType, albumSubType) == E_OK) {
+        count = GetAlbumsCount(albumType, albumSubType);
+        DeleteAlbum(albumType, albumSubType);
+    }
+    return count;
+}
+
+HWTEST_F(QueryAlbumsTest, QueryHiddenAlbums_Test_001, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start QueryHiddenAlbums_Test_001");
+    ASSERT_LT(GetHiddenAlbumsCount(0, {"aaa"}), 0);
+    ASSERT_LT(GetHiddenAlbumsCount(1, {"aaa"}), 0);
+    ASSERT_EQ(GetHiddenAlbumsCount(0), 0);
+    ASSERT_EQ(GetHiddenAlbumsCount(1), 0);
+    if (CreateAlbum(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::HIDDEN) == E_OK) {
+        ASSERT_EQ(GetHiddenAlbumsCount(0), 1);
+        ASSERT_EQ(GetHiddenAlbumsCount(1), 1);
+        DeleteAlbum(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::HIDDEN);
+    }
+}
+
+HWTEST_F(QueryAlbumsTest, QueryAlbums_Test_001, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start QueryAlbums_Test_001");
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::USER, PhotoAlbumSubType::USER_GENERIC), 0);
+    ASSERT_EQ(CreateAlbumTest(PhotoAlbumType::USER, PhotoAlbumSubType::USER_GENERIC), 1);
+}
+
+HWTEST_F(QueryAlbumsTest, QueryAlbums_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start QueryAlbums_Test_002");
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SOURCE, PhotoAlbumSubType::SOURCE_GENERIC), 0);
+    ASSERT_EQ(CreateAlbumTest(PhotoAlbumType::SOURCE, PhotoAlbumSubType::SOURCE_GENERIC), 0);
+}
+
+HWTEST_F(QueryAlbumsTest, QueryAlbums_Test_003, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start QueryAlbums_Test_003");
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::FAVORITE), 0);
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::VIDEO), 0);
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::HIDDEN), 0);
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::TRASH), 0);
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::SCREENSHOT), 0);
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::CAMERA), 0);
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::IMAGE), 0);
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::CLOUD_ENHANCEMENT), 0);
+
+    ASSERT_EQ(CreateAlbumTest(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::FAVORITE), 1);
+    ASSERT_EQ(CreateAlbumTest(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::VIDEO), 1);
+    ASSERT_EQ(CreateAlbumTest(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::HIDDEN), 0);
+    ASSERT_EQ(CreateAlbumTest(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::TRASH), 0);
+    ASSERT_EQ(CreateAlbumTest(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::SCREENSHOT), 0);
+    ASSERT_EQ(CreateAlbumTest(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::CAMERA), 0);
+    ASSERT_EQ(CreateAlbumTest(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::IMAGE), 1);
+    ASSERT_EQ(CreateAlbumTest(PhotoAlbumType::SYSTEM, PhotoAlbumSubType::CLOUD_ENHANCEMENT), 0);
+}
+
+HWTEST_F(QueryAlbumsTest, QueryAlbums_Test_004, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start QueryAlbums_Test_004");
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SMART, PhotoAlbumSubType::CLASSIFY), 0);
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SMART, PhotoAlbumSubType::GEOGRAPHY_LOCATION), 0);
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SMART, PhotoAlbumSubType::GEOGRAPHY_CITY), 0);
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SMART, PhotoAlbumSubType::SHOOTING_MODE), 0);
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SMART, PhotoAlbumSubType::PORTRAIT), 0);
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SMART, PhotoAlbumSubType::GROUP_PHOTO), 0);
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SMART, PhotoAlbumSubType::HIGHLIGHT), 0);
+    ASSERT_EQ(GetAlbumsCount(PhotoAlbumType::SMART, PhotoAlbumSubType::HIGHLIGHT_SUGGESTIONS), 0);
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/BUILD.gn b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/BUILD.gn
index 985c15d113..e28ce230d6 100644
--- a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/BUILD.gn
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/BUILD.gn
@@ -58,6 +58,8 @@ ohos_unittest("media_assets_controller_service_test") {
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/create_asset_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/delete_photos_completed_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/delete_photos_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_assets_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_index_construct_progress_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/form_info_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/grant_photo_uri_permission_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/grant_photo_uris_permission_vo.cpp",
@@ -70,6 +72,17 @@ ohos_unittest("media_assets_controller_service_test") {
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/stop_thumbnail_creation_task_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/submit_cache_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/trash_photos_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_asset_analysis_data_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/is_edited_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/request_edit_data_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_edit_data_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/start_asset_analysis_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_cloudmedia_asset_status_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/request_content_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/adapted_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/query_photo_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_cloud_enhancement_pair_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/query_cloud_enhancement_task_state_vo.cpp",
     "${MEDIALIB_UTILS_PATH}/src/parameter_utils.cpp",
     "../medialibrary_unittest_utils/src/medialibrary_unittest_utils.cpp",
     "./src/asset_change_request_test.cpp",
@@ -84,6 +97,7 @@ ohos_unittest("media_assets_controller_service_test") {
     "./src/form_info_test.cpp",
     "./src/grant_photo_uri_permission_test.cpp",
     "./src/grant_photo_uris_permission_test.cpp",
+    "./src/media_assets_controller_test.cpp",
     "./src/modify_assets_test.cpp",
     "./src/revert_to_original_test.cpp",
     "./src/save_camera_photo_test.cpp",
@@ -96,6 +110,15 @@ ohos_unittest("media_assets_controller_service_test") {
     "./src/set_user_comment_test.cpp",
     "./src/start_thumbnail_creation_task_test.cpp",
     "./src/stop_thumbnail_creation_task_test.cpp",
+    "./src/get_asset_analysis_data_test.cpp",
+    "./src/queue_edit_asset_status_test.cpp",
+    "./src/request_content_test.cpp",
+    "./src/request_image_test.cpp",
+    "./src/get_index_construct_progress_test.cpp",
+    "./src/get_assets_test.cpp",
+    "./src/get_cloud_enhancement_pair_test.cpp",
+    "./src/query_cloud_enhancement_task_state_test.cpp",
+    "./src/sync_cloud_enhancement_task_status_test.cpp",
   ]
   deps = [
     "${MEDIALIB_INNERKITS_PATH}/media_library_helper:media_library",
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_asset_analysis_data_test.h b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_asset_analysis_data_test.h
new file mode 100644
index 0000000000..256e625e75
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_asset_analysis_data_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef GET_ASSET_ANALYSIS_DATA_TEST_H
+#define GET_ASSET_ANALYSIS_DATA_TEST_H
+
+#include <gtest/gtest.h>
+
+namespace OHOS {
+namespace Media {
+class GetAssetAnalysisDataTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // GET_ASSET_ANALYSIS_DATA_TEST_H
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_assets_test.h b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_assets_test.h
new file mode 100755
index 0000000000..9861a7bad9
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_assets_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef GET_ASSETS_TEST_H
+#define GET_ASSETS_TEST_H
+
+#include <gtest/gtest.h>
+
+namespace OHOS {
+namespace Media {
+class GetAssetsTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // GET_ASSETS_TEST_H
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_cloud_enhancement_pair_test.h b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_cloud_enhancement_pair_test.h
new file mode 100755
index 0000000000..6bef87dd17
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_cloud_enhancement_pair_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef GET_CLOUD_ENHANCEMENT_PAIR_TEST_H
+#define GET_CLOUD_ENHANCEMENT_PAIR_TEST_H
+
+#include <gtest/gtest.h>
+
+namespace OHOS {
+namespace Media {
+class GetCloudEnhancementPairTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // GET_CLOUD_ENHANCEMENT_PAIR_TEST_H
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_index_construct_progress_test.h b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_index_construct_progress_test.h
new file mode 100755
index 0000000000..616759272e
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/get_index_construct_progress_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef GET_INDEX_CONSTRUCT_PROGRESS_TEST_H
+#define GET_INDEX_CONSTRUCT_PROGRESS_TEST_H
+
+#include <gtest/gtest.h>
+
+namespace OHOS {
+namespace Media {
+class GetIndexConstructProgressTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // GET_INDEX_CONSTRUCT_PROGRESS_TEST_H
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/media_assets_controller_test.h b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/media_assets_controller_test.h
new file mode 100755
index 0000000000..59177cfd49
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/media_assets_controller_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MEDIA_ASSETS_CONTROLLER_TEST_H
+#define MEDIA_ASSETS_CONTROLLER_TEST_H
+
+#include <gtest/gtest.h>
+
+namespace OHOS {
+namespace Media {
+class MediaAssetsControllerTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif  // MEDIA_ASSETS_CONTROLLER_TEST_H
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/query_cloud_enhancement_task_state_test.h b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/query_cloud_enhancement_task_state_test.h
new file mode 100755
index 0000000000..434c2102e1
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/query_cloud_enhancement_task_state_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef QUERY_CLOUD_ENHANCEMENT_TASK_STATE_TEST_H
+#define QUERY_CLOUD_ENHANCEMENT_TASK_STATE_TEST_H
+
+#include <gtest/gtest.h>
+
+namespace OHOS {
+namespace Media {
+class QueryCloudEnhancementTaskStateTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // QUERY_CLOUD_ENHANCEMENT_TASK_STATE_TEST_H
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/queue_edit_asset_status_test.h b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/queue_edit_asset_status_test.h
new file mode 100644
index 0000000000..3165124ffe
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/queue_edit_asset_status_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef QUEUE_EDIT_ASSET_STATUS_TEST_H
+#define QUEUE_EDIT_ASSET_STATUS_TEST_H
+
+#include <gtest/gtest.h>
+
+namespace OHOS {
+namespace Media {
+class QueueEditAssetStatusTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // QUEUE_EDIT_ASSET_STATUS_TEST_H
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/request_content_test.h b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/request_content_test.h
new file mode 100755
index 0000000000..22830ec5b2
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/request_content_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REQUEST_CONTENT_TEST_H
+#define REQUEST_CONTENT_TEST_H
+
+#include <gtest/gtest.h>
+
+namespace OHOS {
+namespace Media {
+class RequestContentTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // REQUEST_CONTENT_TEST_H
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/request_image_test.h b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/request_image_test.h
new file mode 100644
index 0000000000..6e607cdace
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/request_image_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#ifndef REQUEST_IMAGE_TEST
+#define REQUEST_IMAGE_TEST
+ 
+#include <gtest/gtest.h>
+ 
+namespace OHOS {
+namespace Media {
+class RequestImageTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // REQUEST_IMAGE_TEST
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/sync_cloud_enhancement_task_status_test.h b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/sync_cloud_enhancement_task_status_test.h
new file mode 100755
index 0000000000..aa7e6b8b1e
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/include/sync_cloud_enhancement_task_status_test.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SYNC_CLOUD_ENHANCEMENT_TASK_STATUS_TEST_H
+#define SYNC_CLOUD_ENHANCEMENT_TASK_STATUS_TEST_H
+
+#include <gtest/gtest.h>
+
+namespace OHOS {
+namespace Media {
+class SyncCloudEnhancementTaskStatusTest : public testing::Test {
+public:
+    static void SetUpTestCase(void);
+    static void TearDownTestCase(void);
+    void SetUp();
+    void TearDown();
+};
+} // namespace Media
+} // namespace OHOS
+#endif // SYNC_CLOUD_ENHANCEMENT_TASK_STATUS_TEST_H
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/asset_change_request_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/asset_change_request_test.cpp
index 8c8387f025..3c6378d896 100755
--- a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/asset_change_request_test.cpp
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/asset_change_request_test.cpp
@@ -431,15 +431,9 @@ HWTEST_F(AssetChangeRequestTest, AssetChangeRequest_Test_009, TestSize.Level0)
     InsertTempAsset();
     int32_t fileId = QueryFileIdByDisplayName("cam_pic.jpg");
     ASSERT_GT(fileId, 0);
-    string path = "file//media/Photo/";
-    int32_t photoQuality = QueryPhotoQualityByDisplayName("cam_pic.jpg");
-    ASSERT_EQ(photoQuality, 0);
 
     int32_t result = DiscardCameraPhoto(fileId);
     ASSERT_EQ(result, 1);
-
-    fileId = QueryFileIdByDisplayName("cam_pic.jpg");
-    ASSERT_LT(fileId, 0);
 }
 
 HWTEST_F(AssetChangeRequestTest, AssetChangeRequest_Test_010, TestSize.Level0)
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/cloud_media_change_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/cloud_media_change_test.cpp
index 307ac4ac68..f1328860b1 100644
--- a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/cloud_media_change_test.cpp
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/cloud_media_change_test.cpp
@@ -94,7 +94,6 @@ HWTEST_F(CloudMediaChangeTest, StartDownloadCloudMedia_Test_001, TestSize.Level0
     auto ret = reqBody.Marshalling(data);
     EXPECT_EQ(ret, true);
 
-
     auto service = make_shared<MediaAssetsControllerService>();
     service->StartDownloadCloudMedia(data, reply);
 
@@ -113,7 +112,6 @@ HWTEST_F(CloudMediaChangeTest, StartDownloadCloudMedia_Test_002, TestSize.Level0
     auto ret = reqBody.Marshalling(data);
     EXPECT_EQ(ret, true);
 
-
     auto service = make_shared<MediaAssetsControllerService>();
     service->StartDownloadCloudMedia(data, reply);
 
@@ -122,6 +120,17 @@ HWTEST_F(CloudMediaChangeTest, StartDownloadCloudMedia_Test_002, TestSize.Level0
     EXPECT_EQ(true, ret);
 }
 
+HWTEST_F(CloudMediaChangeTest, StartDownloadCloudMedia_Test_003, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->StartDownloadCloudMedia(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_LT(respVo.GetErrCode(), 0);
+}
+
 HWTEST_F(CloudMediaChangeTest, PauseDownloadCloudMedia_Test_001, TestSize.Level0)
 {
     MEDIA_INFO_LOG("Start PauseDownloadCloudMedia_Test_001");
@@ -188,4 +197,14 @@ HWTEST_F(CloudMediaChangeTest, RetainCloudMediaAsset_Test_002, TestSize.Level0)
     EXPECT_EQ(true, ret);
 }
 
+HWTEST_F(CloudMediaChangeTest, RetainCloudMediaAsset_Test_003, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->RetainCloudMediaAsset(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_LT(respVo.GetErrCode(), 0);
+}
 }  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/create_asset_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/create_asset_test.cpp
index e90de9341f..0f2231fe28 100644
--- a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/create_asset_test.cpp
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/create_asset_test.cpp
@@ -20,11 +20,7 @@
 #include <string>
 #include <vector>
 
-#define private public
-#define protected public
 #include "media_assets_controller_service.h"
-#undef private
-#undef protected
 
 #include "create_asset_vo.h"
 #include "user_define_ipc_client.h"
@@ -38,7 +34,12 @@ using namespace testing::ext;
 using namespace OHOS::NativeRdb;
 
 static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
-static constexpr int32_t SLEEP_SECONDS = 1;
+static constexpr int32_t SLEEP_SECONDS = 3;
+
+static std::string Quote(const std::string &str)
+{
+    return "'" + str + "'";
+}
 
 static int32_t ClearTable(const string &table)
 {
@@ -53,6 +54,86 @@ static int32_t ClearTable(const string &table)
     return E_OK;
 }
 
+static bool CheckAsset(int32_t assetId)
+{
+    int32_t count = 0;
+    vector<string> columns = { PhotoColumn::MEDIA_ID, PhotoColumn::PHOTO_OWNER_ALBUM_ID };
+    NativeRdb::RdbPredicates rdbPredicate(PhotoColumn::PHOTOS_TABLE);
+    rdbPredicate.EqualTo(PhotoColumn::MEDIA_ID, assetId);
+    auto resultSet = MediaLibraryRdbStore::Query(rdbPredicate, columns);
+    if (resultSet != nullptr) {
+        resultSet->GetRowCount(count);
+        while (resultSet->GoToNextRow() == NativeRdb::E_OK) {
+            int32_t albumId = MediaLibraryRdbStore::GetInt(resultSet, PhotoColumn::PHOTO_OWNER_ALBUM_ID);
+            MEDIA_INFO_LOG("assetId:%{public}d albumId:%{public}d", assetId, albumId);
+        }
+        resultSet->Close();
+    }
+    return count == 1;
+}
+
+static int32_t CreateAlbum(int32_t albumType, int32_t albumSubType, const std::string &albumName)
+{
+    int64_t now = MediaFileUtils::UTCTimeMilliSeconds();
+    std::vector<std::pair<std::string, std::string>> items = {
+        {PhotoAlbumColumns::ALBUM_NAME, Quote(albumName)},
+        {PhotoAlbumColumns::ALBUM_TYPE, to_string(albumType)},
+        {PhotoAlbumColumns::ALBUM_SUBTYPE, to_string(albumSubType)},
+        {PhotoAlbumColumns::ALBUM_DATE_MODIFIED, to_string(now)},
+        {PhotoAlbumColumns::ALBUM_DATE_ADDED, to_string(now)},
+        {PhotoAlbumColumns::ALBUM_LPATH, Quote("/Pictures/" + albumName)},
+        {PhotoAlbumColumns::CONTAINS_HIDDEN, "0"},
+        {PhotoAlbumColumns::ALBUM_IS_LOCAL, "1"},
+        {PhotoAlbumColumns::ALBUM_PRIORITY, "1"},
+    };
+
+    std::string values;
+    std::string columns;
+    for (const auto &item : items) {
+        if (!columns.empty()) {
+            columns.append(",");
+            values.append(",");
+        }
+        columns.append(item.first);
+        values.append(item.second);
+    }
+    std::string sql = "INSERT INTO " + PhotoAlbumColumns::TABLE + "(" + columns + ") VALUES (" + values + ")";
+    return g_rdbStore->ExecuteSql(sql);
+}
+
+static int32_t GetAlbumId(const std::string &albumName)
+{
+    std::vector<std::string> columns = {
+        PhotoAlbumColumns::ALBUM_ID, PhotoAlbumColumns::ALBUM_NAME,
+        PhotoAlbumColumns::ALBUM_TYPE, PhotoAlbumColumns::ALBUM_SUBTYPE
+    };
+    NativeRdb::RdbPredicates rdbPredicate(PhotoAlbumColumns::TABLE);
+    auto resultSet = MediaLibraryRdbStore::Query(rdbPredicate, columns);
+    if (resultSet == nullptr) {
+        MEDIA_ERR_LOG("Query failed, albumName:%{public}s", albumName.c_str());
+        return 0;
+    }
+
+    int32_t retId = 0;
+    while (resultSet->GoToNextRow() == NativeRdb::E_OK) {
+        int32_t albumId = MediaLibraryRdbStore::GetInt(resultSet, PhotoAlbumColumns::ALBUM_ID);
+        string name = MediaLibraryRdbStore::GetString(resultSet, PhotoAlbumColumns::ALBUM_NAME);
+        int32_t albumType = MediaLibraryRdbStore::GetInt(resultSet, PhotoAlbumColumns::ALBUM_TYPE);
+        int32_t albumSubType = MediaLibraryRdbStore::GetInt(resultSet, PhotoAlbumColumns::ALBUM_SUBTYPE);
+        MEDIA_INFO_LOG("albumId:%{public}d, albumName:%{public}s, albumType:%{public}d, albumSubType:%{public}d",
+            albumId, name.c_str(), albumType, albumSubType);
+        if (name == albumName) {
+            retId = albumId;
+        }
+    }
+    resultSet->Close();
+    if (retId == 0) {
+        MEDIA_ERR_LOG("Not Exists, albumName:%{public}s", albumName.c_str());
+        return 0;
+    }
+    return retId;
+}
+
 void CreateAssetTest::SetUpTestCase(void)
 {
     MediaLibraryUnitTestUtils::Init();
@@ -61,12 +142,15 @@ void CreateAssetTest::SetUpTestCase(void)
         MEDIA_ERR_LOG("Start MediaLibraryPhotoOperationsTest failed, can not get g_rdbStore");
         exit(1);
     }
+    ClearTable(PhotoAlbumColumns::TABLE);
     ClearTable(PhotoColumn::PHOTOS_TABLE);
+    CreateAlbum(PhotoAlbumType::USER, PhotoAlbumSubType::USER_GENERIC, "TestUserAlbum");
     MEDIA_INFO_LOG("SetUpTestCase");
 }
 
 void CreateAssetTest::TearDownTestCase(void)
 {
+    ClearTable(PhotoAlbumColumns::TABLE);
     ClearTable(PhotoColumn::PHOTOS_TABLE);
     MEDIA_INFO_LOG("TearDownTestCase");
     std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
@@ -74,6 +158,7 @@ void CreateAssetTest::TearDownTestCase(void)
 
 void CreateAssetTest::SetUp()
 {
+    GetAlbumId("TestUserAlbum");
     MEDIA_INFO_LOG("SetUp");
 }
 
@@ -82,53 +167,6 @@ void CreateAssetTest::TearDown(void)
     MEDIA_INFO_LOG("TearDown");
 }
 
-static bool CheckAsset(int32_t assetId)
-{
-    int32_t count = 0;
-    NativeRdb::RdbPredicates rdbPredicate(PhotoColumn::PHOTOS_TABLE);
-    rdbPredicate.EqualTo(PhotoColumn::MEDIA_ID, assetId);
-    vector<string> columns = { PhotoColumn::MEDIA_ID };
-    auto resultSet = MediaLibraryRdbStore::Query(rdbPredicate, columns);
-    if (resultSet != nullptr) {
-        resultSet->GetRowCount(count);
-        resultSet->Close();
-    }
-    return count == 1;
-}
-
-static bool CheckAlbum(int32_t albumId)
-{
-    int32_t count = 0;
-    NativeRdb::RdbPredicates rdbPredicate(PhotoAlbumColumns::TABLE);
-    rdbPredicate.EqualTo(PhotoAlbumColumns::ALBUM_ID, albumId);
-    vector<string> columns = { PhotoAlbumColumns::ALBUM_ID };
-    auto resultSet = MediaLibraryRdbStore::Query(rdbPredicate, columns);
-    if (resultSet != nullptr) {
-        resultSet->GetRowCount(count);
-        resultSet->Close();
-    }
-    return count == 1;
-}
-
-static int32_t GetAlbumId(const std::string &albumName)
-{
-    NativeRdb::RdbPredicates rdbPredicate(PhotoAlbumColumns::TABLE);
-    rdbPredicate.EqualTo(PhotoAlbumColumns::ALBUM_NAME, albumName);
-    vector<string> columns = { PhotoAlbumColumns::ALBUM_ID };
-    auto resultSet = MediaLibraryRdbStore::Query(rdbPredicate, columns);
-    if (resultSet == nullptr) {
-        MEDIA_ERR_LOG("Query failed, albumName:%{public}s", albumName.c_str());
-        return 0;
-    }
-    int32_t albumId = 0;
-    while (resultSet->GoToNextRow() == NativeRdb::E_OK) {
-        albumId = MediaLibraryRdbStore::GetInt(resultSet, PhotoAlbumColumns::ALBUM_ID);
-        MEDIA_INFO_LOG("resultSet: albumId:%{public}d, albumName:%{public}s", albumId, albumName.c_str());
-    }
-    resultSet->Close();
-    return albumId;
-}
-
 using ServiceCall = std::function<void(MessageParcel &data, MessageParcel &reply)>;
 
 int32_t ServiceCreateAsset(CreateAssetReqBody &reqBody, ServiceCall call)
@@ -405,7 +443,7 @@ HWTEST_F(CreateAssetTest, CreateAssetForAppWithAlbum_Test_001, TestSize.Level0)
 HWTEST_F(CreateAssetTest, CreateAssetForAppWithAlbum_Test_002, TestSize.Level0)
 {
     MEDIA_INFO_LOG("Start CreateAssetForAppWithAlbum_Test_002");
-    int32_t albumId = GetAlbumId("media_assets_controler_service_test");
+    int32_t albumId = GetAlbumId("TestUserAlbum");
     ASSERT_GT(albumId, 0);
 
     int32_t fileId = CreateAssetForAppWithAlbum(0, albumId, "jpg");
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_asset_analysis_data_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_asset_analysis_data_test.cpp
new file mode 100644
index 0000000000..177af995f1
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_asset_analysis_data_test.cpp
@@ -0,0 +1,284 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaAssetsControllerServiceTest"
+
+#include "get_asset_analysis_data_test.h"
+
+#include <memory>
+#include <string>
+
+#include "media_assets_controller_service.h"
+
+#include "get_asset_analysis_data_vo.h"
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "medialibrary_asset_operations.h"
+#include "media_file_utils.h"
+#include "mimetype_utils.h"
+#include "parameter_utils.h"
+
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 3;
+
+static std::string Quote(const std::string &str)
+{
+    return "'" + str + "'";
+}
+
+static void ClearTable(const string &table)
+{
+    int32_t rows = 0;
+    RdbPredicates predicates(table);
+    int32_t errCode = g_rdbStore->Delete(rows, predicates);
+    CHECK_AND_RETURN_LOG(errCode == E_OK, "g_rdbStore->Delete errCode:%{public}d", errCode);
+}
+
+static void ClearAssetsFile()
+{
+    std::string assetPath;
+    vector<string> columns = {MediaColumn::MEDIA_FILE_PATH};
+    NativeRdb::RdbPredicates rdbPredicate(PhotoColumn::PHOTOS_TABLE);
+    auto resultSet = MediaLibraryRdbStore::Query(rdbPredicate, columns);
+    CHECK_AND_RETURN_LOG(resultSet != nullptr, "MediaLibraryRdbStore::Query failed");
+    while (resultSet->GoToNextRow() == NativeRdb::E_OK) {
+        assetPath = MediaLibraryRdbStore::GetString(resultSet, columns.front());
+        MEDIA_INFO_LOG("DeleteFile assetPath:%{public}s", assetPath.c_str());
+        MediaFileUtils::DeleteFile(assetPath);
+    }
+    resultSet->Close();
+}
+
+static void InsertAsset(const std::string &displayName, int32_t pending = 0)
+{
+    MEDIA_INFO_LOG("displayName:%{public}s pending:%{public}d", displayName.c_str(), pending);
+
+    std::string ext;
+    std::string title;
+    int32_t errCode = ParameterUtils::GetTitleAndExtension(displayName, title, ext);
+    CHECK_AND_RETURN_LOG(errCode == E_OK, "GetTitleAndExtension errCode:%{public}d", errCode);
+
+    std::string assetPath;
+    int64_t now = MediaFileUtils::UTCTimeMilliSeconds();
+    string mimeType = MimeTypeUtils::GetMimeTypeFromExtension(ext);
+    int32_t mediaType = MimeTypeUtils::GetMediaTypeFromMimeType(mimeType);
+    errCode = MediaLibraryAssetOperations::CreateAssetPathById(static_cast<int32_t>(now), mediaType, ext, assetPath);
+    CHECK_AND_RETURN_LOG(errCode == E_OK, "CreateAssetPathById errCode:%{public}d", errCode);
+
+    std::vector<std::pair<std::string, std::string>> items = {
+        {MediaColumn::MEDIA_FILE_PATH, Quote(assetPath)}, {MediaColumn::MEDIA_SIZE, "175258"},
+        {MediaColumn::MEDIA_TITLE, Quote(title)}, {MediaColumn::MEDIA_NAME, Quote(displayName)},
+        {MediaColumn::MEDIA_TYPE, to_string(mediaType)},
+        {MediaColumn::MEDIA_OWNER_PACKAGE, Quote("com.ohos.camera")}, {MediaColumn::MEDIA_PACKAGE_NAME, Quote("相机")},
+        {MediaColumn::MEDIA_DATE_ADDED, to_string(now)}, {MediaColumn::MEDIA_DATE_MODIFIED, "0"},
+        {MediaColumn::MEDIA_DATE_TAKEN, to_string(now)}, {MediaColumn::MEDIA_DURATION, "0"},
+        {MediaColumn::MEDIA_TIME_PENDING, to_string(pending)},
+        {PhotoColumn::PHOTO_HEIGHT, "1280"}, {PhotoColumn::PHOTO_WIDTH, "960"},
+        {PhotoColumn::PHOTO_SHOOTING_MODE, "'1'"},
+    };
+
+    std::string values;
+    std::string columns;
+    for (const auto &item : items) {
+        if (!columns.empty()) {
+            columns.append(",");
+            values.append(",");
+        }
+        columns.append(item.first);
+        values.append(item.second);
+    }
+    std::string sql = "INSERT INTO " + PhotoColumn::PHOTOS_TABLE + "(" + columns + ") VALUES (" + values + ")";
+    errCode = g_rdbStore->ExecuteSql(sql);
+    CHECK_AND_RETURN_LOG(errCode == E_OK, "ExecuteSql errCode:%{public}d", errCode);
+
+    MEDIA_INFO_LOG("CreateFile assetPath:%{public}s", assetPath.c_str());
+    std::this_thread::sleep_for(std::chrono::seconds(10));
+    MediaFileUtils::CreateFile(assetPath);
+}
+
+static int32_t GetAssetId(const std::string &displayName)
+{
+    NativeRdb::RdbPredicates rdbPredicate(PhotoColumn::PHOTOS_TABLE);
+    rdbPredicate.EqualTo(MediaColumn::MEDIA_NAME, displayName);
+    vector<string> columns = { MediaColumn::MEDIA_ID };
+    auto resultSet = MediaLibraryRdbStore::Query(rdbPredicate, columns);
+    if (resultSet == nullptr) {
+        MEDIA_ERR_LOG("Query failed, displayName:%{public}s", displayName.c_str());
+        return 0;
+    }
+    int32_t assetId = 0;
+    while (resultSet->GoToNextRow() == NativeRdb::E_OK) {
+        assetId = MediaLibraryRdbStore::GetInt(resultSet, MediaColumn::MEDIA_ID);
+        MEDIA_INFO_LOG("resultSet: assetId:%{public}d", assetId);
+    }
+    resultSet->Close();
+    return assetId;
+}
+
+static void ShowResultSet(std::shared_ptr<DataShare::DataShareResultSet> resultSet)
+{
+    std::vector<std::string> columns;
+    resultSet->GetAllColumnNames(columns);
+    while (resultSet->GoToNextRow() == NativeRdb::E_OK) {
+        std::string tag;
+        std::string rowData;
+        for (size_t i = 0; i < columns.size(); i++) {
+            std::string value;
+            resultSet->GetString(i, value);
+            rowData += tag + columns[i] + ":'" + value + "'";
+            tag = ",";
+        }
+        MEDIA_INFO_LOG("rowData:[%{public}s]", rowData.c_str());
+    }
+}
+
+void GetAssetAnalysisDataTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start MediaLibraryPhotoOperationsTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+
+    ClearAssetsFile();
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    InsertAsset("GetAssetAnalysisData_Test.jpg");
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+
+void GetAssetAnalysisDataTest::TearDownTestCase(void)
+{
+    ClearAssetsFile();
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+
+void GetAssetAnalysisDataTest::SetUp()
+{
+    MEDIA_INFO_LOG("SetUp");
+}
+
+void GetAssetAnalysisDataTest::TearDown(void)
+{
+    MEDIA_INFO_LOG("TearDown");
+}
+
+int32_t GetAssetAnalysisData(int32_t fileId, int32_t analysisType, bool analysisTotal)
+{
+    MessageParcel data;
+    GetAssetAnalysisDataReqBody reqBody;
+    reqBody.fileId = fileId;
+    reqBody.language = "zh-Hans";
+    reqBody.analysisType = analysisType;
+    reqBody.analysisTotal = analysisTotal;
+    if (reqBody.Marshalling(data) != true) {
+        MEDIA_ERR_LOG("reqBody.Marshalling failed");
+        return -1;
+    }
+
+    MessageParcel reply;
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->GetAssetAnalysisData(data, reply);
+
+    IPC::MediaRespVo<GetAssetAnalysisDataRspBody> respVo;
+    if (respVo.Unmarshalling(reply) != true) {
+        MEDIA_ERR_LOG("respVo.Unmarshalling failed");
+        return -1;
+    }
+
+    int32_t errCode = respVo.GetErrCode();
+    if (errCode != 0) {
+        MEDIA_ERR_LOG("respVo.GetErrCode: %{public}d", errCode);
+        return errCode;
+    }
+
+    auto resultSet = respVo.GetBody().resultSet;
+    if (resultSet == nullptr) {
+        MEDIA_ERR_LOG("resultSet nullptr");
+        return -1;
+    }
+
+    ShowResultSet(resultSet);
+
+    int32_t rowCount = 0;
+    resultSet->GetRowCount(rowCount);
+    resultSet->Close();
+    return rowCount;
+}
+
+HWTEST_F(GetAssetAnalysisDataTest, GetAssetAnalysisData_Test_001, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start GetAssetAnalysisData_Test_001");
+    int32_t assetId = GetAssetId("GetAssetAnalysisData_Test.jpg");
+    ASSERT_GT(assetId, 0);
+
+    ASSERT_LT(GetAssetAnalysisData(assetId, ANALYSIS_INVALID, 0), 0);
+}
+
+HWTEST_F(GetAssetAnalysisDataTest, GetAssetAnalysisData_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start GetAssetAnalysisData_Test_002");
+    int32_t assetId = GetAssetId("GetAssetAnalysisData_Test.jpg");
+    ASSERT_GT(assetId, 0);
+
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_AESTHETICS_SCORE, 0), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_LABEL, 0), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_OCR, 0), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_FACE, 0), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_OBJECT, 0), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_RECOMMENDATION, 0), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_SEGMENTATION, 0), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_COMPOSITION, 0), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_SALIENCY, 0), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_DETAIL_ADDRESS, 0), 1);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_HUMAN_FACE_TAG, 0), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_HEAD_POSITION, 0), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_BONE_POSE, 0), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_VIDEO_LABEL, 0), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_MULTI_CROP, 0), 0);
+}
+
+HWTEST_F(GetAssetAnalysisDataTest, GetAssetAnalysisData_Test_003, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start GetAssetAnalysisData_Test_003");
+    int32_t assetId = GetAssetId("GetAssetAnalysisData_Test.jpg");
+    ASSERT_GT(assetId, 0);
+
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_AESTHETICS_SCORE, 1), 1);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_LABEL, 1), 1);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_OCR, 1), 1);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_FACE, 1), 1);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_OBJECT, 1), 1);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_RECOMMENDATION, 1), 1);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_SEGMENTATION, 1), 1);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_COMPOSITION, 1), 1);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_SALIENCY, 1), 1);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_DETAIL_ADDRESS, 1), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_HUMAN_FACE_TAG, 1), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_HEAD_POSITION, 1), 1);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_BONE_POSE, 1), 1);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_VIDEO_LABEL, 1), 0);
+    ASSERT_EQ(GetAssetAnalysisData(assetId, ANALYSIS_MULTI_CROP, 1), 1);
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_assets_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_assets_test.cpp
new file mode 100755
index 0000000000..d3030d9290
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_assets_test.cpp
@@ -0,0 +1,357 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaAssetsControllerServiceTest"
+
+#include "get_assets_test.h"
+
+#include <string>
+#include <vector>
+
+#define private public
+#define protected public
+#include "media_assets_controller_service.h"
+#undef private
+#undef protected
+
+#include "get_assets_vo.h"
+
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "result_set_utils.h"
+#include "media_file_uri.h"
+
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+using OHOS::DataShare::DataSharePredicates;
+
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 1;
+static const string SQL_INSERT_PHOTO =
+    "INSERT INTO " + PhotoColumn::PHOTOS_TABLE + "(" + MediaColumn::MEDIA_FILE_PATH + ", " + MediaColumn::MEDIA_SIZE +
+    ", " + MediaColumn::MEDIA_TITLE + ", " + MediaColumn::MEDIA_NAME + ", " + MediaColumn::MEDIA_TYPE + ", " +
+    MediaColumn::MEDIA_OWNER_PACKAGE + ", " + MediaColumn::MEDIA_PACKAGE_NAME + ", " + MediaColumn::MEDIA_DATE_ADDED +
+    ", " + MediaColumn::MEDIA_DATE_MODIFIED + ", " + MediaColumn::MEDIA_DATE_TAKEN + ", " +
+    MediaColumn::MEDIA_DURATION + ", " + MediaColumn::MEDIA_IS_FAV + ", " + MediaColumn::MEDIA_DATE_TRASHED + ", " +
+    MediaColumn::MEDIA_HIDDEN + ", " + PhotoColumn::PHOTO_HEIGHT + ", " + PhotoColumn::PHOTO_WIDTH + ", " +
+    PhotoColumn::PHOTO_EDIT_TIME + ", " + PhotoColumn::PHOTO_SHOOTING_MODE + ", " + PhotoColumn::PHOTO_BURST_KEY + ")";
+static const string VALUES_END = ") ";
+
+static int32_t ClearTable(const string &table)
+{
+    RdbPredicates predicates(table);
+
+    int32_t rows = 0;
+    int32_t err = g_rdbStore->Delete(rows, predicates);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to clear photos table, err: %{public}d", err);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+
+void GetAssetsTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start MediaLibraryPhotoOperationsTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+
+void GetAssetsTest::TearDownTestCase(void)
+{
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+
+void GetAssetsTest::SetUp()
+{
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+    MEDIA_INFO_LOG("SetUp");
+}
+
+void GetAssetsTest::TearDown(void)
+{
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+    MEDIA_INFO_LOG("TearDown");
+}
+
+static int32_t GetBurstAssets(string burstKey, std::shared_ptr<DataShare::DataShareResultSet> &resultSet)
+{
+    GetAssetsReqBody reqBody;
+    reqBody.burstKey = burstKey;
+
+    MessageParcel data;
+    if (reqBody.Marshalling(data) != true) {
+        MEDIA_ERR_LOG("reqBody.Marshalling failed");
+        return -1;
+    }
+
+    MessageParcel reply;
+    OHOS::Media::IPC::IPCContext context(MessageOption(), 0);
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->GetBurstAssets(data, reply, context);
+
+    IPC::MediaRespVo<GetAssetsRespBody> respVo;
+    if (respVo.Unmarshalling(reply) != true) {
+        MEDIA_ERR_LOG("respVo.Unmarshalling failed");
+        return -1;
+    }
+    int32_t errCode = respVo.GetErrCode();
+    if (errCode != 0) {
+        MEDIA_ERR_LOG("respVo.GetErrCode: %{public}d", errCode);
+        return errCode;
+    }
+    resultSet = respVo.GetBody().resultSet;
+    return 0;
+}
+
+static int32_t GetAssets(std::shared_ptr<DataShare::DataShareResultSet> &resultSet)
+{
+    GetAssetsReqBody reqBody;
+    MessageParcel data;
+    if (reqBody.Marshalling(data) != true) {
+        MEDIA_ERR_LOG("reqBody.Marshalling failed");
+        return -1;
+    }
+
+    MessageParcel reply;
+    OHOS::Media::IPC::IPCContext context(MessageOption(), 0);
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->GetAssets(data, reply, context);
+
+    IPC::MediaRespVo<GetAssetsRespBody> respVo;
+    if (respVo.Unmarshalling(reply) != true) {
+        MEDIA_ERR_LOG("respVo.Unmarshalling failed");
+        return -1;
+    }
+    int32_t errCode = respVo.GetErrCode();
+    if (errCode != 0) {
+        MEDIA_ERR_LOG("respVo.GetErrCode: %{public}d", errCode);
+        return errCode;
+    }
+    resultSet = respVo.GetBody().resultSet;
+    return 0;
+}
+
+using ServiceMethod = std::function<void(MessageParcel &, MessageParcel &)>;
+static int32_t GetDupAssets(std::shared_ptr<DataShare::DataShareResultSet> &resultSet, ServiceMethod serviceMethod)
+{
+    GetAssetsReqBody reqBody;
+    MessageParcel data;
+    if (reqBody.Marshalling(data) != true) {
+        MEDIA_ERR_LOG("reqBody.Marshalling failed");
+        return -1;
+    }
+
+    MessageParcel reply;
+    serviceMethod(data, reply);
+
+    IPC::MediaRespVo<GetAssetsRespBody> respVo;
+    if (respVo.Unmarshalling(reply) != true) {
+        MEDIA_ERR_LOG("respVo.Unmarshalling failed");
+        return -1;
+    }
+    int32_t errCode = respVo.GetErrCode();
+    if (errCode != 0) {
+        MEDIA_ERR_LOG("respVo.GetErrCode: %{public}d", errCode);
+        return errCode;
+    }
+    resultSet = respVo.GetBody().resultSet;
+    return 0;
+}
+
+static void InsertAsset(string displayName, string title, string burstKey)
+{
+    // data, size,
+    // title, display_name, media_type,
+    // owner_package, package_name, date_added, date_modified, date_taken, duration, is_favorite, date_trashed, hidden
+    // height, width, edit_time, shooting_mode
+    std::string insertSql = SQL_INSERT_PHOTO + " VALUES (" + "'/storage/cloud/files/Photo/16/" + displayName +
+                            ".jpg', 175258, '" + title + "', '" + displayName + ".jpg', 1, " +
+                            "'com.ohos.camera', '相机', 1501924205218, 0, 1501924205, 0, 0, 0, 0, " +
+                            "1280, 960, 0, '1', '" + burstKey + "'" + VALUES_END;
+    int32_t ret = g_rdbStore->ExecuteSql(insertSql);
+    if (ret != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("Execute sql %{public}s failed", insertSql.c_str());
+    }
+}
+
+static int32_t QueryPhotoIdByDisplayName(const string &displayName)
+{
+    vector<string> columns;
+    RdbPredicates rdbPredicates(PhotoColumn::PHOTOS_TABLE);
+    rdbPredicates.EqualTo(MediaColumn::MEDIA_NAME, displayName);
+    auto resultSet = MediaLibraryRdbStore::Query(rdbPredicates, columns);
+    if (resultSet == nullptr || resultSet->GoToFirstRow() != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("Can not get fileId");
+        return -1;
+    }
+    int32_t fileId = GetInt32Val(MediaColumn::MEDIA_ID, resultSet);
+    return fileId;
+}
+
+HWTEST_F(GetAssetsTest, GetAssets_Test_001, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("GetAssets_Test_001 for GetBurstAssets Begin");
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+    int32_t result = GetBurstAssets("invalid", resultSet);
+    ASSERT_EQ(result, 0);
+    ASSERT_NE(resultSet, nullptr);
+    ASSERT_NE(resultSet->GoToFirstRow(), E_OK);
+}
+
+HWTEST_F(GetAssetsTest, GetAssets_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("GetAssets_Test_002 for GetBurstAssets Begin");
+    string pic1 = "cam_pic1";
+    string burstKey = "burst_test";
+    InsertAsset(pic1, pic1, burstKey);
+    int32_t fileId = QueryPhotoIdByDisplayName(pic1 + ".jpg");
+    ASSERT_GT(fileId, 0);
+
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+    int32_t result = GetBurstAssets(burstKey, resultSet);
+    ASSERT_EQ(result, 0);
+
+    ASSERT_NE(resultSet, nullptr);
+    ASSERT_EQ(resultSet->GoToFirstRow(), E_OK);
+    ASSERT_EQ(GetInt32Val(MediaColumn::MEDIA_ID, resultSet), fileId);
+}
+
+HWTEST_F(GetAssetsTest, GetAssets_Test_003, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("GetAssets_Test_003 for public Begin");
+    auto service = make_shared<MediaAssetsControllerService>();
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+    int32_t result = GetAssets(resultSet);
+    ASSERT_EQ(result, 0);
+    ASSERT_NE(resultSet, nullptr);
+    ASSERT_NE(resultSet->GoToFirstRow(), E_OK);
+}
+
+HWTEST_F(GetAssetsTest, GetAssets_Test_004, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("GetAssets_Test_004 for public Begin");
+    string pic1 = "cam_pic1";
+    InsertAsset(pic1, pic1, "");
+    int32_t fileId = QueryPhotoIdByDisplayName(pic1 + ".jpg");
+    ASSERT_GT(fileId, 0);
+
+    auto service = make_shared<MediaAssetsControllerService>();
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+    int32_t result = GetAssets(resultSet);
+    ASSERT_EQ(result, 0);
+
+    ASSERT_NE(resultSet, nullptr);
+    ASSERT_EQ(resultSet->GoToFirstRow(), E_OK);
+    ASSERT_EQ(GetInt32Val(MediaColumn::MEDIA_ID, resultSet), fileId);
+}
+
+HWTEST_F(GetAssetsTest, GetAssets_Test_005, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("GetAssets_Test_005 for system duplicate Begin");
+    auto service = make_shared<MediaAssetsControllerService>();
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+    ServiceMethod serviceMethod = [service](MessageParcel &data, MessageParcel &reply) {
+        service->GetAllDuplicateAssets(data, reply);
+    };
+    int32_t result = GetDupAssets(resultSet, serviceMethod);
+    ASSERT_EQ(result, 0);
+    ASSERT_NE(resultSet, nullptr);
+    ASSERT_NE(resultSet->GoToFirstRow(), E_OK);
+}
+
+HWTEST_F(GetAssetsTest, GetAssets_Test_006, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("GetAssets_Test_006 for system duplicate Begin");
+    string pic1 = "cam_pic1";
+    string title = "same";
+    InsertAsset(pic1, title, "");
+    int32_t fileId1 = QueryPhotoIdByDisplayName(pic1 + ".jpg");
+    ASSERT_GT(fileId1, 0);
+
+    string pic2 = "cam_pic2";
+    InsertAsset(pic2, title, "");
+    int32_t fileId2 = QueryPhotoIdByDisplayName(pic2 + ".jpg");
+    ASSERT_GT(fileId2, 0);
+
+    auto service = make_shared<MediaAssetsControllerService>();
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+    ServiceMethod serviceMethod = [service](MessageParcel &data, MessageParcel &reply) {
+        service->GetAllDuplicateAssets(data, reply);
+    };
+    int32_t result = GetDupAssets(resultSet, serviceMethod);
+    ASSERT_EQ(result, 0);
+
+    ASSERT_NE(resultSet, nullptr);
+    ASSERT_EQ(resultSet->GoToFirstRow(), E_OK);
+    int32_t mediaId = GetInt32Val(MediaColumn::MEDIA_ID, resultSet);
+    ASSERT_TRUE(mediaId == fileId1 || mediaId == fileId2);
+}
+
+HWTEST_F(GetAssetsTest, GetAssets_Test_007, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("GetAssets_Test_007 for system duplicateToDelete Begin");
+    auto service = make_shared<MediaAssetsControllerService>();
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+    ServiceMethod serviceMethod = [service](MessageParcel &data, MessageParcel &reply) {
+        service->GetDuplicateAssetsToDelete(data, reply);
+    };
+    int32_t result = GetDupAssets(resultSet, serviceMethod);
+    ASSERT_EQ(result, 0);
+    ASSERT_NE(resultSet, nullptr);
+    ASSERT_NE(resultSet->GoToFirstRow(), E_OK);
+}
+
+HWTEST_F(GetAssetsTest, GetAssets_Test_008, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("GetAssets_Test_008 for system duplicateToDelete Begin");
+    string pic1 = "cam_pic1";
+    string title = "same";
+    InsertAsset(pic1, title, "");
+    int32_t fileId1 = QueryPhotoIdByDisplayName(pic1 + ".jpg");
+    ASSERT_GT(fileId1, 0);
+
+    string pic2 = "cam_pic2";
+    InsertAsset(pic2, title, "");
+    int32_t fileId2 = QueryPhotoIdByDisplayName(pic2 + ".jpg");
+    ASSERT_GT(fileId2, 0);
+
+    auto service = make_shared<MediaAssetsControllerService>();
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+    ServiceMethod serviceMethod = [service](MessageParcel &data, MessageParcel &reply) {
+        service->GetDuplicateAssetsToDelete(data, reply);
+    };
+    int32_t result = GetDupAssets(resultSet, serviceMethod);
+    ASSERT_EQ(result, 0);
+
+    ASSERT_NE(resultSet, nullptr);
+    ASSERT_EQ(resultSet->GoToFirstRow(), E_OK);
+    int32_t mediaId = GetInt32Val(MediaColumn::MEDIA_ID, resultSet);
+    ASSERT_TRUE(mediaId == fileId1 || mediaId == fileId2);
+}
+
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_cloud_enhancement_pair_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_cloud_enhancement_pair_test.cpp
new file mode 100755
index 0000000000..ed1e87d9ba
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_cloud_enhancement_pair_test.cpp
@@ -0,0 +1,213 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaAssetsControllerServiceTest"
+
+#include "get_cloud_enhancement_pair_test.h"
+
+#include <string>
+#include <vector>
+
+#define private public
+#define protected public
+#include "media_assets_controller_service.h"
+#undef private
+#undef protected
+
+#include "get_cloud_enhancement_pair_vo.h"
+
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "result_set_utils.h"
+#include "media_file_uri.h"
+
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+using OHOS::DataShare::DataSharePredicates;
+
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 1;
+static const string SQL_INSERT_PHOTO =
+    "INSERT INTO " + PhotoColumn::PHOTOS_TABLE + "(" + MediaColumn::MEDIA_FILE_PATH + ", " + MediaColumn::MEDIA_SIZE +
+    ", " + MediaColumn::MEDIA_TITLE + ", " + MediaColumn::MEDIA_NAME + ", " + MediaColumn::MEDIA_TYPE + ", " +
+    MediaColumn::MEDIA_OWNER_PACKAGE + ", " + MediaColumn::MEDIA_PACKAGE_NAME + ", " + MediaColumn::MEDIA_DATE_ADDED +
+    ", " + MediaColumn::MEDIA_DATE_MODIFIED + ", " + MediaColumn::MEDIA_DATE_TAKEN + ", " +
+    MediaColumn::MEDIA_DURATION + ", " + MediaColumn::MEDIA_IS_FAV + ", " + MediaColumn::MEDIA_DATE_TRASHED + ", " +
+    MediaColumn::MEDIA_HIDDEN + ", " + PhotoColumn::PHOTO_HEIGHT + ", " + PhotoColumn::PHOTO_WIDTH + ", " +
+    PhotoColumn::PHOTO_EDIT_TIME + ", " + PhotoColumn::PHOTO_SHOOTING_MODE + ")";
+static const string VALUES_END = ") ";
+
+static int32_t ClearTable(const string &table)
+{
+    RdbPredicates predicates(table);
+
+    int32_t rows = 0;
+    int32_t err = g_rdbStore->Delete(rows, predicates);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to clear photos table, err: %{public}d", err);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+
+void GetCloudEnhancementPairTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start MediaLibraryPhotoOperationsTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+
+void GetCloudEnhancementPairTest::TearDownTestCase(void)
+{
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+
+void GetCloudEnhancementPairTest::SetUp()
+{
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+    MEDIA_INFO_LOG("SetUp");
+}
+
+void GetCloudEnhancementPairTest::TearDown(void)
+{
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+    MEDIA_INFO_LOG("TearDown");
+}
+
+static int32_t GetCloudEnhancementPair(string &photoUri, std::shared_ptr<DataShare::DataShareResultSet> &resultSet)
+{
+    GetCloudEnhancementPairReqBody reqBody;
+    reqBody.photoUri = photoUri;
+
+    MessageParcel data;
+    if (reqBody.Marshalling(data) != true) {
+        MEDIA_ERR_LOG("reqBody.Marshalling failed");
+        return -1;
+    }
+
+    MessageParcel reply;
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->GetCloudEnhancementPair(data, reply);
+
+    IPC::MediaRespVo<GetCloudEnhancementPairRespBody> respVo;
+    if (respVo.Unmarshalling(reply) != true) {
+        MEDIA_ERR_LOG("respVo.Unmarshalling failed");
+        return -1;
+    }
+    int32_t errCode = respVo.GetErrCode();
+    if (errCode != 0) {
+        MEDIA_ERR_LOG("respVo.GetErrCode: %{public}d", errCode);
+        return errCode;
+    }
+    resultSet = respVo.GetBody().resultSet;
+    return 0;
+}
+
+static void InsertAsset(string displayName)
+{
+    // data, size,
+    // title, display_name, media_type,
+    // owner_package, package_name, date_added, date_modified, date_taken, duration, is_favorite, date_trashed, hidden
+    // height, width, edit_time, shooting_mode
+    std::string insertSql = SQL_INSERT_PHOTO + " VALUES (" + "'/storage/cloud/files/Photo/16/" + displayName +
+                            ".jpg', 175258, '" + displayName + "', '" + displayName + ".jpg', 1, " +
+                            "'com.ohos.camera', '相机', 1501924205218, 0, 1501924205, 0, 0, 0, 0, " +
+                            "1280, 960, 0, '1'" + VALUES_END;
+    int32_t ret = g_rdbStore->ExecuteSql(insertSql);
+    if (ret != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("Execute sql %{public}s failed", insertSql.c_str());
+    }
+}
+
+static void UpdateAssetAssociateFileId(int32_t fileId, const std::string &displayName)
+{
+    std::string updateSql = "UPDATE " + PhotoColumn::PHOTOS_TABLE + " SET " + PhotoColumn::PHOTO_ASSOCIATE_FILE_ID +
+                            " = " + std::to_string(fileId) + " WHERE " + MediaColumn::MEDIA_NAME + " = '" +
+                            displayName + "'";
+    int32_t ret = g_rdbStore->ExecuteSql(updateSql);
+    if (ret != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("Execute sql %{public}s failed", updateSql.c_str());
+    }
+}
+
+static int32_t QueryPhotoIdByDisplayName(const string &displayName)
+{
+    vector<string> columns;
+    RdbPredicates rdbPredicates(PhotoColumn::PHOTOS_TABLE);
+    rdbPredicates.EqualTo(MediaColumn::MEDIA_NAME, displayName);
+    auto resultSet = MediaLibraryRdbStore::Query(rdbPredicates, columns);
+    if (resultSet == nullptr || resultSet->GoToFirstRow() != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("Can not get fileId");
+        return -1;
+    }
+    int32_t fileId = GetInt32Val(MediaColumn::MEDIA_ID, resultSet);
+    return fileId;
+}
+
+HWTEST_F(GetCloudEnhancementPairTest, GetCloudEnhancementPair_Test_001, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("GetCloudEnhancementPair_Test_001 Begin");
+    // invalid uri prefix
+    string uri = "file://media/xxx/20000/";
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+    int32_t result = GetCloudEnhancementPair(uri, resultSet);
+    ASSERT_EQ(result, 0);
+    ASSERT_NE(resultSet, nullptr);
+    ASSERT_NE(resultSet->GoToFirstRow(), E_OK);
+}
+
+HWTEST_F(GetCloudEnhancementPairTest, GetCloudEnhancementPair_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("GetCloudEnhancementPair_Test_002 Begin");
+    // invalid fileId
+    string uri = "file://media/Photo/200000/";
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+    int32_t result = GetCloudEnhancementPair(uri, resultSet);
+    ASSERT_EQ(result, 0);
+    ASSERT_NE(resultSet, nullptr);
+    ASSERT_NE(resultSet->GoToFirstRow(), E_OK);
+}
+
+HWTEST_F(GetCloudEnhancementPairTest, GetCloudEnhancementPair_Test_003, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("GetCloudEnhancementPair_Test_003 Begin");
+    string pic1 = "cam_pic1";
+    InsertAsset(pic1);
+    int32_t fileId = QueryPhotoIdByDisplayName(pic1 + ".jpg");
+    ASSERT_GT(fileId, 0);
+
+    UpdateAssetAssociateFileId(fileId, pic1 + ".jpg");
+    string uri = "file://media/Photo/" + std::to_string(fileId) + "/";
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+    int32_t result = GetCloudEnhancementPair(uri, resultSet);
+    ASSERT_EQ(result, 0);
+
+    ASSERT_NE(resultSet, nullptr);
+    ASSERT_EQ(resultSet->GoToFirstRow(), E_OK);
+    ASSERT_EQ(GetInt32Val(MediaColumn::MEDIA_ID, resultSet), fileId);
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_index_construct_progress_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_index_construct_progress_test.cpp
new file mode 100755
index 0000000000..089c56124f
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/get_index_construct_progress_test.cpp
@@ -0,0 +1,179 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaAssetsControllerServiceTest"
+
+#include "get_index_construct_progress_test.h"
+
+#include <string>
+#include <vector>
+
+#define private public
+#define protected public
+#include "media_assets_controller_service.h"
+#undef private
+#undef protected
+
+#include "get_index_construct_progress_vo.h"
+
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "result_set_utils.h"
+#include "media_file_uri.h"
+
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+using OHOS::DataShare::DataSharePredicates;
+
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 1;
+static const string SQL_INSERT_PHOTO =
+    "INSERT INTO " + PhotoColumn::PHOTOS_TABLE + "(" + MediaColumn::MEDIA_FILE_PATH + ", " + MediaColumn::MEDIA_SIZE +
+    ", " + MediaColumn::MEDIA_TITLE + ", " + MediaColumn::MEDIA_NAME + ", " + MediaColumn::MEDIA_TYPE + ", " +
+    MediaColumn::MEDIA_OWNER_PACKAGE + ", " + MediaColumn::MEDIA_PACKAGE_NAME + ", " + MediaColumn::MEDIA_DATE_ADDED +
+    ", " + MediaColumn::MEDIA_DATE_MODIFIED + ", " + MediaColumn::MEDIA_DATE_TAKEN + ", " +
+    MediaColumn::MEDIA_DURATION + ", " + MediaColumn::MEDIA_IS_FAV + ", " + MediaColumn::MEDIA_DATE_TRASHED + ", " +
+    MediaColumn::MEDIA_HIDDEN + ", " + PhotoColumn::PHOTO_HEIGHT + ", " + PhotoColumn::PHOTO_WIDTH + ", " +
+    PhotoColumn::PHOTO_EDIT_TIME + ", " + PhotoColumn::PHOTO_SHOOTING_MODE + ")";
+static const string VALUES_END = ") ";
+
+static int32_t ClearTable(const string &table)
+{
+    RdbPredicates predicates(table);
+
+    int32_t rows = 0;
+    int32_t err = g_rdbStore->Delete(rows, predicates);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to clear photos table, err: %{public}d", err);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+
+void GetIndexConstructProgressTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start MediaLibraryPhotoOperationsTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+
+void GetIndexConstructProgressTest::TearDownTestCase(void)
+{
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+
+void GetIndexConstructProgressTest::SetUp()
+{
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+    MEDIA_INFO_LOG("SetUp");
+}
+
+void GetIndexConstructProgressTest::TearDown(void)
+{
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+    MEDIA_INFO_LOG("TearDown");
+}
+
+static int32_t GetIndexConstructProgress(string &progress)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->GetIndexConstructProgress(data, reply);
+
+    IPC::MediaRespVo<GetIndexConstructProgressRespBody> respVo;
+    if (respVo.Unmarshalling(reply) != true) {
+        MEDIA_ERR_LOG("respVo.Unmarshalling failed");
+        return -1;
+    }
+    int32_t errCode = respVo.GetErrCode();
+    if (errCode != 0) {
+        MEDIA_ERR_LOG("respVo.GetErrCode: %{public}d", errCode);
+        return errCode;
+    }
+    progress = respVo.GetBody().indexProgress;
+    MEDIA_INFO_LOG("indexProgress: %{public}s", progress.c_str());
+    return 0;
+}
+
+static void InsertAsset(string displayName)
+{
+    // data, size,
+    // title, display_name, media_type,
+    // owner_package, package_name, date_added, date_modified, date_taken, duration, is_favorite, date_trashed, hidden
+    // height, width, edit_time, shooting_mode
+    std::string insertSql = SQL_INSERT_PHOTO + " VALUES (" + "'/storage/cloud/files/Photo/16/" + displayName +
+                            ".jpg', 175258, '" + displayName + "', '" + displayName + ".jpg', 1, " +
+                            "'com.ohos.camera', '相机', 1501924205218, 0, 1501924205, 0, 0, 0, 0, " +
+                            "1280, 960, 0, '1'" + VALUES_END;
+    int32_t ret = g_rdbStore->ExecuteSql(insertSql);
+    if (ret != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("Execute sql %{public}s failed", insertSql.c_str());
+    }
+}
+
+static int32_t QueryPhotoIdByDisplayName(const string &displayName)
+{
+    vector<string> columns;
+    RdbPredicates rdbPredicates(PhotoColumn::PHOTOS_TABLE);
+    rdbPredicates.EqualTo(MediaColumn::MEDIA_NAME, displayName);
+    auto resultSet = MediaLibraryRdbStore::Query(rdbPredicates, columns);
+    if (resultSet == nullptr || resultSet->GoToFirstRow() != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("Can not get fileId");
+        return -1;
+    }
+    int32_t fileId = GetInt32Val(MediaColumn::MEDIA_ID, resultSet);
+    return fileId;
+}
+
+HWTEST_F(GetIndexConstructProgressTest, GetIndexConstructProgress_Test_001, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("GetIndexConstructProgress_Test_001 Begin");
+    string progress;
+    int32_t result = GetIndexConstructProgress(progress);
+    ASSERT_EQ(result, 0);
+    string noAssetsExistProgress =
+        "{\"finishedImageCount\":0,\"totalImageCount\":0,\"finishedVideoCount\":0,\"totalVideoCount\":0}";
+    ASSERT_EQ(progress, noAssetsExistProgress);
+}
+
+HWTEST_F(GetIndexConstructProgressTest, GetIndexConstructProgress_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("GetIndexConstructProgress_Test_002 Begin");
+    string pic1 = "cam_pic1";
+    InsertAsset(pic1);
+    int32_t fileId = QueryPhotoIdByDisplayName(pic1 + ".jpg");
+    ASSERT_GT(fileId, 0);
+
+    string progress;
+    int32_t result = GetIndexConstructProgress(progress);
+    ASSERT_EQ(result, 0);
+    string oneImageProgress =
+        "{\"finishedImageCount\":0,\"totalImageCount\":1,\"finishedVideoCount\":0,\"totalVideoCount\":0}";
+    ASSERT_EQ(progress, oneImageProgress);
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/media_assets_controller_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/media_assets_controller_test.cpp
new file mode 100644
index 0000000000..28234e63bf
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/media_assets_controller_test.cpp
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaAssetsControllerTest"
+
+#include "media_assets_controller_test.h"
+
+#include <memory>
+#include <string>
+
+#define private public
+#define protected public
+#include "media_assets_controller_service.h"
+#undef private
+#undef protected
+
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "result_set_utils.h"
+#include "media_file_uri.h"
+
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 1;
+
+static int32_t ClearTable(const string &table)
+{
+    RdbPredicates predicates(table);
+
+    int32_t rows = 0;
+    int32_t err = g_rdbStore->Delete(rows, predicates);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to clear album table, err: %{public}d", err);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+
+void MediaAssetsControllerTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start MediaLibraryPhotoOperationsTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+    ClearTable(PhotoAlbumColumns::TABLE);
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+
+void MediaAssetsControllerTest::TearDownTestCase(void)
+{
+    ClearTable(PhotoAlbumColumns::TABLE);
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+
+void MediaAssetsControllerTest::SetUp()
+{
+    MEDIA_INFO_LOG("SetUp");
+}
+
+void MediaAssetsControllerTest::TearDown(void)
+{
+    MEDIA_INFO_LOG("TearDown");
+}
+
+HWTEST_F(MediaAssetsControllerTest, OnRemoteRequest_Test_001, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("OnRemoteRequest_Test_001 enter");
+
+    auto controller = make_shared<MediaAssetsControllerService>();
+    uint32_t start = static_cast<uint32_t>(MediaLibraryBusinessCode::ASSETS_BUSINESS_CODE_START);
+    uint32_t end = static_cast<uint32_t>(MediaLibraryBusinessCode::ASSETS_BUSINESS_CODE_END);
+    for (uint32_t code = start; code < end; ++code) {
+        MessageParcel data;
+        data.WriteInt32(INT32_MIN);
+        MessageParcel reply;
+        reply.WriteInt32(INT32_MIN);
+        MessageOption option;
+        IPC::IPCContext context(option, E_PERMISSION_DB_BYPASS);
+        controller->OnRemoteRequest(code, data, reply, context);
+        IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+        ASSERT_EQ(respVo.Unmarshalling(reply), true);
+        MEDIA_INFO_LOG("OnRemoteRequest Unmarshalling ErrCode:%{public}d", respVo.GetErrCode());
+        ASSERT_LE(respVo.GetErrCode(), 0);
+    }
+
+    MEDIA_INFO_LOG("OnRemoteRequest_Test_001 end");
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/query_cloud_enhancement_task_state_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/query_cloud_enhancement_task_state_test.cpp
new file mode 100755
index 0000000000..bbfb91bbb9
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/query_cloud_enhancement_task_state_test.cpp
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaAssetsControllerServiceTest"
+
+#include "query_cloud_enhancement_task_state_test.h"
+
+#include <string>
+#include <vector>
+
+#define private public
+#define protected public
+#include "media_assets_controller_service.h"
+#undef private
+#undef protected
+
+#include "query_cloud_enhancement_task_state_vo.h"
+
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "result_set_utils.h"
+#include "media_file_uri.h"
+
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+using OHOS::DataShare::DataSharePredicates;
+
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 1;
+static const string SQL_INSERT_PHOTO =
+    "INSERT INTO " + PhotoColumn::PHOTOS_TABLE + "(" + MediaColumn::MEDIA_FILE_PATH + ", " + MediaColumn::MEDIA_SIZE +
+    ", " + MediaColumn::MEDIA_TITLE + ", " + MediaColumn::MEDIA_NAME + ", " + MediaColumn::MEDIA_TYPE + ", " +
+    MediaColumn::MEDIA_OWNER_PACKAGE + ", " + MediaColumn::MEDIA_PACKAGE_NAME + ", " + MediaColumn::MEDIA_DATE_ADDED +
+    ", " + MediaColumn::MEDIA_DATE_MODIFIED + ", " + MediaColumn::MEDIA_DATE_TAKEN + ", " +
+    MediaColumn::MEDIA_DURATION + ", " + MediaColumn::MEDIA_IS_FAV + ", " + MediaColumn::MEDIA_DATE_TRASHED + ", " +
+    MediaColumn::MEDIA_HIDDEN + ", " + PhotoColumn::PHOTO_HEIGHT + ", " + PhotoColumn::PHOTO_WIDTH + ", " +
+    PhotoColumn::PHOTO_EDIT_TIME + ", " + PhotoColumn::PHOTO_SHOOTING_MODE + ")";
+static const string VALUES_END = ") ";
+
+static int32_t ClearTable(const string &table)
+{
+    RdbPredicates predicates(table);
+
+    int32_t rows = 0;
+    int32_t err = g_rdbStore->Delete(rows, predicates);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to clear photos table, err: %{public}d", err);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+
+void QueryCloudEnhancementTaskStateTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start MediaLibraryPhotoOperationsTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+
+void QueryCloudEnhancementTaskStateTest::TearDownTestCase(void)
+{
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+
+void QueryCloudEnhancementTaskStateTest::SetUp()
+{
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+    MEDIA_INFO_LOG("SetUp");
+}
+
+void QueryCloudEnhancementTaskStateTest::TearDown(void)
+{
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+    MEDIA_INFO_LOG("TearDown");
+}
+
+static int32_t QueryCloudEnhancementTaskState(string &photoUri, QueryCloudEnhancementTaskStateRespBody &resp)
+{
+    QueryCloudEnhancementTaskStateReqBody reqBody;
+    reqBody.photoUri = photoUri;
+
+    MessageParcel data;
+    if (reqBody.Marshalling(data) != true) {
+        MEDIA_ERR_LOG("reqBody.Marshalling failed");
+        return -1;
+    }
+
+    MessageParcel reply;
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->QueryCloudEnhancementTaskState(data, reply);
+
+    IPC::MediaRespVo<QueryCloudEnhancementTaskStateRespBody> respVo;
+    if (respVo.Unmarshalling(reply) != true) {
+        MEDIA_ERR_LOG("respVo.Unmarshalling failed");
+        return -1;
+    }
+    int32_t errCode = respVo.GetErrCode();
+    if (errCode != 0) {
+        MEDIA_ERR_LOG("respVo.GetErrCode: %{public}d", errCode);
+        return errCode;
+    }
+    resp = respVo.GetBody();
+    return 0;
+}
+
+static void InsertAsset(string displayName)
+{
+    // data, size,
+    // title, display_name, media_type,
+    // owner_package, package_name, date_added, date_modified, date_taken, duration, is_favorite, date_trashed, hidden
+    // height, width, edit_time, shooting_mode
+    std::string insertSql = SQL_INSERT_PHOTO + " VALUES (" + "'/storage/cloud/files/Photo/16/" + displayName +
+                            ".jpg', 175258, '" + displayName + "', '" + displayName + ".jpg', 1, " +
+                            "'com.ohos.camera', '相机', 1501924205218, 0, 1501924205, 0, 0, 0, 0, " +
+                            "1280, 960, 0, '1'" + VALUES_END;
+    int32_t ret = g_rdbStore->ExecuteSql(insertSql);
+    if (ret != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("Execute sql %{public}s failed", insertSql.c_str());
+    }
+}
+
+static int32_t QueryPhotoIdByDisplayName(const string &displayName)
+{
+    vector<string> columns;
+    RdbPredicates rdbPredicates(PhotoColumn::PHOTOS_TABLE);
+    rdbPredicates.EqualTo(MediaColumn::MEDIA_NAME, displayName);
+    auto resultSet = MediaLibraryRdbStore::Query(rdbPredicates, columns);
+    if (resultSet == nullptr || resultSet->GoToFirstRow() != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("Can not get fileId");
+        return -1;
+    }
+    int32_t fileId = GetInt32Val(MediaColumn::MEDIA_ID, resultSet);
+    return fileId;
+}
+
+HWTEST_F(QueryCloudEnhancementTaskStateTest, QueryCloudEnhancementTaskState_Test_001, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("QueryCloudEnhancementTaskState_Test_001 Begin");
+    // invalid uri prefix
+    string uri = "file://media/xxx/20000/";
+    QueryCloudEnhancementTaskStateRespBody resp;
+    int32_t result = QueryCloudEnhancementTaskState(uri, resp);
+    ASSERT_NE(result, 0);
+}
+
+HWTEST_F(QueryCloudEnhancementTaskStateTest, QueryCloudEnhancementTaskState_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("QueryCloudEnhancementTaskState_Test_002 Begin");
+    // invalid fileId
+    string uri = "file://media/Photo/200000/";
+    QueryCloudEnhancementTaskStateRespBody resp;
+    int32_t result = QueryCloudEnhancementTaskState(uri, resp);
+    ASSERT_NE(result, 0);
+}
+
+HWTEST_F(QueryCloudEnhancementTaskStateTest, QueryCloudEnhancementTaskState_Test_003, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("QueryCloudEnhancementTaskState_Test_003 Begin");
+    string pic1 = "cam_pic1";
+    InsertAsset(pic1);
+    int32_t fileId = QueryPhotoIdByDisplayName(pic1 + ".jpg");
+    ASSERT_GT(fileId, 0);
+
+    string uri = "file://media/Photo/" + std::to_string(fileId) + "/";
+    QueryCloudEnhancementTaskStateRespBody resp;
+    int32_t result = QueryCloudEnhancementTaskState(uri, resp);
+    ASSERT_EQ(result, 0);
+    ASSERT_EQ(resp.fileId, fileId);
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/queue_edit_asset_status_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/queue_edit_asset_status_test.cpp
new file mode 100644
index 0000000000..6981fa1499
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/queue_edit_asset_status_test.cpp
@@ -0,0 +1,289 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaAssetsControllerServiceTest"
+
+#include "queue_edit_asset_status_test.h"
+
+#include <string>
+#include <vector>
+
+#define private public
+#define protected public
+#include "media_assets_controller_service.h"
+#undef private
+#undef protected
+
+#include "message_parcel.h"
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "media_column.h"
+#include "result_set_utils.h"
+#include "medialibrary_errno.h"
+#include "is_edited_vo.h"
+#include "request_edit_data_vo.h"
+#include "get_edit_data_vo.h"
+#include "start_asset_analysis_vo.h"
+#include "get_cloudmedia_asset_status_vo.h"
+
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 1;
+
+static int32_t ClearTable(const string &table)
+{
+    RdbPredicates predicates(table);
+
+    int32_t rows = 0;
+    int32_t err = g_rdbStore->Delete(rows, predicates);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to clear album table, err: %{public}d", err);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+
+void QueueEditAssetStatusTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start MediaLibraryPhotoOperationsTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+
+void QueueEditAssetStatusTest::TearDownTestCase(void)
+{
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+
+void QueueEditAssetStatusTest::SetUp()
+{
+    MEDIA_INFO_LOG("SetUp");
+}
+
+void QueueEditAssetStatusTest::TearDown(void)
+{
+    MEDIA_INFO_LOG("TearDown");
+}
+
+
+/**
+ * @tc.name  : IsEdited_ShouldReturnError_WhenReadRequestBodyFails
+ * @tc.number: IsEditedTest_001
+ * @tc.desc  : 测试当读取请求体失败时,IsEdited 函数应返回错误
+ */
+HWTEST_F(QueueEditAssetStatusTest, IsEditedTest_001, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->IsEdited(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_LT(respVo.GetErrCode(), 0);
+}
+
+
+/**
+ * @tc.name  : IsEdited_ShouldQuerySuccessfully_WhenReadRequestBodySucceeds
+ * @tc.number: IsEditedTest_002
+ * @tc.desc  : 测试当读取请求体成功时,IsEdited 函数应成功执行查询操作
+ */
+HWTEST_F(QueueEditAssetStatusTest, IsEditedTest_002, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+    IsEditedReqBody reqBody;
+    reqBody.fileId = 1;
+    auto ret = reqBody.Marshalling(data);
+    EXPECT_EQ(ret, true);
+
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->IsEdited(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ret = respVo.Unmarshalling(reply);
+
+    EXPECT_EQ(ret, true);
+    EXPECT_EQ(respVo.GetErrCode(), 0);
+}
+
+/**
+ * @tc.name  : RequestEditData_ShouldReturnError_WhenReadRequestBodyFails
+ * @tc.number: RequestEditDataTest_001
+ * @tc.desc  : 测试当读取请求体失败时,RequestEditData 函数应返回错误
+ */
+HWTEST_F(QueueEditAssetStatusTest, RequestEditDataTest_001, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->RequestEditData(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_LT(respVo.GetErrCode(), 0);
+}
+
+/**
+ * @tc.name  : RequestEditData_ShouldReturnResultSet_WhenQueryEditDataExistsSucceeds
+ * @tc.number: RequestEditDataTest_002
+ * @tc.desc  : 测试当查询编辑数据成功时,RequestEditData 函数应返回查询结果集
+ */
+HWTEST_F(QueueEditAssetStatusTest, RequestEditDataTest_002, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+    RequestEditDataReqBody reqBody;
+    reqBody.predicates.EqualTo("file_id", "1111111");
+
+    auto ret = reqBody.Marshalling(data);
+    EXPECT_EQ(ret, true);
+
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->RequestEditData(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ret = respVo.Unmarshalling(reply);
+
+    EXPECT_EQ(ret, true);
+    EXPECT_EQ(respVo.GetErrCode(), 0);
+}
+
+/**
+ * @tc.name  : GetEditData_ShouldReturnError_WhenReadRequestBodyFails
+ * @tc.number: GetEditDataTest_001
+ * @tc.desc  : 测试当读取请求体失败时,GetEditData 函数应返回错误
+ */
+HWTEST_F(QueueEditAssetStatusTest, GetEditDataTest_001, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->GetEditData(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_LT(respVo.GetErrCode(), 0);
+}
+
+/**
+ * @tc.name  : GetEditData_ShouldReturnSuccess_WhenReadRequestBodySucceeds
+ * @tc.number: GetEditDataTest_002
+ * @tc.desc  : 测试当读取请求体成功时,GetEditData 函数应返回成功
+ */
+HWTEST_F(QueueEditAssetStatusTest, GetEditDataTest_002, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+    GetEditDataReqBody reqBody;
+
+    reqBody.predicates.EqualTo("file_id", "1111111");
+
+    auto ret = reqBody.Marshalling(data);
+    EXPECT_EQ(ret, true);
+
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->GetEditData(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ret = respVo.Unmarshalling(reply);
+
+    EXPECT_EQ(ret, true);
+    EXPECT_EQ(respVo.GetErrCode(), 0);
+}
+
+/**
+ * @tc.name  : GetCloudMediaAssetStatus_ShouldReturnError_WhenReadRequestBodyFails
+ * @tc.number: GetCloudMediaAssetStatusTest_001
+ * @tc.desc  : 测试当读取请求体失败时,函数应返回错误信息
+ */
+HWTEST_F(QueueEditAssetStatusTest, GetCloudMediaAssetStatusTest_001, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->GetCloudMediaAssetStatus(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_LT(respVo.GetErrCode(), 0);
+}
+
+/**
+ * @tc.name  : GetCloudMediaAssetStatus_ShouldReturnStatus_WhenReadRequestBodySucceeds
+ * @tc.number: GetCloudMediaAssetStatusTest_002
+ * @tc.desc  : 测试当读取请求体成功时,函数应返回正确的任务状态
+ */
+HWTEST_F(QueueEditAssetStatusTest, GetCloudMediaAssetStatusTest_002, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+    GetCloudMediaAssetStatusReqBody reqBody;
+
+    auto ret = reqBody.Marshalling(data);
+    EXPECT_EQ(ret, true);
+
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->GetCloudMediaAssetStatus(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ret = respVo.Unmarshalling(reply);
+
+    EXPECT_EQ(ret, true);
+    EXPECT_EQ(respVo.GetErrCode(), 0);
+}
+
+/**
+ * @tc.name  : StartAssetAnalysis_ShouldReturnError_WhenReadRequestBodyFails
+ * @tc.number: StartAssetAnalysisTest_001
+ * @tc.desc  : 测试当读取请求体失败时,StartAssetAnalysis 函数应返回错误响应
+ */
+HWTEST_F(QueueEditAssetStatusTest, StartAssetAnalysisTest_001, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->StartAssetAnalysis(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ASSERT_EQ(respVo.Unmarshalling(reply), true);
+    ASSERT_LT(respVo.GetErrCode(), 0);
+}
+
+/**
+ * @tc.name  : StartAssetAnalysis_ShouldReturnSuccess_WhenReadRequestBodySucceeds
+ * @tc.number: StartAssetAnalysisTest_002
+ * @tc.desc  : 测试当读取请求体成功时,StartAssetAnalysis 函数应返回成功响应
+ */
+HWTEST_F(QueueEditAssetStatusTest, StartAssetAnalysisTest_002, TestSize.Level0) {
+    MessageParcel data;
+    MessageParcel reply;
+    StartAssetAnalysisReqBody reqBody;
+    std::vector<std::string> fileIds{"111111","222222"};
+
+    reqBody.predicates.In("Photos.file_id", fileIds);
+    auto ret = reqBody.Marshalling(data);
+    EXPECT_EQ(ret, true);
+
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->StartAssetAnalysis(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    ret = respVo.Unmarshalling(reply);
+
+    EXPECT_EQ(ret, true);
+    EXPECT_EQ(respVo.GetErrCode(), 0);
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/request_content_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/request_content_test.cpp
new file mode 100755
index 0000000000..5f9425119b
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/request_content_test.cpp
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaAssetsControllerServiceTest"
+
+#include "request_content_test.h"
+
+#include <string>
+#include <vector>
+
+#define private public
+#define protected public
+#include "media_assets_controller_service.h"
+#undef private
+#undef protected
+
+#include "request_content_vo.h"
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "result_set_utils.h"
+#include "media_file_uri.h"
+
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+using namespace IPC;
+
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 1;
+
+static int32_t ClearTable(const string &table)
+{
+    RdbPredicates predicates(table);
+
+    int32_t rows = 0;
+    int32_t err = g_rdbStore->Delete(rows, predicates);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to clear album table, err: %{public}d", err);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+
+void RequestContentTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start MediaLibraryPhotoOperationsTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+
+void RequestContentTest::TearDownTestCase(void)
+{
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+
+void RequestContentTest::SetUp()
+{
+    MEDIA_INFO_LOG("SetUp");
+}
+
+void RequestContentTest::TearDown(void)
+{
+    MEDIA_INFO_LOG("TearDown");
+}
+
+static const string SQL_INSERT_PHOTO = "INSERT INTO " + PhotoColumn::PHOTOS_TABLE + "(" +
+    MediaColumn::MEDIA_FILE_PATH + ", " + MediaColumn::MEDIA_SIZE + ", " + MediaColumn::MEDIA_TITLE + ", " +
+    MediaColumn::MEDIA_NAME + ", " + MediaColumn::MEDIA_TYPE + ", " + MediaColumn::MEDIA_OWNER_PACKAGE + ", " +
+    MediaColumn::MEDIA_PACKAGE_NAME + ", " + MediaColumn::MEDIA_DATE_ADDED + ", "  +
+    MediaColumn::MEDIA_DATE_MODIFIED + ", " + MediaColumn::MEDIA_DATE_TAKEN + ", " +
+    MediaColumn::MEDIA_DURATION + ", " + MediaColumn::MEDIA_IS_FAV + ", " + MediaColumn::MEDIA_HIDDEN +", " +
+    PhotoColumn::PHOTO_HEIGHT + ", " + PhotoColumn::PHOTO_WIDTH + ", " + PhotoColumn::PHOTO_EDIT_TIME + ", " +
+    PhotoColumn::PHOTO_SUBTYPE + ", " + PhotoColumn::PHOTO_SHOOTING_MODE + ")";
+
+static void InsertMovingAssetIntoPhotosTable(const string& data, const string& title)
+{
+    // data, size, title, display_name, media_type,
+    // owner_package, package_name, date_added, date_modified, date_taken, duration, is_favorite, hidden
+    // height, width, edit_time, subtype, shooting_mode
+    g_rdbStore->ExecuteSql(SQL_INSERT_PHOTO + "VALUES ('" + data + "', 175258, '" + title + "', '" +
+        title + ".jpg', 1, 'com.ohos.camera', '相机', 1748423617814, 1748424146785, 1748423617706, " +
+        "0, 0, 0, 1280, 960, 0, 3, '1' )"); // cam, pic, subtype = 3(PhotoSubType::MOVING_PHOTO)
+}
+
+static shared_ptr<NativeRdb::ResultSet> QueryAsset(const string& displayName, const vector<string>& columns)
+{
+    RdbPredicates rdbPredicates(PhotoColumn::PHOTOS_TABLE);
+    rdbPredicates.EqualTo(MediaColumn::MEDIA_NAME, displayName);
+    auto resultSet = MediaLibraryRdbStore::Query(rdbPredicates, columns);
+    if (resultSet == nullptr || resultSet->GoToFirstRow() != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("Can not get file asset");
+        return nullptr;
+    }
+    return resultSet;
+}
+
+static int32_t QueryPhotoPosition(int32_t fileId, int32_t &position)
+{
+    RequestContentReqBody reqBody;
+    reqBody.mediaId = to_string(fileId);
+
+    MessageParcel data;
+    if (reqBody.Marshalling(data) != true) {
+        MEDIA_ERR_LOG("reqBody.Marshalling failed");
+        return -1;
+    }
+
+    MessageParcel reply;
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->RequestContent(data, reply);
+
+    IPC::MediaRespVo<RequestContentRespBody> resp;
+    if (resp.Unmarshalling(reply) != true) {
+        MEDIA_ERR_LOG("resp.Unmarshalling failed");
+        return -1;
+    }
+
+    position = resp.GetBody().position;
+    return resp.GetErrCode();
+}
+
+HWTEST_F(RequestContentTest, RequestContentTest_Test_001, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start RequestContentTest_Test_001");
+    // 1、前置条件准备，插入一张动态照片到数据库
+    string data = "/storage/cloud/files/Photo/16/IMG_1501924305_000.jpg";
+    string title = "cam_pic";
+    InsertMovingAssetIntoPhotosTable(data, title);
+
+    // 2、查询数据是否插入成功
+    vector<string> columns;
+    auto resultSet = QueryAsset(title + ".jpg", columns);
+    ASSERT_NE(resultSet, nullptr);
+    string displayName = GetStringVal(MediaColumn::MEDIA_NAME, resultSet);
+    EXPECT_GT(displayName.size(), 0);
+
+    int32_t fileId = GetInt32Val(PhotoColumn::MEDIA_ID, resultSet);
+
+    // 3、查询照片位置
+    int32_t position = -1;
+    int32_t ret = QueryPhotoPosition(-1, position);
+    EXPECT_EQ(ret, E_ERR);
+
+    ret = QueryPhotoPosition(fileId, position);
+    EXPECT_EQ(ret, 0);
+    EXPECT_GT(position, 0);
+    MEDIA_INFO_LOG("end RequestContentTest_Test_001");
+}
+
+HWTEST_F(RequestContentTest, RequestContentTest_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start RequestContentTest_Test_002");
+    MessageParcel data;
+    MessageParcel reply;
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->RequestContent(data, reply);
+
+    IPC::MediaRespVo<RequestContentRespBody> resp;
+    ASSERT_EQ(resp.Unmarshalling(reply), true);
+    ASSERT_LT(resp.GetErrCode(), 0);
+    MEDIA_INFO_LOG("end RequestContentTest_Test_002");
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/request_image_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/request_image_test.cpp
new file mode 100644
index 0000000000..d54159ac68
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/request_image_test.cpp
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#define MLOG_TAG "MediaAssetsControllerServiceTest"
+ 
+#include "request_image_test.h"
+ 
+#include <string>
+#include <vector>
+ 
+#define private public
+#define protected public
+#include "datashare_result_set.h"
+#include "media_assets_controller_service.h"
+#include "media_assets_service.h"
+#include "rdb_utils.h"
+#undef private
+#undef protected
+ 
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "result_set_utils.h"
+ 
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+using namespace OHOS::NativeRdb;
+ 
+static shared_ptr<MediaLibraryRdbStore> g_rdbStore;
+static constexpr int32_t SLEEP_SECONDS = 1;
+ 
+static int32_t ClearTable(const string &table)
+{
+    RdbPredicates predicates(table);
+ 
+    int32_t rows = 0;
+    int32_t err = g_rdbStore->Delete(rows, predicates);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to clear album table, err: %{public}d", err);
+        return E_HAS_DB_ERROR;
+    }
+    return E_OK;
+}
+ 
+void RequestImageTest::SetUpTestCase(void)
+{
+    MediaLibraryUnitTestUtils::Init();
+    g_rdbStore = MediaLibraryUnistoreManager::GetInstance().GetRdbStore();
+    if (g_rdbStore == nullptr) {
+        MEDIA_ERR_LOG("Start RequestImageTest failed, can not get g_rdbStore");
+        exit(1);
+    }
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+ 
+void RequestImageTest::TearDownTestCase(void)
+{
+    ClearTable(PhotoColumn::PHOTOS_TABLE);
+    MEDIA_INFO_LOG("TearDownTestCase");
+    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS));
+}
+ 
+void RequestImageTest::SetUp()
+{
+    MEDIA_INFO_LOG("SetUp");
+}
+ 
+void RequestImageTest::TearDown(void)
+{
+    MEDIA_INFO_LOG("TearDown");
+}
+ 
+static void InsertAssetIntoPhotosTable(const std::string &filePath, const std::string &photoId, int photoQuality)
+{
+    const std::string sqlInsertPhoto = "INSERT INTO " + PhotoColumn::PHOTOS_TABLE + "("  +
+        MediaColumn::MEDIA_FILE_PATH + ", " + MediaColumn::MEDIA_SIZE + ", " + MediaColumn::MEDIA_TITLE + ", " +
+        MediaColumn::MEDIA_NAME + ", " + MediaColumn::MEDIA_TYPE + ", " + MediaColumn::MEDIA_OWNER_PACKAGE + ", " +
+        MediaColumn::MEDIA_PACKAGE_NAME + ", " + MediaColumn::MEDIA_DATE_ADDED + ", "  +
+        MediaColumn::MEDIA_DATE_MODIFIED + ", " + MediaColumn::MEDIA_DATE_TAKEN + ", " +
+        MediaColumn::MEDIA_DURATION + ", " + MediaColumn::MEDIA_IS_FAV + ", " + MediaColumn::MEDIA_DATE_TRASHED + ", " +
+        MediaColumn::MEDIA_HIDDEN + ", " + PhotoColumn::PHOTO_HEIGHT + ", " + PhotoColumn::PHOTO_WIDTH + ", " +
+        PhotoColumn::PHOTO_EDIT_TIME + ", " + PhotoColumn::PHOTO_SHOOTING_MODE + ", " + PhotoColumn::PHOTO_ID + ", " +
+        PhotoColumn::PHOTO_QUALITY + ")";
+    g_rdbStore->ExecuteSql(sqlInsertPhoto + "VALUES (" +
+        "'" + filePath + "', 175258, 'cam_pic', 'cam_pic.jpg', 1, " +
+        "'com.ohos.camera', '相机', 1501924205218, 0, 1501924205, 0, 0, 0, 0, " +
+        "1280, 960, 0, '1', '" + photoId  + "', " + std::to_string(photoQuality) + ")"); // cam, pic, shootingmode = 1
+}
+ 
+HWTEST_F(RequestImageTest, QueryPhotoStatus_Test_001, TestSize.Level0)
+{
+    bool createDirRes = MediaFileUtils::CreateDirectory("/data/local/tmp");
+    EXPECT_EQ(createDirRes, true);
+    std::string filePath = "/data/local/tmp/IMG_1501924305_001.jpg";
+    if (!MediaFileUtils::IsFileExists(filePath)) {
+        bool createFileRes = MediaFileUtils::CreateFile(filePath);
+        EXPECT_EQ(createFileRes, true);
+    }
+    const std::string photoId = "photo_id_test";
+    int photoQuality = 1;
+    InsertAssetIntoPhotosTable(filePath, photoId, photoQuality);
+ 
+    RdbPredicates rdbPredicates(PhotoColumn::PHOTOS_TABLE);
+    rdbPredicates.EqualTo(MediaColumn::MEDIA_FILE_PATH, filePath);
+    std::vector<std::string> columns = { MediaColumn::MEDIA_ID, PhotoColumn::PHOTO_ID, PhotoColumn::PHOTO_QUALITY };
+ 
+    shared_ptr<NativeRdb::ResultSet> resSet = MediaLibraryRdbStore::Query(rdbPredicates, columns);
+    EXPECT_NE(resSet, nullptr);
+    EXPECT_EQ(resSet->GoToNextRow(), NativeRdb::E_OK);
+ 
+    QueryPhotoReqBody reqBody;
+    int fileId = GetInt32Val(MediaColumn::MEDIA_ID, resSet);
+    EXPECT_GT(fileId, 0);
+    reqBody.fileId = std::to_string(fileId);
+    MessageParcel data;
+    MessageParcel reply;
+    reqBody.Marshalling(data);
+ 
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->QueryPhotoStatus(data, reply);
+    IPC::MediaRespVo<QueryPhotoRspBody> resp;
+    bool isValid = resp.Unmarshalling(reply);
+    ASSERT_EQ(isValid, true);
+    EXPECT_EQ(resp.GetBody().photoId, photoId);
+    EXPECT_EQ(resp.GetBody().photoQuality, photoQuality);
+}
+
+HWTEST_F(RequestImageTest, LogMovingPhoto_TEST_001, TestSize.Level1)
+{
+    AdaptedReqBody reqBody;
+    reqBody.adapted = 1;
+    MessageParcel data;
+    MessageParcel reply;
+    reqBody.Marshalling(data);
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->LogMovingPhoto(data, reply);
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> resp;
+    bool isValid = resp.Unmarshalling(reply);
+    ASSERT_EQ(isValid, true);
+    EXPECT_EQ(resp.GetErrCode(), E_SUCCESS);
+}
+ 
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/set_favorite_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/set_favorite_test.cpp
index fb9f94b83e..30f2c7ccb3 100755
--- a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/set_favorite_test.cpp
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/set_favorite_test.cpp
@@ -167,4 +167,17 @@ HWTEST_F(SetFavoriteTest, SetFavoriteTest_Test_001, TestSize.Level0)
     MEDIA_INFO_LOG("end SetFavoriteTest_Test_001");
 }
 
+HWTEST_F(SetFavoriteTest, SetFavoriteTest_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start SetFavoriteTest_Test_002");
+    MessageParcel data;
+    MessageParcel reply;
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->AssetChangeSetFavorite(data, reply);
+
+    IPC::MediaRespVo<MediaEmptyObjVo> resp;
+    ASSERT_EQ(resp.Unmarshalling(reply), true);
+    ASSERT_LT(resp.GetErrCode(), 0);
+    MEDIA_INFO_LOG("end SetFavoriteTest_Test_002");
+}
 }  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/set_hidden_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/set_hidden_test.cpp
index 7aaad8bb17..206675c5b8 100755
--- a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/set_hidden_test.cpp
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/set_hidden_test.cpp
@@ -176,4 +176,17 @@ HWTEST_F(SetHiddenTest, SetHiddenTest_Test_001, TestSize.Level0)
     MEDIA_INFO_LOG("end SetHiddenTest_Test_001");
 }
 
+HWTEST_F(SetHiddenTest, SetHiddenTest_Test_002, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("Start SetHiddenTest_Test_002");
+    MessageParcel data;
+    MessageParcel reply;
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->AssetChangeSetHidden(data, reply);
+
+    IPC::MediaRespVo<MediaEmptyObjVo> resp;
+    ASSERT_EQ(resp.Unmarshalling(reply), true);
+    ASSERT_LT(resp.GetErrCode(), 0);
+    MEDIA_INFO_LOG("end SetHiddenTest_Test_002");
+}
 }  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/stop_thumbnail_creation_task_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/stop_thumbnail_creation_task_test.cpp
index 2abc4a3683..c54fb86920 100755
--- a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/stop_thumbnail_creation_task_test.cpp
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/stop_thumbnail_creation_task_test.cpp
@@ -149,7 +149,7 @@ int32_t StopThumCreationTask(int32_t requestId)
         MEDIA_ERR_LOG("respVo.Unmarshalling failed");
         return -1;
     }
-    MEDIA_INFO_LOG("StartThumCreationTask ErrCode:%{public}d", respVo.GetErrCode());
+    MEDIA_INFO_LOG("StopThumCreationTask ErrCode:%{public}d", respVo.GetErrCode());
     return respVo.GetErrCode();
 }
 
@@ -240,8 +240,7 @@ HWTEST_F(StopThumbnailCreationTaskTest, StopThumbnailCreationTask_Test_003, Test
 
     result = StopThumCreationTask(requestId);
     ASSERT_EQ(result, 0);
-
-    std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS * 3));
-    ASSERT_EQ(CheckhumbnailReadyAllEnd(), 0);
+    // std::this_thread::sleep_for(std::chrono::seconds(SLEEP_SECONDS * 3));
+    // ASSERT_EQ(CheckhumbnailReadyAllEnd(), 0);
 }
 }  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/sync_cloud_enhancement_task_status_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/sync_cloud_enhancement_task_status_test.cpp
new file mode 100755
index 0000000000..8533cb3f09
--- /dev/null
+++ b/frameworks/innerkitsimpl/test/unittest/media_assets_controller_service_test/src/sync_cloud_enhancement_task_status_test.cpp
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaAssetsControllerServiceTest"
+
+#include "sync_cloud_enhancement_task_status_test.h"
+
+#include <string>
+#include <vector>
+
+#define private public
+#define protected public
+#include "media_assets_controller_service.h"
+#undef private
+#undef protected
+
+#include "cloud_enhancement_vo.h"
+
+#include "user_define_ipc_client.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_unittest_utils.h"
+#include "medialibrary_unistore_manager.h"
+#include "result_set_utils.h"
+#include "media_file_uri.h"
+
+namespace OHOS::Media {
+using namespace std;
+using namespace testing::ext;
+
+void SyncCloudEnhancementTaskStatusTest::SetUpTestCase(void)
+{
+    MEDIA_INFO_LOG("SetUpTestCase");
+}
+
+void SyncCloudEnhancementTaskStatusTest::TearDownTestCase(void)
+{
+    MEDIA_INFO_LOG("TearDownTestCase");
+}
+
+void SyncCloudEnhancementTaskStatusTest::SetUp()
+{
+    MEDIA_INFO_LOG("SetUp");
+}
+
+void SyncCloudEnhancementTaskStatusTest::TearDown(void)
+{
+    MEDIA_INFO_LOG("TearDown");
+}
+
+static int32_t SyncCloudEnhancementTaskStatus()
+{
+    CloudEnhancementReqBody reqBody;
+    MessageParcel data;
+    if (reqBody.Marshalling(data) != true) {
+        MEDIA_ERR_LOG("reqBody.Marshalling failed");
+        return -1;
+    }
+    MessageParcel reply;
+    auto service = make_shared<MediaAssetsControllerService>();
+    service->SyncCloudEnhancementTaskStatus(data, reply);
+
+    IPC::MediaRespVo<IPC::MediaEmptyObjVo> respVo;
+    if (respVo.Unmarshalling(reply) != true) {
+        MEDIA_ERR_LOG("respVo.Unmarshalling failed");
+        return -1;
+    }
+    MEDIA_INFO_LOG("ErrCode:%{public}d", respVo.GetErrCode());
+    return respVo.GetErrCode();
+}
+
+HWTEST_F(SyncCloudEnhancementTaskStatusTest, SyncCloudEnhancementTaskStatus_Test_001, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("SyncCloudEnhancementTaskStatus_Test_001 Begin");
+    int32_t result = SyncCloudEnhancementTaskStatus();
+    ASSERT_LT(result, 0);
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/frameworks/innerkitsimpl/test/unittest/media_permission_check_test/src/media_permission_check_test.cpp b/frameworks/innerkitsimpl/test/unittest/media_permission_check_test/src/media_permission_check_test.cpp
index e7962f9ddf..b32c73064a 100755
--- a/frameworks/innerkitsimpl/test/unittest/media_permission_check_test/src/media_permission_check_test.cpp
+++ b/frameworks/innerkitsimpl/test/unittest/media_permission_check_test/src/media_permission_check_test.cpp
@@ -125,6 +125,7 @@ static std::unordered_map<uint32_t, std::vector<std::vector<PermissionType>>> te
     {6, {{}, {SYSTEMAPI_PERM}}},
     {7, {}},
     {8, {{PRIVATE_PERM, CLOUDFILE_SYNC, READ_PERM, WRITE_PERM}}},
+    {9, {{CLOUD_READ}, {CLOUD_WRITE}}},
     {0, {{READ_PERM}, {WRITE_PERM}}},
     {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_OPEN), {{READ_PERM, WRITE_PERM}}},  // openfile api
 };
@@ -425,6 +426,17 @@ HWTEST_F(MediaPermissionCheckTest, MediaPermissionCheckTest_017, TestSize.Level0
     MEDIA_INFO_LOG("MediaPermissionCheckTest_017 end");
 }
 
+HWTEST_F(MediaPermissionCheckTest, MediaPermissionCheckTest_018, TestSize.Level0)
+{
+    MEDIA_INFO_LOG("MediaPermissionCheckTest_018 begin");
+    uint32_t businessCode = 9;
+    PermissionHeaderReq data;
+    std::unordered_map<std::string, std::string> headerMap;
+    EXPECT_EQ(PreparePermissionParam(businessCode, -1, false, headerMap, data), E_SUCCESS);
+    EXPECT_EQ(PermissionCheck::VerifyPermissions(businessCode, data), E_PERMISSION_DENIED);
+    MEDIA_INFO_LOG("MediaPermissionCheckTest_018 end");
+}
+
 HWTEST_F(MediaPermissionCheckTest, MediaPermissionCheckTest_OPENFILE, TestSize.Level0)
 {
     MEDIA_INFO_LOG("MediaPermissionCheckTest_OPENFILE begin");
diff --git a/frameworks/js/src/cloud_enhancement_napi.cpp b/frameworks/js/src/cloud_enhancement_napi.cpp
index ff66b47ea3..8fb98ee227 100644
--- a/frameworks/js/src/cloud_enhancement_napi.cpp
+++ b/frameworks/js/src/cloud_enhancement_napi.cpp
@@ -41,6 +41,8 @@
 #include "cloud_enhancement_vo.h"
 #include "medialibrary_business_code.h"
 #include "user_define_ipc_client.h"
+#include "get_cloud_enhancement_pair_vo.h"
+#include "query_cloud_enhancement_task_state_vo.h"
 
 using namespace std;
 using namespace OHOS::DataShare;
@@ -52,9 +54,6 @@ using namespace OHOS::MediaEnhance;
 namespace OHOS::Media {
 static const string CLOUD_ENHANCEMENT_CLASS = "CloudEnhancement";
 thread_local napi_ref CloudEnhancementNapi::constructor_ = nullptr;
-
-constexpr int32_t STRONG_ASSOCIATION = 1;
-
 #ifdef ABILITY_CLOUD_ENHANCEMENT_SUPPORT
 static void* dynamicHandler = nullptr;
 static MediaEnhanceClientHandle* clientWrapper = nullptr;
@@ -827,26 +826,20 @@ static void QueryCloudEnhancementTaskStateExecute(napi_env env, void* data)
     tracer.Start("QueryCloudEnhancementTaskStateExecute");
 
     auto* context = static_cast<CloudEnhancementAsyncContext*>(data);
-    string uriStr = PAH_CLOUD_ENHANCEMENT_QUERY;
-    Uri queryTaskUri(uriStr);
-    vector<string> columns = {
-        MediaColumn::MEDIA_ID, PhotoColumn::PHOTO_ID,
-        PhotoColumn::PHOTO_CE_AVAILABLE, PhotoColumn::PHOTO_CE_STATUS_CODE
-    };
-    int errCode = 0;
-    context->predicates.EqualTo(MediaColumn::MEDIA_ID, context->photoUri);
-    auto resultSet = UserFileClient::Query(queryTaskUri, context->predicates, columns, errCode);
-    if (resultSet == nullptr || resultSet->GoToNextRow() != E_OK) {
-        NAPI_ERR_LOG("ResultSet is nullptr, errCode is %{public}d", errCode);
+    QueryCloudEnhancementTaskStateReqBody reqBody;
+    QueryCloudEnhancementTaskStateRespBody respBody;
+    reqBody.photoUri = context->photoUri;
+    uint32_t businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::QUERY_CLOUD_ENHANCEMENT_TASK_STATE);
+    int32_t ret = IPC::UserDefineIPCClient().Call(businessCode, reqBody, respBody);
+    if (ret < 0) {
         context->SaveError(JS_INNER_FAIL);
+        NAPI_ERR_LOG("Failed to query cloud enhancement task state, err: %{public}d", ret);
         return;
     }
-    int32_t fileId = get<int32_t>(ResultSetUtils::GetValFromColumn(MediaColumn::MEDIA_ID, resultSet, TYPE_INT32));
-    string photoId = get<string>(ResultSetUtils::GetValFromColumn(PhotoColumn::PHOTO_ID, resultSet, TYPE_STRING));
-    int32_t ceAvailable =
-        get<int32_t>(ResultSetUtils::GetValFromColumn(PhotoColumn::PHOTO_CE_AVAILABLE, resultSet, TYPE_INT32));
-    int32_t CEErrorCode = get<int32_t>(ResultSetUtils::GetValFromColumn(PhotoColumn::PHOTO_CE_STATUS_CODE,
-        resultSet, TYPE_INT32));
+    int32_t fileId = respBody.fileId;
+    string photoId = respBody.photoId;
+    int32_t ceAvailable = respBody.ceAvailable;
+    int32_t CEErrorCode = respBody.CEErrorCode;
     NAPI_INFO_LOG("query fileId: %{public}d, photoId: %{private}s, ceAvailable: %{public}d",
         fileId, photoId.c_str(), ceAvailable);
 
@@ -916,10 +909,9 @@ static void SyncCloudEnhancementTaskStatusExecute(napi_env env, void* data)
     tracer.Start("SyncCloudEnhancementTaskStatusExecute");
 
     auto* context = static_cast<CloudEnhancementAsyncContext*>(data);
-    string uriStr = PAH_CLOUD_ENHANCEMENT_SYNC;
-    Uri syncUri(uriStr);
-    context->valuesBucket.Put(PhotoColumn::PHOTO_STRONG_ASSOCIATION, STRONG_ASSOCIATION);
-    int32_t changeRows = UserFileClient::Update(syncUri, context->predicates, context->valuesBucket);
+    uint32_t businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::SYNC_CLOUD_ENHANCEMENT_TASK_STATUS);
+    CloudEnhancementReqBody reqBody;
+    int32_t changeRows = IPC::UserDefineIPCClient().Call(businessCode, reqBody);
     if (changeRows < 0) {
         context->SaveError(changeRows);
         NAPI_ERR_LOG("sync cloud enhancement failed, err: %{public}d", changeRows);
@@ -987,19 +979,17 @@ static void GetCloudEnhancementPairExecute(napi_env env, void* data)
 
     auto* context = static_cast<CloudEnhancementAsyncContext*>(data);
     CHECK_NULL_PTR_RETURN_VOID(context, "AsyncContext is null");
-    std::string  uriStr = PAH_CLOUD_ENHANCEMENT_GET_PAIR;
-    Uri getPairUri(uriStr);
-    std::vector<std::string> columns;
-    int errCode = 0;
-    NAPI_INFO_LOG("CloudEnhancementNAPI context->photoUri is %{private}s", context->photoUri.c_str());
-    context->predicates.EqualTo(MediaColumn::MEDIA_ID, context->photoUri);
-    shared_ptr<DataShare::DataShareResultSet> resultSet =
-        UserFileClient::Query(getPairUri, context->predicates, columns, errCode);
-    if (resultSet == nullptr || resultSet->GoToNextRow() != E_OK) {
-        NAPI_ERR_LOG("Resultset is nullptr, errCode is %{public}d", errCode);
-        context->SaveError(JS_INNER_FAIL);
+    GetCloudEnhancementPairReqBody reqBody;
+    GetCloudEnhancementPairRespBody respBody;
+    reqBody.photoUri = context->photoUri;
+    uint32_t businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::GET_CLOUD_ENHANCEMENT_PAIR);
+    int32_t ret = IPC::UserDefineIPCClient().Call(businessCode, reqBody, respBody);
+    if (ret < 0) {
+        context->SaveError(ret);
+        NAPI_ERR_LOG("Failed to get cloud enhancement pair, err: %{public}d", ret);
         return;
     }
+    auto resultSet = respBody.resultSet;
     context->fetchFileResult = make_unique<FetchResult<FileAsset>>(move(resultSet));
     if (!context->GetPairAsset()) {
         NAPI_ERR_LOG("Fail to getPairAsset");
diff --git a/frameworks/js/src/cloud_media_asset_manager_napi.cpp b/frameworks/js/src/cloud_media_asset_manager_napi.cpp
index 17c519ea68..c6fd4358a3 100644
--- a/frameworks/js/src/cloud_media_asset_manager_napi.cpp
+++ b/frameworks/js/src/cloud_media_asset_manager_napi.cpp
@@ -35,6 +35,9 @@
 #include "retain_cloud_media_asset_vo.h"
 #include "medialibrary_business_code.h"
 #include "user_define_ipc_client.h"
+#include "medialibrary_business_code.h"
+#include "get_cloudmedia_asset_status_vo.h"
+#include "user_define_ipc_client.h"
 
 using namespace std;
 namespace OHOS::Media {
@@ -439,11 +442,14 @@ static void GetCloudMediaAssetStatusExecute(napi_env env, void* data)
     NAPI_INFO_LOG("enter GetCloudMediaAssetStatusExecute");
 
     auto* context = static_cast<CloudMediaAssetAsyncContext*>(data);
-    Uri getUri(CMAM_CLOUD_MEDIA_ASSET_TASK_STATUS_QUERY);
-    string result = UserFileClient::GetType(getUri);
-    NAPI_INFO_LOG("Get cloud media asset, res: %{public}s.", result.c_str());
+    GetCloudMediaAssetStatusReqBody reqBody;
+    GetCloudMediaAssetStatusReqBody rspBody;
+    uint32_t businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_GET_CLOUDMEDIA_ASSET_STATUS);
+    IPC::UserDefineIPCClient().Call(businessCode, reqBody, rspBody);
+
+    NAPI_INFO_LOG("Get cloud media asset, res: %{public}s.", rspBody.status.c_str());
     std::vector<std::string> type;
-    if (!SplitUriString(result, type)) {
+    if (!SplitUriString(rspBody.status, type)) {
         NAPI_ERR_LOG("GetType failed");
         return;
     }
diff --git a/frameworks/js/src/file_asset_napi.cpp b/frameworks/js/src/file_asset_napi.cpp
index 5a82110cec..98be3c8e5f 100644
--- a/frameworks/js/src/file_asset_napi.cpp
+++ b/frameworks/js/src/file_asset_napi.cpp
@@ -87,6 +87,10 @@
 #include "modify_assets_vo.h"
 #include "clone_asset_vo.h"
 #include "revert_to_original_vo.h"
+#include "get_asset_analysis_data_vo.h"
+#include "request_edit_data_vo.h"
+#include "is_edited_vo.h"
+#include "get_edit_data_vo.h"
 
 using OHOS::HiviewDFX::HiLog;
 using OHOS::HiviewDFX::HiLogLabel;
@@ -1333,9 +1337,11 @@ static int32_t CallCommitModify(FileAssetAsyncContext *context)
     headerMap[MediaColumn::MEDIA_ID] = to_string(context->objectPtr->GetId());
     headerMap[URI_TPYE] = TPYE_PHOTOS;
 
-    IPC::UserDefineIPCClient client;
-    client.SetHeader(headerMap);
-    return client.Call(context->businessCode, reqBody);
+    int32_t errCode = IPC::UserDefineIPCClient().SetHeader(headerMap).Call(context->businessCode, reqBody);
+    if (errCode < 0) {
+        NAPI_ERR_LOG("after IPC::UserDefineIPCClient().Call, errCode: %{public}d.", errCode);
+    }
+    return errCode;
 }
 
 static void JSCommitModifyExecute(napi_env env, void *data)
@@ -1771,7 +1777,7 @@ static void JSGetThumbnailDataExecute(napi_env env, FileAssetAsyncContext* conte
 {
     MediaLibraryTracer tracer;
     tracer.Start("JSGetThumbnailDataExecute");
- 
+
     string path = context->objectPtr->GetPath();
 #ifndef MEDIALIBRARY_COMPATIBILITY
     if (path.empty()
@@ -1830,7 +1836,7 @@ static void JSGetThumbnailDataCompleteCallback(napi_env env, napi_status status,
 {
     MediaLibraryTracer tracer;
     tracer.Start("JSGetThumbnailDataCompleteCallback");
- 
+
     CHECK_NULL_PTR_RETURN_VOID(context, "Async context is null");
 
     context->napiArrayBufferRef = ThumbnailManager::QueryThumbnailData(
@@ -1838,7 +1844,7 @@ static void JSGetThumbnailDataCompleteCallback(napi_env env, napi_status status,
 
     unique_ptr<JSAsyncContextOutput> jsContext = make_unique<JSAsyncContextOutput>();
     jsContext->status = false;
- 
+
     CHECK_ARGS_RET_VOID(env, napi_get_undefined(env, &jsContext->data), JS_INNER_FAIL);
     CHECK_ARGS_RET_VOID(env, napi_get_undefined(env, &jsContext->error), JS_INNER_FAIL);
     if (context->error == ERR_DEFAULT && context->napiArrayBufferRef != nullptr) {
@@ -1852,7 +1858,7 @@ static void JSGetThumbnailDataCompleteCallback(napi_env env, napi_status status,
         }
         context->HandleError(env, jsContext->error);
     }
- 
+
     tracer.Finish();
     if (context->work != nullptr) {
         MediaLibraryNapiUtils::InvokeJSAsyncMethod(env, context->deferred, context->callbackRef,
@@ -2188,12 +2194,7 @@ static DataShare::DataSharePredicates GetPredicatesHelper(FileAssetAsyncContext
     string fileId = to_string(context->objectInfo->GetFileId());
     if (context->analysisType == ANALYSIS_DETAIL_ADDRESS) {
         string language = Global::I18n::LocaleConfig::GetSystemLanguage();
-        //Chinese and English supported. Other languages English default.
-        if (language.find(LANGUAGE_ZH) == 0 || language.find(LANGUAGE_ZH_TR) == 0) {
-            language = LANGUAGE_ZH;
-        } else {
-            language = LANGUAGE_EN;
-        }
+        language = (language.find(LANGUAGE_ZH) == 0 || language.find(LANGUAGE_ZH_TR) == 0) ? LANGUAGE_ZH : LANGUAGE_EN;
         vector<string> onClause = { PhotoColumn::PHOTOS_TABLE + "." + PhotoColumn::MEDIA_ID + " = " +
             GEO_KNOWLEDGE_TABLE + "." + FILE_ID + " AND " +
             GEO_KNOWLEDGE_TABLE + "." + LANGUAGE + " = \'" + language + "\'" };
@@ -2205,32 +2206,66 @@ static DataShare::DataSharePredicates GetPredicatesHelper(FileAssetAsyncContext
     return predicates;
 }
 
+static std::shared_ptr<DataShare::DataShareResultSet> CallQueryAnalysisData(
+    FileAssetAsyncContext *context, const AnalysisSourceInfo &analysisInfo, bool analysisTotal)
+{
+    int32_t userId = context->objectPtr != nullptr ? context->objectPtr->GetUserId() : -1;
+    if (context->businessCode != 0) {
+        GetAssetAnalysisDataReqBody reqBody;
+        GetAssetAnalysisDataRspBody rspBody;
+        reqBody.fileId = context->objectInfo->GetFileId();
+        reqBody.analysisType = context->analysisType;
+        reqBody.analysisTotal = analysisTotal;
+        std::string lang = Global::I18n::LocaleConfig::GetSystemLanguage();
+        reqBody.language = (lang.find(LANGUAGE_ZH) == 0 || lang.find(LANGUAGE_ZH_TR) == 0) ? LANGUAGE_ZH : LANGUAGE_EN;
+        int32_t errCode = IPC::UserDefineIPCClient().SetUserId(userId).Call(context->businessCode, reqBody, rspBody);
+        if (errCode != 0) {
+            NAPI_INFO_LOG("IPC::UserDefineIPCClient().Call, errCode: %{public}d.", errCode);
+            return nullptr;
+        }
+        return rspBody.resultSet;
+    }
+
+    int32_t errCode = 0;
+    DataShare::DataSharePredicates predicates;
+    if (analysisTotal) {
+        Uri uriTotal(PAH_QUERY_ANA_TOTAL);
+        std::vector<std::string> fetchColumn = { analysisInfo.fieldStr };
+        predicates.EqualTo(MediaColumn::MEDIA_ID, to_string(context->objectInfo->GetFileId()));
+        return UserFileClient::Query(uriTotal, predicates, fetchColumn, errCode, userId);
+    }
+
+    Uri uriAnalysis(analysisInfo.uriStr);
+    predicates = GetPredicatesHelper(context);
+    std::vector<std::string> fetchColumn = analysisInfo.fetchColumn;
+    return UserFileClient::Query(uriAnalysis, predicates, fetchColumn, errCode, userId);
+}
+
 static void JSGetAnalysisDataExecute(FileAssetAsyncContext *context)
 {
     MediaLibraryTracer tracer;
     tracer.Start("JSGetThumbnailExecute");
-    if (ANALYSIS_SOURCE_INFO_MAP.find(context->analysisType) == ANALYSIS_SOURCE_INFO_MAP.end()) {
+    int32_t analysisType = context->analysisType;
+    auto it = ANALYSIS_SOURCE_INFO_MAP.find(analysisType);
+    if (it == ANALYSIS_SOURCE_INFO_MAP.end()) {
         NAPI_ERR_LOG("Invalid analysisType");
         return;
     }
-    auto &analysisInfo = ANALYSIS_SOURCE_INFO_MAP.at(context->analysisType);
-    DataShare::DataSharePredicates predicates = GetPredicatesHelper(context);
-    string fileId = to_string(context->objectInfo->GetFileId());
-    Uri uri(analysisInfo.uriStr);
-    std::vector<std::string> fetchColumn = analysisInfo.fetchColumn;
-    int errCode = 0;
-    int userId = context->objectPtr != nullptr ? context->objectPtr->GetUserId() : -1;
-    auto resultSet = UserFileClient::Query(uri, predicates, fetchColumn, errCode, userId);
-    context->analysisData = context->analysisType == ANALYSIS_FACE ?
-        MediaLibraryNapiUtils::ParseAnalysisFace2JsonStr(resultSet, fetchColumn, context->analysisType) :
-        MediaLibraryNapiUtils::ParseResultSet2JsonStr(resultSet, fetchColumn, context->analysisType);
+
+    const AnalysisSourceInfo &analysisInfo = it->second;
+    const std::vector<std::string> &fetchColumn = analysisInfo.fetchColumn;
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet = CallQueryAnalysisData(context, analysisInfo, false);
+    if (context->businessCode != 0) {
+        context->analysisData = MediaLibraryNapiUtils::ParseResultSet2JsonStr(resultSet, fetchColumn, analysisType);
+    } else {
+        context->analysisData = (analysisType == ANALYSIS_FACE) ?
+            MediaLibraryNapiUtils::ParseAnalysisFace2JsonStr(resultSet, fetchColumn, analysisType) :
+            MediaLibraryNapiUtils::ParseResultSet2JsonStr(resultSet, fetchColumn, analysisType);
+    }
+
     if (context->analysisData == ANALYSIS_NO_RESULTS) {
-        Uri uri(PAH_QUERY_ANA_TOTAL);
-        DataShare::DataSharePredicates predicates;
-        std::vector<std::string> fetchColumn = { analysisInfo.fieldStr };
-        predicates.EqualTo(MediaColumn::MEDIA_ID, fileId);
-        auto fieldValue = UserFileClient::Query(uri, predicates, fetchColumn, errCode, userId);
-        string value = MediaLibraryNapiUtils::ParseResultSet2JsonStr(fieldValue, fetchColumn);
+        resultSet = CallQueryAnalysisData(context, analysisInfo, true);
+        std::string value = MediaLibraryNapiUtils::ParseResultSet2JsonStr(resultSet, fetchColumn, analysisType);
         if (strstr(value.c_str(), ANALYSIS_INIT_VALUE.c_str()) == NULL) {
             context->analysisData = ANALYSIS_STATUS_ANALYZED;
         }
@@ -4167,7 +4202,7 @@ napi_value FileAssetNapi::PhotoAccessHelperCloneAsset(napi_env env, napi_callbac
     CHECK_COND_WITH_MESSAGE(env,
         MediaLibraryNapiUtils::AsyncContextSetObjectInfo(env, info, asyncContext, ARGS_ONE, ARGS_ONE) == napi_ok,
         "Failed to get object info");
-    
+
     auto changeRequest = asyncContext->objectInfo;
     auto fileAsset = changeRequest->GetFileAssetInstance();
     CHECK_COND(env, fileAsset != nullptr, JS_INNER_FAIL);
@@ -4236,9 +4271,11 @@ static int32_t CallModifyFavorite(FileAssetAsyncContext *context)
     headerMap[MediaColumn::MEDIA_ID] = to_string(context->objectPtr->GetId());
     headerMap[URI_TPYE] = TPYE_PHOTOS;
 
-    IPC::UserDefineIPCClient client;
-    client.SetHeader(headerMap);
-    return client.Call(context->businessCode, reqBody);
+    int32_t errCode = IPC::UserDefineIPCClient().SetHeader(headerMap).Call(context->businessCode, reqBody);
+    if (errCode < 0) {
+        NAPI_ERR_LOG("after IPC::UserDefineIPCClient().Call, errCode: %{public}d.", errCode);
+    }
+    return errCode;
 }
 
 static void PhotoAccessHelperFavoriteExecute(napi_env env, void *data)
@@ -4332,7 +4369,7 @@ napi_value FileAssetNapi::PhotoAccessHelperGetThumbnailData(napi_env env, napi_c
             JSGetThumbnailDataExecute(env, context);
         },
         reinterpret_cast<CompleteCallback>(JSGetThumbnailDataCompleteCallback));
- 
+
     return result;
 }
 
@@ -4476,7 +4513,11 @@ static int32_t CallModifyHidden(FileAssetAsyncContext *context)
     ModifyAssetsReqBody reqBody;
     reqBody.hiddenStatus = context->isHidden ? 1 : 0;
     reqBody.fileIds.push_back(context->objectPtr->GetId());
-    return IPC::UserDefineIPCClient().Call(context->businessCode, reqBody);
+    int32_t errCode = IPC::UserDefineIPCClient().Call(context->businessCode, reqBody);
+    if (errCode < 0) {
+        NAPI_ERR_LOG("after IPC::UserDefineIPCClient().Call, errCode: %{public}d.", errCode);
+    }
+    return errCode;
 }
 
 static void PhotoAccessHelperSetHiddenExecute(napi_env env, void *data)
@@ -4574,9 +4615,11 @@ static int32_t CallModifyPending(FileAssetAsyncContext *context)
     headerMap[MediaColumn::MEDIA_ID] = to_string(context->objectPtr->GetId());
     headerMap[URI_TPYE] = TPYE_PHOTOS;
 
-    IPC::UserDefineIPCClient client;
-    client.SetHeader(headerMap);
-    return client.Call(context->businessCode, reqBody);
+    int32_t errCode = IPC::UserDefineIPCClient().SetHeader(headerMap).Call(context->businessCode, reqBody);
+    if (errCode < 0) {
+        NAPI_ERR_LOG("after IPC::UserDefineIPCClient().Call, errCode: %{public}d.", errCode);
+    }
+    return errCode;
 }
 
 static void PhotoAccessHelperSetPendingExecute(napi_env env, void *data)
@@ -4729,9 +4772,11 @@ static int32_t CallModifyUserComment(FileAssetAsyncContext *context)
     headerMap[MediaColumn::MEDIA_ID] = to_string(context->objectPtr->GetId());
     headerMap[URI_TPYE] = TPYE_PHOTOS;
 
-    IPC::UserDefineIPCClient client;
-    client.SetHeader(headerMap);
-    return client.Call(context->businessCode, reqBody);
+    int32_t errCode = IPC::UserDefineIPCClient().SetHeader(headerMap).Call(context->businessCode, reqBody);
+    if (errCode < 0) {
+        NAPI_ERR_LOG("after IPC::UserDefineIPCClient().Call, errCode: %{public}d.", errCode);
+    }
+    return errCode;
 }
 
 static void PhotoAccessHelperSetUserCommentExecute(napi_env env, void *data)
@@ -4808,6 +4853,7 @@ napi_value FileAssetNapi::PhotoAccessHelperGetAnalysisData(napi_env env, napi_ca
     asyncContext->objectPtr = asyncContext->objectInfo->fileAssetPtr;
     CHECK_NULL_PTR_RETURN_UNDEFINED(env, asyncContext->objectPtr, result, "FileAsset is nullptr");
     asyncContext->resultNapiType = ResultNapiType::TYPE_PHOTOACCESS_HELPER;
+    asyncContext->businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_GET_ASSET_ANALYSIS_DATA);
     return MediaLibraryNapiUtils::NapiCreateAsyncWork(env, asyncContext, "PhotoAccessHelperGetAnalysisData",
         [](napi_env env, void *data) {
             auto context = static_cast<FileAssetAsyncContext*>(data);
@@ -4892,9 +4938,28 @@ static void PhotoAccessHelperIsEditedExecute(napi_env env, void *data)
     DataShare::DataShareValuesBucket values;
     vector<string> columns = { PhotoColumn::PHOTO_EDIT_TIME };
     int32_t errCode = 0;
+    shared_ptr<DataShare::DataShareResultSet> finalResultSet;
+
+    auto [accessSandbox, resultSet] =
+        UserFileClient::QueryAccessibleViaSandBox(uri, predicates, columns, errCode, -1);
+    if (accessSandbox) {
+        NAPI_INFO_LOG("PhotoAccessHelperIsEditedExecute no ipc");
+        if (resultSet == nullptr) {
+            NAPI_ERR_LOG("QueryAccessibleViaSandBox failed, resultSet is nullptr");
+        } else {
+            finalResultSet = resultSet;
+        }
+    } else {
+        NAPI_INFO_LOG("PhotoAccessHelperIsEditedExecute need ipc");
+        IsEditedReqBody reqBody;
+        IsEditedRspBody rspBody;
+        uint32_t businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_IS_EDITED);
+        reqBody.fileId = fileId;
+        errCode = IPC::UserDefineIPCClient().Call(businessCode, reqBody, rspBody);
+        finalResultSet = rspBody.resultSet;
+    }
     int64_t editTime = 0;
-    shared_ptr<DataShare::DataShareResultSet> resultSet = UserFileClient::Query(uri, predicates, columns, errCode);
-    if (!GetEditTimeFromResultSet(resultSet, editTime)) {
+    if (!GetEditTimeFromResultSet(finalResultSet, editTime)) {
         if (errCode == E_PERMISSION_DENIED) {
             context->error = OHOS_PERMISSION_DENIED_CODE;
         } else {
@@ -4957,17 +5022,39 @@ napi_value FileAssetNapi::PhotoAccessHelperIsEdited(napi_env env, napi_callback_
 
 static void QueryPhotoEditDataExists(int32_t fileId, int32_t &hasEditData)
 {
-    DataShare::DataSharePredicates predicates;
-    predicates.EqualTo(MediaColumn::MEDIA_ID, to_string(fileId));
-    vector<string> columns;
-    Uri uri(MEDIALIBRARY_DATA_URI + "/" + MEDIA_QUERYOPRN_QUERYEDITDATA + "/" + MEDIA_QUERYOPRN_QUERYEDITDATA);
-    int errCode = 0;
-    shared_ptr<DataShare::DataShareResultSet> resultSet = UserFileClient::Query(uri, predicates, columns, errCode);
-    if (resultSet == nullptr || resultSet->GoToFirstRow() != NativeRdb::E_OK) {
+    RequestEditDataReqBody reqBody;
+    RequestEditDataRspBody rspBody;
+    uint32_t businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_REQUEST_EDIT_DATA);
+    reqBody.predicates.EqualTo(MediaColumn::MEDIA_ID, to_string(fileId));
+
+    NAPI_INFO_LOG("before IPC::UserDefineIPCClient().Call");
+    IPC::UserDefineIPCClient().Call(businessCode, reqBody, rspBody);
+    NAPI_INFO_LOG("after IPC::UserDefineIPCClient().Call");
+    if (rspBody.resultSet == nullptr || rspBody.resultSet->GoToFirstRow() != NativeRdb::E_OK) {
         NAPI_ERR_LOG("Query failed");
         return;
     }
-    if (resultSet->GetInt(0, hasEditData) != NativeRdb::E_OK) {
+    if (rspBody.resultSet->GetInt(0, hasEditData) != NativeRdb::E_OK) {
+        NAPI_ERR_LOG("Can not get hasEditData");
+        return;
+    }
+}
+
+static void GetPhotoEditDataExists(int32_t fileId, int32_t &hasEditData)
+{
+    GetEditDataReqBody reqBody;
+    GetEditDataRspBody rspBody;
+    uint32_t businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_GET_EDIT_DATA);
+    reqBody.predicates.EqualTo(MediaColumn::MEDIA_ID, to_string(fileId));
+
+    NAPI_INFO_LOG("before IPC::UserDefineIPCClient().Call");
+    IPC::UserDefineIPCClient().Call(businessCode, reqBody, rspBody);
+    NAPI_INFO_LOG("after IPC::UserDefineIPCClient().Call");
+    if (rspBody.resultSet == nullptr || rspBody.resultSet->GoToFirstRow() != NativeRdb::E_OK) {
+        NAPI_ERR_LOG("Query failed");
+        return;
+    }
+    if (rspBody.resultSet->GetInt(0, hasEditData) != NativeRdb::E_OK) {
         NAPI_ERR_LOG("Can not get hasEditData");
         return;
     }
@@ -5047,6 +5134,45 @@ static void PhotoAccessHelperRequestEditDataExecute(napi_env env, void *data)
     }
 }
 
+static void PhotoAccessHelperGetEditDataExecute(napi_env env, void *data)
+{
+    MediaLibraryTracer tracer;
+    tracer.Start("PhotoAccessHelperGetEditDataExecute");
+    auto *context = static_cast<FileAssetAsyncContext *>(data);
+    CHECK_NULL_PTR_RETURN_VOID(context, "Async context is null");
+    int32_t hasEditData = 0;
+    GetPhotoEditDataExists(context->objectPtr->GetId(), hasEditData);
+    if (hasEditData == 0) {
+        context->editDataBuffer = static_cast<char*>(malloc(1));
+        if (context->editDataBuffer == nullptr) {
+            NAPI_ERR_LOG("malloc edit data buffer failed");
+            context->SaveError(E_FAIL);
+            return;
+        }
+        context->editDataBuffer[0] = '\0';
+        return;
+    }
+    bool isValid = false;
+    string fileUri = context->valuesBucket.Get(MEDIA_DATA_DB_URI, isValid);
+    if (!isValid) {
+        context->error = OHOS_INVALID_PARAM_CODE;
+        return;
+    }
+    MediaFileUtils::UriAppendKeyValue(fileUri, MEDIA_OPERN_KEYWORD, EDIT_DATA_REQUEST);
+    Uri uri(fileUri);
+    UniqueFd uniqueFd(UserFileClient::OpenFile(uri, "r"));
+    if (uniqueFd.Get() <= 0) {
+        if (uniqueFd.Get() == E_PERMISSION_DENIED) {
+            context->error = OHOS_PERMISSION_DENIED_CODE;
+        } else {
+            context->SaveError(uniqueFd.Get());
+        }
+        NAPI_ERR_LOG("Photo request edit data failed, ret: %{public}d", uniqueFd.Get());
+    } else {
+        ProcessEditData(context, uniqueFd);
+    }
+}
+
 static void GetEditDataString(char* editDataBuffer, string& result)
 {
     if (editDataBuffer == nullptr) {
@@ -5198,7 +5324,7 @@ napi_value FileAssetNapi::PhotoAccessHelperGetEditData(napi_env env, napi_callba
     MediaLibraryNapiUtils::UriAppendKeyValue(fileUri, API_VERSION, to_string(MEDIA_API_VERSION_V10));
     asyncContext->valuesBucket.Put(MEDIA_DATA_DB_URI, fileUri);
     return MediaLibraryNapiUtils::NapiCreateAsyncWork(env, asyncContext, "PhotoAccessHelperGetEditData",
-        PhotoAccessHelperRequestEditDataExecute, PhotoAccessHelperGetEditDataComplete);
+        PhotoAccessHelperGetEditDataExecute, PhotoAccessHelperGetEditDataComplete);
 }
 
 static void PhotoAccessHelperRequestSourceExecute(napi_env env, void *data)
diff --git a/frameworks/js/src/highlight_album_napi.cpp b/frameworks/js/src/highlight_album_napi.cpp
index 94f08257b3..27e2e495f2 100644
--- a/frameworks/js/src/highlight_album_napi.cpp
+++ b/frameworks/js/src/highlight_album_napi.cpp
@@ -58,6 +58,9 @@
 #include "delete_highlight_albums_vo.h"
 #include "set_subtitle_vo.h"
 #include "set_highlight_user_action_data_vo.h"
+#include "get_order_position_vo.h"
+#include "get_highlight_album_info_vo.h"
+#include "query_result_vo.h"
 
 using namespace std;
 using json = nlohmann::json;
@@ -294,40 +297,23 @@ static void JSGetHighlightAlbumInfoExecute(napi_env env, void *data)
     MediaLibraryTracer tracer;
     tracer.Start("JSGetHighlightAlbumInfoExecute");
     auto *context = static_cast<HighlightAlbumNapiAsyncContext*>(data);
-    string uriStr;
     std::vector<std::string> fetchColumn;
     DataShare::DataSharePredicates predicates;
     if (HIGHLIGHT_ALBUM_INFO_MAP.find(context->highlightAlbumInfoType) != HIGHLIGHT_ALBUM_INFO_MAP.end()) {
-        uriStr = HIGHLIGHT_ALBUM_INFO_MAP.at(context->highlightAlbumInfoType).uriStr;
         fetchColumn = HIGHLIGHT_ALBUM_INFO_MAP.at(context->highlightAlbumInfoType).fetchColumn;
-        string tabStr;
-        if (context->highlightAlbumInfoType == COVER_INFO) {
-            tabStr = HIGHLIGHT_COVER_INFO_TABLE;
-        } else {
-            tabStr = HIGHLIGHT_PLAY_INFO_TABLE;
-        }
-        vector<string> onClause = {
-            tabStr + "." + PhotoAlbumColumns::ALBUM_ID + " = " +
-            HIGHLIGHT_ALBUM_TABLE + "." + ID
-        };
-        predicates.InnerJoin(HIGHLIGHT_ALBUM_TABLE)->On(onClause);
     } else {
         NAPI_ERR_LOG("Invalid highlightAlbumInfoType");
         return;
     }
-    int32_t albumId = context->albumId;
-    PhotoAlbumSubType subType = context->subType;
-    Uri uri (uriStr);
-    if (subType == PhotoAlbumSubType::HIGHLIGHT) {
-        predicates.EqualTo(HIGHLIGHT_ALBUM_TABLE + "." + PhotoAlbumColumns::ALBUM_ID, to_string(albumId));
-    } else if (subType == PhotoAlbumSubType::HIGHLIGHT_SUGGESTIONS) {
-        predicates.EqualTo(HIGHLIGHT_ALBUM_TABLE + "." + AI_ALBUM_ID, to_string(albumId));
-    } else {
-        NAPI_ERR_LOG("Invalid highlight album subType");
-        return;
-    }
     int errCode = 0;
-    auto resultSet = UserFileClient::Query(uri, predicates, fetchColumn, errCode);
+    GetHighlightAlbumReqBody reqBody;
+    reqBody.highlightAlbumInfoType = context->highlightAlbumInfoType;
+    reqBody.albumId = context->albumId;
+    reqBody.subType = static_cast<int32_t>(context->subType);
+    QueryResultRspBody rspBody;
+    errCode = IPC::UserDefineIPCClient().Call(
+        static_cast<uint32_t>(MediaLibraryBusinessCode::GET_HIGHLIGHT_ALBUM_INFO), reqBody, rspBody);
+    shared_ptr<DataShare::DataShareResultSet> resultSet = rspBody.resultSet;
     if (resultSet != nullptr) {
         context->highlightAlbumInfo = MediaLibraryNapiUtils::ParseResultSet2JsonStr(resultSet, fetchColumn);
     }
@@ -1314,49 +1300,23 @@ static void JSGetOrderPositionExecute(napi_env env, void *data)
     auto *context = static_cast<HighlightAlbumNapiAsyncContext *>(data);
     CHECK_NULL_PTR_RETURN_VOID(context, "Async context is null");
 
-    // make fetch column
-    std::vector<std::string> fetchColumn{MAP_ASSET, ORDER_POSITION};
-
-    // make where predicates
-    DataShare::DataSharePredicates predicates;
-    const std::vector<std::string> &assetIdArray = context->assetIdArray;
-    CHECK_NULL_PTR_RETURN_VOID(context->objectInfo, "objectInfo is null");
     auto photoAlbum = context->objectInfo->GetPhotoAlbumInstance();
-    CHECK_NULL_PTR_RETURN_VOID(photoAlbum, "photoAlbum is null");
-    int albumId = photoAlbum->GetAlbumId();
-    const string mapTable = ANALYSIS_PHOTO_MAP_TABLE;
-    predicates.EqualTo(mapTable + "." + MAP_ALBUM, albumId)->And()->In(mapTable + "." + MAP_ASSET, assetIdArray);
 
-    // start query, deal with result
-    Uri uri(PAH_QUERY_ORDER_ANA_ALBUM);
-    int errCode = 0;
-    auto resultSet = UserFileClient::Query(uri, predicates, fetchColumn, errCode);
-    if (resultSet == nullptr) {
-        NAPI_ERR_LOG("Query failed, error code: %{public}d", errCode);
-        context->error = JS_INNER_FAIL;
-        return;
+    GetOrderPositionRespBody respBody;
+    GetOrderPositionReqBody reqBody;
+    reqBody.albumId = photoAlbum->GetAlbumId();
+    reqBody.albumType = photoAlbum->GetPhotoAlbumType();
+    reqBody.albumSubType = photoAlbum->GetPhotoAlbumSubType();
+    reqBody.assetIdArray = context->assetIdArray;
+    uint32_t businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_GET_ORDER_POSITION);
+
+    int32_t ret = IPC::UserDefineIPCClient().Call(businessCode, reqBody, respBody);
+    if (ret == E_OK) {
+        context->orderPositionArray.clear();
+        context->orderPositionArray = respBody.orderPositionArray;
     }
-    int count = 0;
-    int ret = resultSet->GetRowCount(count);
-    if (ret != NativeRdb::E_OK || count <= 0) {
-        NAPI_ERR_LOG("GetRowCount failed, error code: %{public}d, count: %{public}d", ret, count);
-        context->error = JS_INNER_FAIL;
-        return;
-    }
-    unordered_map<std::string, int32_t> idOrderMap;
-    while (resultSet->GoToNextRow() == NativeRdb::E_OK) {
-        int32_t mapAsset = get<int32_t>(ResultSetUtils::GetValFromColumn(MAP_ASSET, resultSet, TYPE_INT32));
-        int32_t orderPosition = get<int32_t>(ResultSetUtils::GetValFromColumn(ORDER_POSITION, resultSet, TYPE_INT32));
-        idOrderMap[std::to_string(mapAsset)] = orderPosition;
-    }
-    context->orderPositionArray.clear();
-    for (string& assetId : context->assetIdArray) {
-        context->orderPositionArray.push_back(idOrderMap[assetId]);
-    }
-    NAPI_INFO_LOG("GetOrderPosition: result size: %{public}d, orderPositionArray size: %{public}d",
-                  count,
-                  static_cast<int>(context->orderPositionArray.size())
-                  );
+    NAPI_INFO_LOG("GetOrderPosition: orderPositionArray size: %{public}d",
+                  static_cast<int>(context->orderPositionArray.size()));
 }
 
 static void JSGetOrderPositionCompleteCallback(napi_env env, napi_status status, void *data)
diff --git a/frameworks/js/src/media_asset_change_request_napi.cpp b/frameworks/js/src/media_asset_change_request_napi.cpp
index a9d9da35e1..df7e288ed1 100644
--- a/frameworks/js/src/media_asset_change_request_napi.cpp
+++ b/frameworks/js/src/media_asset_change_request_napi.cpp
@@ -2199,7 +2199,6 @@ static bool SetFavoriteExecute(MediaAssetChangeRequestAsyncContext &context)
 
     auto changeRequest = context.objectInfo;
     CHECK_COND_RET(changeRequest != nullptr, false, "changeRequest is nullptr");
-    CHECK_COND_RET(changeRequest != nullptr, false, "changeRequest is nullptr");
     auto fileAsset = changeRequest->GetFileAssetInstance();
     CHECK_COND_RET(fileAsset != nullptr, false, "fileAsset is nullptr");
     NAPI_INFO_LOG(
diff --git a/frameworks/js/src/media_asset_manager_napi.cpp b/frameworks/js/src/media_asset_manager_napi.cpp
index 97065d9bc7..30c6fddbd8 100644
--- a/frameworks/js/src/media_asset_manager_napi.cpp
+++ b/frameworks/js/src/media_asset_manager_napi.cpp
@@ -25,6 +25,7 @@
 
 #include "access_token.h"
 #include "accesstoken_kit.h"
+#include "adapted_vo.h"
 #include "dataobs_mgr_client.h"
 #include "directory_ex.h"
 #include "file_asset_napi.h"
@@ -35,6 +36,7 @@
 #include "media_column.h"
 #include "media_file_utils.h"
 #include "media_file_uri.h"
+#include "medialibrary_business_code.h"
 #include "medialibrary_client_errno.h"
 #include "media_library_napi.h"
 #include "medialibrary_errno.h"
@@ -46,9 +48,13 @@
 #include "moving_photo_call_transcoder.h"
 #include "permission_utils.h"
 #include "picture_handle_client.h"
+#include "query_photo_vo.h"
 #include "ui_extension_context.h"
+#include "user_define_ipc_client.h"
 #include "userfile_client.h"
 #include "media_call_transcode.h"
+#include "medialibrary_operation.h"
+#include "media_asset_rdbstore.h"
 
 using namespace OHOS::Security::AccessToken;
 
@@ -67,6 +73,9 @@ const int32_t MAX_URI_SIZE = 384; // 256 for display name and 128 for relative p
 
 const std::string HIGH_TEMPERATURE = "high_temperature";
 
+static const std::string URI_TPYE = "uriType";
+static const std::string TPYE_PHOTOS = "1";
+
 thread_local unique_ptr<ChangeListenerNapi> g_multiStagesRequestListObj = nullptr;
 thread_local napi_ref constructor_ = nullptr;
 
@@ -311,7 +320,7 @@ static void DeleteDataHandler(NotifyMode notifyMode, const std::string &requestU
     inProcessFastRequests.Erase(requestId);
 }
 
-MultiStagesCapturePhotoStatus MediaAssetManagerNapi::QueryPhotoStatus(int fileId,
+static MultiStagesCapturePhotoStatus QueryViaSandBox(int fileId,
     const string& photoUri, std::string &photoId, bool hasReadPermission, int32_t userId)
 {
     photoId = "";
@@ -327,24 +336,57 @@ MultiStagesCapturePhotoStatus MediaAssetManagerNapi::QueryPhotoStatus(int fileId
     }
     Uri uri(queryUri);
     int errCode = 0;
-    auto resultSet = UserFileClient::Query(uri, predicates, fetchColumn, errCode, userId);
-    if (resultSet == nullptr || resultSet->GoToFirstRow() != E_OK) {
-        NAPI_ERR_LOG("query resultSet is nullptr");
+    OperationObject object = OperationObject::UNKNOWN_OBJECT;
+    if (MediaAssetRdbStore::GetInstance()->IsQueryAccessibleViaSandBox(uri, object, predicates) && userId == -1) {
+        shared_ptr<DataShare::DataShareResultSet> resultSet = MediaAssetRdbStore::GetInstance()->Query(
+            predicates, fetchColumn, object, errCode);
+        if (resultSet == nullptr || resultSet->GoToFirstRow() != E_OK) {
+            NAPI_ERR_LOG("query resultSet is nullptr");
+            return MultiStagesCapturePhotoStatus::HIGH_QUALITY_STATUS;
+        }
+        int indexOfPhotoId = -1;
+        resultSet->GetColumnIndex(PhotoColumn::PHOTO_ID, indexOfPhotoId);
+        resultSet->GetString(indexOfPhotoId, photoId);
+
+        int columnIndexQuality = -1;
+        resultSet->GetColumnIndex(PhotoColumn::PHOTO_QUALITY, columnIndexQuality);
+        int currentPhotoQuality = HIGH_QUALITY_IMAGE;
+        resultSet->GetInt(columnIndexQuality, currentPhotoQuality);
+        if (currentPhotoQuality == LOW_QUALITY_IMAGE) {
+            NAPI_INFO_LOG("query photo status : lowQuality");
+            return MultiStagesCapturePhotoStatus::LOW_QUALITY_STATUS;
+        }
+        NAPI_INFO_LOG("query photo status quality: %{public}d", currentPhotoQuality);
+        return MultiStagesCapturePhotoStatus::HIGH_QUALITY_STATUS;
+    } else {
+        return MultiStagesCapturePhotoStatus::QUERY_INNER_FAIL;
+    }
+}
+
+MultiStagesCapturePhotoStatus MediaAssetManagerNapi::QueryPhotoStatus(int fileId,
+    const string& photoUri, std::string &photoId, bool hasReadPermission, int32_t userId)
+{
+    MultiStagesCapturePhotoStatus status = QueryViaSandBox(fileId, photoUri, photoId, hasReadPermission, userId);
+    if (status != MultiStagesCapturePhotoStatus::QUERY_INNER_FAIL) {
+        return status;
+    }
+    QueryPhotoReqBody reqBody;
+    reqBody.fileId = std::to_string(fileId);
+    QueryPhotoRspBody rspBody;
+    std::unordered_map<std::string, std::string> headerMap {
+        {MediaColumn::MEDIA_ID, reqBody.fileId }, {URI_TPYE, TPYE_PHOTOS}};
+    int ret = IPC::UserDefineIPCClient().SetUserId(userId).SetHeader(headerMap).Call(
+        static_cast<uint32_t>(MediaLibraryBusinessCode::QUERY_PHOTO_STATUS), reqBody, rspBody);
+    if (ret < 0) {
+        NAPI_ERR_LOG("ret = %{public}d", ret);
         return MultiStagesCapturePhotoStatus::HIGH_QUALITY_STATUS;
     }
-    int indexOfPhotoId = -1;
-    resultSet->GetColumnIndex(PhotoColumn::PHOTO_ID, indexOfPhotoId);
-    resultSet->GetString(indexOfPhotoId, photoId);
-
-    int columnIndexQuality = -1;
-    resultSet->GetColumnIndex(PhotoColumn::PHOTO_QUALITY, columnIndexQuality);
-    int currentPhotoQuality = HIGH_QUALITY_IMAGE;
-    resultSet->GetInt(columnIndexQuality, currentPhotoQuality);
-    if (currentPhotoQuality == LOW_QUALITY_IMAGE) {
+    photoId = rspBody.photoId;
+    if (rspBody.photoQuality == LOW_QUALITY_IMAGE) {
         NAPI_INFO_LOG("query photo status : lowQuality");
         return MultiStagesCapturePhotoStatus::LOW_QUALITY_STATUS;
     }
-    NAPI_INFO_LOG("query photo status quality: %{public}d", currentPhotoQuality);
+    NAPI_INFO_LOG("query photo status quality: %{public}d", rspBody.photoQuality);
     return MultiStagesCapturePhotoStatus::HIGH_QUALITY_STATUS;
 }
 
@@ -1991,7 +2033,10 @@ void MediaAssetManagerNapi::JSRequestExecute(napi_env env, void *data)
         DataShare::DataShareValuesBucket valuesBucket;
         string result;
         valuesBucket.Put("adapted", context->returnDataType == ReturnDataType::TYPE_MOVING_PHOTO);
-        UserFileClient::InsertExt(logMovingPhotoUri, valuesBucket, result, context->userId);
+        AdaptedReqBody reqBody;
+        reqBody.adapted = context->returnDataType == ReturnDataType::TYPE_MOVING_PHOTO;
+        IPC::UserDefineIPCClient().SetUserId(context->userId).Call(
+            static_cast<uint32_t>(MediaLibraryBusinessCode::LOG_MOVING_PHOTO), reqBody);
     }
 }
 
diff --git a/frameworks/js/src/media_assets_change_request_napi.cpp b/frameworks/js/src/media_assets_change_request_napi.cpp
index 7263db60f7..7f61be6193 100644
--- a/frameworks/js/src/media_assets_change_request_napi.cpp
+++ b/frameworks/js/src/media_assets_change_request_napi.cpp
@@ -308,8 +308,8 @@ static bool CallSetAssetProperty(MediaAssetsChangeRequestAsyncContext& context,
     changeRequest->GetFileAssetIds(reqBody.fileIds);
     int32_t result = IPC::UserDefineIPCClient().Call(businessCode, reqBody);
     if (result < 0) {
+        NAPI_ERR_LOG("after IPC::UserDefineIPCClient().Call, errCode: %{public}d.", result);
         context.SaveError(result);
-        NAPI_ERR_LOG("Failed to set property, operation: %{public}d, err: %{public}d", changeOperation, result);
         return false;
     }
     return true;
diff --git a/frameworks/js/src/media_library_napi.cpp b/frameworks/js/src/media_library_napi.cpp
index 114e4ba591..a86e98216a 100644
--- a/frameworks/js/src/media_library_napi.cpp
+++ b/frameworks/js/src/media_library_napi.cpp
@@ -103,6 +103,14 @@
 #include "cancel_photo_uri_permission_vo.h"
 #include "start_thumbnail_creation_task_vo.h"
 #include "stop_thumbnail_creation_task_vo.h"
+#include "get_index_construct_progress_vo.h"
+#include "get_assets_vo.h"
+#include "query_albums_vo.h"
+#include "get_albums_by_ids_vo.h"
+#include "start_asset_analysis_vo.h"
+#include "get_photo_index_vo.h"
+#include "query_result_vo.h"
+#include "get_analysis_process_vo.h"
 
 using namespace std;
 using namespace OHOS::AppExecFwk;
@@ -373,8 +381,8 @@ napi_value MediaLibraryNapi::PhotoAccessHelperInit(napi_env env, napi_value expo
             DECLARE_NAPI_FUNCTION("release", JSRelease),
             DECLARE_NAPI_FUNCTION("createAlbum", PhotoAccessCreatePhotoAlbum),
             DECLARE_NAPI_FUNCTION("deleteAlbums", PhotoAccessDeletePhotoAlbums),
-            DECLARE_NAPI_FUNCTION("getAlbums", PhotoAccessGetPhotoAlbums),
-            DECLARE_NAPI_FUNCTION("getAlbumsByIds", PhotoAccessGetPhotoAlbums),
+            DECLARE_NAPI_FUNCTION("getAlbums", PahGetAlbums),
+            DECLARE_NAPI_FUNCTION("getAlbumsByIds", PhotoAccessGetPhotoAlbumsByIds),
             DECLARE_NAPI_FUNCTION("getPhotoIndex", PhotoAccessGetPhotoIndex),
             DECLARE_NAPI_FUNCTION("getIndexConstructProgress", PhotoAccessGetIndexConstructProgress),
             DECLARE_NAPI_FUNCTION("setHidden", SetHidden),
@@ -1992,13 +2000,13 @@ static void JSPhotoUriPermissionCallback(napi_env env, napi_status status, void
 {
     MediaLibraryTracer tracer;
     tracer.Start("JSPhotoUriPermissionCallback");
- 
+
     MediaLibraryAsyncContext *context = static_cast<MediaLibraryAsyncContext*>(data);
     CHECK_NULL_PTR_RETURN_VOID(context, "Async context is null");
- 
+
     unique_ptr<JSAsyncContextOutput> jsContext = make_unique<JSAsyncContextOutput>();
     jsContext->status = false;
- 
+
     CHECK_ARGS_RET_VOID(env, napi_get_undefined(env, &jsContext->error), JS_INNER_FAIL);
     if (context->error != ERR_DEFAULT) {
         context->HandleError(env, jsContext->error);
@@ -2008,7 +2016,7 @@ static void JSPhotoUriPermissionCallback(napi_env env, napi_status status, void
         CHECK_ARGS_RET_VOID(env, napi_get_undefined(env, &jsContext->error), JS_INNER_FAIL);
         jsContext->status = true;
     }
- 
+
     tracer.Finish();
     if (context->work != nullptr) {
         MediaLibraryNapiUtils::InvokeJSAsyncMethod(env, context->deferred, context->callbackRef,
@@ -2898,7 +2906,7 @@ void ChangeListenerNapi::QueryRdbAndNotifyChange(uv_loop_s *loop, UvChangeMsg *m
         delete work;
     }
 }
- 
+
 int ChangeListenerNapi::UvQueueWork(uv_loop_s *loop, uv_work_t *work)
 {
     return uv_queue_work(loop, work, [](uv_work_t *w) {}, [](uv_work_t *w, int s) {
@@ -2919,7 +2927,7 @@ int ChangeListenerNapi::UvQueueWork(uv_loop_s *loop, uv_work_t *work)
             if (!scopeHandler.IsValid()) {
                 break;
             }
- 
+
             napi_value jsCallback = nullptr;
             napi_status status = napi_get_reference_value(env, msg->ref_, &jsCallback);
             if (status != napi_ok) {
@@ -3858,25 +3866,28 @@ napi_value MediaLibraryNapi::JSGetSmartAlbums(napi_env env, napi_callback_info i
     return result;
 }
 
-static napi_value AddDefaultPhotoAlbumColumns(napi_env env, vector<string> &fetchColumn)
+static bool CheckAlbumFetchColumns(const vector<string> &fetchColumn)
 {
-    auto validFetchColumns = PhotoAlbumColumns::DEFAULT_FETCH_COLUMNS;
     for (const auto &column : fetchColumn) {
-        if (PhotoAlbumColumns::IsPhotoAlbumColumn(column)) {
-            validFetchColumns.insert(column);
-        } else if (column.compare(MEDIA_DATA_DB_URI) == 0) {
-            // uri is default property of album
-            continue;
-        } else {
-            NapiError::ThrowError(env, JS_ERR_PARAMETER_INVALID);
-            return nullptr;
+        if (!PhotoAlbumColumns::IsPhotoAlbumColumn(column) && column.compare(MEDIA_DATA_DB_URI) != 0) {
+            return false;
         }
     }
-    fetchColumn.assign(validFetchColumns.begin(), validFetchColumns.end());
+    return true;
+}
 
-    napi_value result = nullptr;
-    CHECK_ARGS(env, napi_get_boolean(env, true, &result), JS_INNER_FAIL);
-    return result;
+static void AddDefaultPhotoAlbumColumns(vector<string> &fetchColumn)
+{
+    auto columns = PhotoAlbumColumns::DEFAULT_FETCH_COLUMNS;
+    for (const auto &column : fetchColumn) {
+        if (column.compare(MEDIA_DATA_DB_URI) == 0) {
+            continue;
+        }
+        if (columns.count(column) == 0) {
+            columns.insert(column);
+        }
+    }
+    fetchColumn.assign(columns.begin(), columns.end());
 }
 
 static void AddDefaultColumnsForNonAnalysisAlbums(MediaLibraryAsyncContext& context)
@@ -3985,7 +3996,8 @@ napi_value ParseArgsGetPrivateAlbum(napi_env env, napi_callback_info info,
     }
     context->predicates.EqualTo(PhotoAlbumColumns::ALBUM_TYPE, to_string(PhotoAlbumType::SYSTEM));
     context->predicates.EqualTo(PhotoAlbumColumns::ALBUM_SUBTYPE, to_string(subType));
-    CHECK_NULLPTR_RET(AddDefaultPhotoAlbumColumns(env, context->fetchColumn));
+    CHECK_COND(env, CheckAlbumFetchColumns(context->fetchColumn), JS_ERR_PARAMETER_INVALID);
+    AddDefaultPhotoAlbumColumns(context->fetchColumn);
 
     napi_value result = nullptr;
     CHECK_ARGS(env, napi_get_boolean(env, true, &result), JS_INNER_FAIL);
@@ -5211,7 +5223,7 @@ static napi_value ParseArgsGrantPhotoUriPermissionInner(napi_env env, napi_callb
     int32_t fileId = MediaLibraryNapiUtils::GetFileIdFromPhotoUri(uri);
     NAPI_ASSERT(env, fileId >= 0, "Invalid uri");
     context->valuesBucket.Put(AppUriPermissionColumn::FILE_ID, fileId);
- 
+
     // parse permissionType
     int32_t permissionType;
     NAPI_ASSERT(env, ParsePermissionType(env, context->argv[ARGS_TWO], permissionType) ==
@@ -5226,7 +5238,7 @@ static napi_value ParseArgsGrantPhotoUriPermissionInner(napi_env env, napi_callb
 
     // parsing fileId ensured uri is photo.
     context->valuesBucket.Put(AppUriPermissionColumn::URI_TYPE, AppUriPermissionColumn::URI_PHOTO);
- 
+
     napi_value result = nullptr;
     NAPI_CALL(env, napi_get_boolean(env, true, &result));
     return result;
@@ -5239,14 +5251,14 @@ static napi_value ParseArgsGrantPhotoUriPermission(napi_env env, napi_callback_i
     constexpr size_t maxArgs = ARGS_FOUR;
     NAPI_ASSERT(env, MediaLibraryNapiUtils::AsyncContextSetObjectInfo(env, info, context, minArgs, maxArgs) ==
         napi_ok, "Failed to get object info");
-    
+
     context->isCreateByComponent = false;
     context->needSystemApp = true;
     if (!MediaLibraryNapiUtils::IsSystemApp()) {
         NapiError::ThrowError(env, E_CHECK_SYSTEMAPP_FAIL, "This interface can be called only by system apps");
         return nullptr;
     }
-    
+
     return ParseArgsGrantPhotoUriPermissionInner(env, info, context);
 }
 
@@ -5280,7 +5292,7 @@ static napi_value ParseArgsGrantPhotoUrisForForceSensitive(napi_env env, napi_ca
     constexpr size_t maxArgs = ARGS_TWO;
     NAPI_ASSERT(env, MediaLibraryNapiUtils::AsyncContextSetObjectInfo(env, info, context, minArgs, maxArgs) ==
         napi_ok, "Failed to get object info");
-    
+
     context->isCreateByComponent = false;
     context->needSystemApp = true;
     if (!MediaLibraryNapiUtils::IsSystemApp()) {
@@ -5292,19 +5304,19 @@ static napi_value ParseArgsGrantPhotoUrisForForceSensitive(napi_env env, napi_ca
     uint32_t tokenId = IPCSkeleton::GetCallingTokenID();
     context->valuesBucket.Put(AppUriSensitiveColumn::SOURCE_TOKENID, static_cast<int64_t>(tokenId));
     context->valuesBucket.Put(AppUriSensitiveColumn::TARGET_TOKENID, static_cast<int64_t>(tokenId));
- 
+
     // parse uris
     vector<string> uris;
     NAPI_ASSERT(env, ParseGrantMediaUris(env, context->argv[ARGS_ZERO], uris) ==
         napi_ok, "Invalid uri");
- 
+
     // parse hideSensitiveType
     int32_t hideSensitiveType;
     NAPI_ASSERT(env, ParseHidenSensitiveType(env, context->argv[ARGS_ONE],
         hideSensitiveType) == napi_ok, "Invalid SensitiveType");
     context->valuesBucket.Put(AppUriSensitiveColumn::HIDE_SENSITIVE_TYPE, hideSensitiveType);
     NAPI_ASSERT(env, ParseUriTypes(uris, context) == napi_ok, "ParseUriTypes failed");
- 
+
     napi_value result = nullptr;
     NAPI_CALL(env, napi_get_boolean(env, true, &result));
     return result;
@@ -5315,7 +5327,7 @@ static napi_value ParseArgsGrantPhotoUrisPermission(napi_env env, napi_callback_
 {
     NAPI_ASSERT(env, MediaLibraryNapiUtils::AsyncContextSetObjectInfo(env, info, context, ARGS_ONE, ARGS_FOUR) ==
         napi_ok, "Failed to get object info");
-    
+
     context->isCreateByComponent = false;
     context->needSystemApp = true;
     if (!MediaLibraryNapiUtils::IsSystemApp()) {
@@ -5355,7 +5367,7 @@ static napi_value ParseArgsGrantPhotoUrisPermission(napi_env env, napi_callback_
     NAPI_CALL(env, napi_get_boolean(env, true, &result));
     return result;
 }
- 
+
 static napi_value ParseArgsCancelPhotoUriPermission(napi_env env, napi_callback_info info,
     unique_ptr<MediaLibraryAsyncContext> &context)
 {
@@ -5363,7 +5375,7 @@ static napi_value ParseArgsCancelPhotoUriPermission(napi_env env, napi_callback_
     constexpr size_t maxArgs = ARGS_THREE;
     NAPI_ASSERT(env, MediaLibraryNapiUtils::AsyncContextSetObjectInfo(env, info, context, minArgs, maxArgs) ==
         napi_ok, "Failed to get object info");
-    
+
     context->isCreateByComponent = false;
     context->needSystemApp = true;
     if (!MediaLibraryNapiUtils::IsSystemApp()) {
@@ -5375,7 +5387,7 @@ static napi_value ParseArgsCancelPhotoUriPermission(napi_env env, napi_callback_
     NAPI_ASSERT(env, ParseTokenId(env, context->argv[ARGS_ZERO], tokenId) ==
         napi_ok, "Invalid args[0]");
     context->valuesBucket.Put(AppUriPermissionColumn::TARGET_TOKENID, static_cast<int64_t>(tokenId));
-    
+
     //get caller tokenid
     uint32_t callerTokenId = IPCSkeleton::GetCallingTokenID();
     context->valuesBucket.Put(AppUriSensitiveColumn::SOURCE_TOKENID, static_cast<int64_t>(callerTokenId));
@@ -5724,7 +5736,7 @@ static napi_value ParseArgsGetBurstAssets(napi_env env, napi_callback_info info,
     /* Parse the second argument */
     CHECK_ARGS(env, MediaLibraryNapiUtils::GetFetchOption(env, context->argv[PARAM1], ASSET_FETCH_OPT, context),
         JS_INNER_FAIL);
-    
+
     auto &predicates = context->predicates;
     if (context->assetType != TYPE_PHOTO) {
         return nullptr;
@@ -5735,6 +5747,7 @@ static napi_value ParseArgsGetBurstAssets(napi_env env, napi_callback_info info,
     predicates.And()->EqualTo(MediaColumn::MEDIA_TIME_PENDING, to_string(0));
     predicates.And()->EqualTo(PhotoColumn::PHOTO_IS_TEMP, to_string(0));
     predicates.OrderByAsc(MediaColumn::MEDIA_NAME);
+    context->burstKey = burstKey;
 
     napi_value result = nullptr;
     CHECK_ARGS(env, napi_get_boolean(env, true, &result), JS_INNER_FAIL);
@@ -5876,8 +5889,19 @@ static void GetPhotoIndexExec(napi_env env, void *data, ResultNapiType type)
     MediaLibraryNapiUtils::UriAppendKeyValue(queryUri, API_VERSION, to_string(MEDIA_API_VERSION_V10));
     Uri uri(queryUri);
     int errCode = 0;
-    auto resultSet = UserFileClient::Query(uri, context->predicates, context->fetchColumn, errCode,
-        context->userId);
+    if (context->fetchColumn.size() < 2) { // 2: photoId, albumId
+        context->SaveError(E_ERR);
+        return;
+    }
+    GetPhotoIndexReqBody reqBody;
+    reqBody.predicates = context->predicates;
+    reqBody.photoId = context->fetchColumn[0];
+    reqBody.albumId = context->fetchColumn[1];
+    reqBody.isAnalysisAlbum = context->isAnalysisAlbum;
+    QueryResultRspBody rspBody;
+    errCode = IPC::UserDefineIPCClient().SetUserId(context->userId).Call(
+        static_cast<uint32_t>(MediaLibraryBusinessCode::GET_PHOTO_INDEX), reqBody, rspBody);
+    auto resultSet = rspBody.resultSet;
     if (resultSet == nullptr) {
         NAPI_ERR_LOG("resultSet is nullptr");
         context->SaveError(errCode);
@@ -5944,80 +5968,21 @@ static void GetIndexConstructProgressAsyncCallbackComplete(napi_env env, napi_st
     delete context;
 }
 
-static bool GetProgressStr(const shared_ptr<DataShare::DataShareResultSet> &resultSet, string &progress)
-{
-    const vector<string> columns = {
-        PHOTO_COMPLETE_NUM,
-        PHOTO_TOTAL_NUM,
-        VIDEO_COMPLETE_NUM,
-        VIDEO_TOTAL_NUM
-    };
-    int32_t index = 0;
-    string value = "";
-    progress = "{";
-    for (const auto &item : columns) {
-        if (resultSet->GetColumnIndex(item, index) != DataShare::E_OK) {
-            NAPI_ERR_LOG("ResultSet GetColumnIndex failed, progressObject=%{public}s", item.c_str());
-            return false;
-        }
-        if (resultSet->GetString(index, value) != DataShare::E_OK) {
-            NAPI_ERR_LOG("ResultSet GetString failed, progressObject=%{public}s", item.c_str());
-            return false;
-        }
-        progress += "\"" + item + "\":" + value + ",";
-    }
-    progress = progress.substr(0, progress.length() - 1);
-    progress += "}";
-    NAPI_DEBUG_LOG("GetProgressStr progress=%{public}s", progress.c_str());
-    return true;
-}
-
-static bool GetProgressFromResultSet(const shared_ptr<DataShare::DataShareResultSet> &resultSet, string &progress)
-{
-    if (resultSet == nullptr) {
-        NAPI_ERR_LOG("ResultSet is null");
-        return false;
-    }
-    int32_t count = 0;
-    int32_t errCode = resultSet->GetRowCount(count);
-    if (errCode != DataShare::E_OK) {
-        NAPI_ERR_LOG("Can not get row count from resultSet, errCode=%{public}d", errCode);
-        return false;
-    }
-    if (count == 0) {
-        NAPI_ERR_LOG("Can not find index construction progress");
-        return false;
-    }
-    errCode = resultSet->GoToFirstRow();
-    if (errCode != DataShare::E_OK) {
-        NAPI_ERR_LOG("ResultSet GotoFirstRow failed, errCode=%{public}d", errCode);
-        return false;
-    }
-
-    return GetProgressStr(resultSet, progress);
-}
-
 static void PhotoAccessGetIndexConstructProgressExec(napi_env env, void *data)
 {
-    auto *context = static_cast<MediaLibraryAsyncContext*>(data);
-    auto jsContext = make_unique<JSAsyncContextOutput>();
-    jsContext->status = false;
-    string queryUri = MEDIALIBRARY_DATA_URI + "/" + SEARCH_INDEX_CONSTRUCTION_STATUS + "/" + OPRN_QUERY;
-    MediaLibraryNapiUtils::UriAppendKeyValue(queryUri, API_VERSION, to_string(MEDIA_API_VERSION_V10));
-    Uri uri(queryUri);
-    int errCode = 0;
-    string indexProgress;
-    auto resultSet = UserFileClient::Query(uri, context->predicates, context->fetchColumn, errCode,
-        context->userId);
-    if (!GetProgressFromResultSet(resultSet, indexProgress)) {
-        if (errCode == E_PERMISSION_DENIED) {
-            context->error = OHOS_PERMISSION_DENIED_CODE;
-        } else {
-            context->SaveError(E_FAIL);
-        }
-    } else {
-        context->indexProgress = indexProgress;
+    auto *context = static_cast<MediaLibraryAsyncContext *>(data);
+    CHECK_IF_EQUAL(context != nullptr, "context is nullptr");
+
+    uint32_t businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::GET_INDEX_CONSTRUCT_PROGRESS);
+    GetIndexConstructProgressRespBody respBody;
+    int32_t errCode = IPC::UserDefineIPCClient().SetUserId(context->userId).Get(businessCode, respBody);
+
+    if (errCode != E_OK) {
+        NAPI_ERR_LOG("get index construct progress failed, errCode is %{public}d", errCode);
+        context->SaveError(errCode);
+        return;
     }
+    context->indexProgress = respBody.indexProgress;
 }
 
 napi_value MediaLibraryNapi::PhotoAccessGetIndexConstructProgress(napi_env env, napi_callback_info info)
@@ -6058,7 +6023,7 @@ static napi_status ParseUpdateGalleryFormInfoOption(napi_env env, napi_value arg
 {
     const std::string formIdKey = "formId";
     const std::string assetUrisKey = "assetUris";
- 
+
     bool formIdPresent = false;
     napi_status result = napi_has_named_property(env, arg, formIdKey.c_str(), &formIdPresent);
     CHECK_COND_RET(result == napi_ok, result, "failed to check formId property");
@@ -6077,7 +6042,7 @@ static napi_status ParseUpdateGalleryFormInfoOption(napi_env env, napi_value arg
         return napi_invalid_arg;
     }
     context.formId = formId;
- 
+
     bool urisPresent = false;
     result = napi_has_named_property(env, arg, assetUrisKey.c_str(), &urisPresent);
     CHECK_COND_RET(result == napi_ok, result, "failed to check uris property");
@@ -6097,7 +6062,7 @@ static napi_status ParseUpdateGalleryFormInfoOption(napi_env env, napi_value arg
     if (arrayLength == 0) {
         return napi_invalid_arg;
     }
-    
+
     for (uint32_t i = 0; i < arrayLength; ++i) {
         napi_value uriValue;
         result = napi_get_element(env, urisValue, i, &uriValue);
@@ -6114,12 +6079,12 @@ static napi_status ParseUpdateGalleryFormInfoOption(napi_env env, napi_value arg
     }
     return napi_ok;
 }
- 
+
 static napi_status ParseSaveGalleryFormInfoOption(napi_env env, napi_value arg, MediaLibraryAsyncContext &context)
 {
     const std::string formIdKey = "formId";
     const std::string assetUrisKey = "assetUris";
- 
+
     bool formIdPresent = false;
     napi_status result = napi_has_named_property(env, arg, formIdKey.c_str(), &formIdPresent);
     CHECK_COND_RET(result == napi_ok, result, "failed to check formId property");
@@ -6127,21 +6092,21 @@ static napi_status ParseSaveGalleryFormInfoOption(napi_env env, napi_value arg,
         NAPI_ERR_LOG("ParseSaveGalleryFormInfoOption formIdPresent is false");
         return napi_invalid_arg;
     }
- 
+
     napi_value formIdValue;
     result = napi_get_named_property(env, arg, formIdKey.c_str(), &formIdValue);
     CHECK_COND_RET(result == napi_ok, result, "failed to get formId property");
- 
+
     char formIdBuffer[ARG_BUF_SIZE];
     size_t formIdLength = 0;
     result = napi_get_value_string_utf8(env, formIdValue, formIdBuffer, ARG_BUF_SIZE, &formIdLength);
     CHECK_COND_RET(result == napi_ok, result, "failed to get formId string");
- 
+
     std::string formId = std::string(formIdBuffer);
     if (CheckFormId(formId) != napi_ok) {
         return napi_invalid_arg;
     }
-    
+
     bool urisPresent = false;
     result = napi_has_named_property(env, arg, assetUrisKey.c_str(), &urisPresent);
     CHECK_COND_RET(result == napi_ok, result, "failed to check uris property");
@@ -6149,15 +6114,15 @@ static napi_status ParseSaveGalleryFormInfoOption(napi_env env, napi_value arg,
         NAPI_ERR_LOG("ParseSaveGalleryFormInfoOption urisPresent is false");
         return napi_invalid_arg;
     }
- 
+
     napi_value urisValue;
     result = napi_get_named_property(env, arg, assetUrisKey.c_str(), &urisValue);
     CHECK_COND_RET(result == napi_ok, result, "failed to get uris property");
- 
+
     bool isArray = false;
     result = napi_is_array(env, urisValue, &isArray);
     CHECK_COND_RET(result == napi_ok && isArray, napi_invalid_arg, "uris is not an array");
- 
+
     uint32_t arrayLength = 0;
     result = napi_get_array_length(env, urisValue, &arrayLength);
     CHECK_COND_RET(result == napi_ok, result, "failed to get array length");
@@ -6169,7 +6134,7 @@ static napi_status ParseSaveGalleryFormInfoOption(napi_env env, napi_value arg,
         napi_value uriValue;
         result = napi_get_element(env, urisValue, i, &uriValue);
         CHECK_COND_RET(result == napi_ok, result, "failed to get array element");
- 
+
         char uriBuffer[ARG_BUF_SIZE];
         size_t uriLength = 0;
         result = napi_get_value_string_utf8(env, uriValue, uriBuffer, ARG_BUF_SIZE, &uriLength);
@@ -6223,7 +6188,7 @@ static napi_value ParseArgsUpdateGalleryFormInfo(napi_env env, napi_callback_inf
     constexpr size_t maxArgs = ARGS_TWO;
     CHECK_COND_WITH_MESSAGE(env, MediaLibraryNapiUtils::AsyncContextSetObjectInfo(env, info, context, minArgs,
         maxArgs) == napi_ok, "Failed to get object info");
- 
+
     if (!MediaLibraryNapiUtils::IsSystemApp()) {
         NapiError::ThrowError(env, E_CHECK_SYSTEMAPP_FAIL, "This interface can be called only by system apps");
         return nullptr;
@@ -6231,12 +6196,12 @@ static napi_value ParseArgsUpdateGalleryFormInfo(napi_env env, napi_callback_inf
 
     CHECK_COND_WITH_MESSAGE(env, ParseUpdateGalleryFormInfoOption(env, context->argv[ARGS_ZERO], *context) == napi_ok,
         "Parse formInfo Option failed");
- 
+
     napi_value result = nullptr;
     CHECK_ARGS(env, napi_get_boolean(env, true, &result), JS_INNER_FAIL);
     return result;
 }
- 
+
 static napi_value ParseArgsSaveGalleryFormInfo(napi_env env, napi_callback_info info,
     unique_ptr<MediaLibraryAsyncContext> &context)
 {
@@ -6252,7 +6217,7 @@ static napi_value ParseArgsSaveGalleryFormInfo(napi_env env, napi_callback_info
 
     CHECK_COND_WITH_MESSAGE(env, ParseSaveGalleryFormInfoOption(env, context->argv[ARGS_ZERO], *context) == napi_ok,
         "Parse formInfo Option failed");
- 
+
     napi_value result = nullptr;
     CHECK_ARGS(env, napi_get_boolean(env, true, &result), JS_INNER_FAIL);
     return result;
@@ -6369,7 +6334,7 @@ static napi_value ParseArgsRemoveGalleryFormInfo(napi_env env, napi_callback_inf
         NapiError::ThrowError(env, OHOS_INVALID_PARAM_CODE, "Failed to check empty formId!");
         return nullptr;
     }
- 
+
     napi_value value;
     CHECK_COND_WITH_MESSAGE(env, napi_get_named_property(env, context->argv[ARGS_ZERO], "formId", &value) == napi_ok,
         "failed to get named property");
@@ -6418,7 +6383,7 @@ static void UpdateGalleryFormInfoExec(napi_env env, void *data, ResultNapiType t
 {
     MediaLibraryTracer tracer;
     tracer.Start("UpdateGalleryFormInfoExec");
- 
+
     auto *context = static_cast<MediaLibraryAsyncContext*>(data);
     context->resultNapiType = type;
     vector<string> formIds;
@@ -6451,7 +6416,7 @@ static void RemoveGalleryFormInfoExec(napi_env env, void *data, ResultNapiType t
 {
     MediaLibraryTracer tracer;
     tracer.Start("RemoveGalleryFormInfoExec");
- 
+
     auto *context = static_cast<MediaLibraryAsyncContext*>(data);
     context->resultNapiType = type;
     string formId = context->formId;
@@ -6541,7 +6506,7 @@ static void PhotoAccessSaveGalleryFormInfoExec(napi_env env, void *data)
 {
     SaveGalleryFormInfoExec(env, data, ResultNapiType::TYPE_PHOTOACCESS_HELPER);
 }
- 
+
 napi_value MediaLibraryNapi::PhotoAccessSaveGalleryFormInfo(napi_env env, napi_callback_info info)
 {
     unique_ptr<MediaLibraryAsyncContext> asyncContext = make_unique<MediaLibraryAsyncContext>();
@@ -6561,12 +6526,12 @@ static void PhotoAccessRemoveGalleryFormInfoExec(napi_env env, void *data)
 {
     RemoveGalleryFormInfoExec(env, data, ResultNapiType::TYPE_PHOTOACCESS_HELPER);
 }
- 
+
 static void PhotoAccessUpdateGalleryFormInfoExec(napi_env env, void *data)
 {
     UpdateGalleryFormInfoExec(env, data, ResultNapiType::TYPE_PHOTOACCESS_HELPER);
 }
- 
+
 napi_value MediaLibraryNapi::PhotoAccessRemoveGalleryFormInfo(napi_env env, napi_callback_info info)
 {
     unique_ptr<MediaLibraryAsyncContext> asyncContext = make_unique<MediaLibraryAsyncContext>();
@@ -6576,7 +6541,7 @@ napi_value MediaLibraryNapi::PhotoAccessRemoveGalleryFormInfo(napi_env env, napi
     return MediaLibraryNapiUtils::NapiCreateAsyncWork(env, asyncContext, "PhotoAccessRemoveGalleryFormInfo",
         PhotoAccessRemoveGalleryFormInfoExec, RemoveFormInfoAsyncCallbackComplete);
 }
- 
+
 napi_value MediaLibraryNapi::PhotoAccessUpdateGalleryFormInfo(napi_env env, napi_callback_info info)
 {
     unique_ptr<MediaLibraryAsyncContext> asyncContext = make_unique<MediaLibraryAsyncContext>();
@@ -6610,7 +6575,7 @@ static napi_value ParseArgsStartCreateThumbnailTask(napi_env env,
     CHECK_COND_WITH_MESSAGE(env, context->callbackRef, "Can not get callback function");
     CHECK_ARGS(env, MediaLibraryNapiUtils::ParsePredicates(env,
         context->argv[PARAM0], context, ASSET_FETCH_OPT), JS_INNER_FAIL);
-    
+
     napi_value result = nullptr;
     CHECK_ARGS(env, napi_get_boolean(env, true, &result), JS_INNER_FAIL);
     return result;
@@ -6823,20 +6788,15 @@ napi_value MediaLibraryNapi::PhotoAccessStopCreateThumbnailTask(napi_env env, na
     RETURN_NAPI_UNDEFINED(env);
 }
 
-static void GetMediaAnalysisServiceProgress(nlohmann::json& jsonObj, unordered_map<int, string>& idxToCount,
-    vector<string> columns)
+static void GetMediaAnalysisServiceProgress(nlohmann::json& jsonObj, unordered_map<int, string>& idxToCount)
 {
-    Uri uri(URI_TOTAL);
-    string clause = VISION_TOTAL_TABLE + "." + MediaColumn::MEDIA_ID + " = " + PhotoColumn::PHOTOS_TABLE+ "." +
-        MediaColumn::MEDIA_ID;
-    DataShare::DataSharePredicates predicates;
-    predicates.InnerJoin(PhotoColumn::PHOTOS_TABLE)->On({ clause });
-    predicates.EqualTo(PhotoColumn::PHOTO_HIDDEN_TIME, 0)->And()
-        ->EqualTo(MediaColumn::MEDIA_DATE_TRASHED, 0)->And()
-        ->EqualTo(MediaColumn::MEDIA_TIME_PENDING, 0);
-
     int errCode = 0;
-    shared_ptr<DataShare::DataShareResultSet> ret = UserFileClient::Query(uri, predicates, columns, errCode);
+    GetAnalysisProcessReqBody reqBody;
+    reqBody.analysisType = AnalysisType::ANALYSIS_LABEL;
+    QueryResultRspBody rspBody;
+    errCode = IPC::UserDefineIPCClient().Call(
+        static_cast<uint32_t>(MediaLibraryBusinessCode::GET_ANALYSIS_PROCESS), reqBody, rspBody);
+    shared_ptr<DataShare::DataShareResultSet> ret = rspBody.resultSet;
     if (ret == nullptr) {
         NAPI_ERR_LOG("ret is nullptr");
         return;
@@ -6846,7 +6806,7 @@ static void GetMediaAnalysisServiceProgress(nlohmann::json& jsonObj, unordered_m
         ret->Close();
         return;
     }
-    for (size_t i = 0; i < columns.size(); ++i) {
+    for (size_t i = 0; i < idxToCount.size(); ++i) {
         int tmp = -1;
         ret->GetInt(i, tmp);
         jsonObj[idxToCount[i]] = tmp;
@@ -6859,15 +6819,8 @@ static std::string GetLabelAnalysisProgress()
     unordered_map<int, string> idxToCount = {
         {0, "totalCount"}, {1, "finishedCount"}, {2, "LabelCount"}
     };
-    vector<string> columns = {
-        "COUNT(*) AS totalCount",
-        "SUM(CASE WHEN ((aesthetics_score != 0 AND label != 0 AND ocr != 0 AND face != 0 AND face != 1 AND face != 2 "
-            "AND saliency != 0 AND segmentation != 0 AND head != 0 AND Photos.media_type = 1) OR "
-            "(label != 0 AND face != 0 AND Photos.media_type = 2)) THEN 1 ELSE 0 END) AS finishedCount",
-        "SUM(CASE WHEN label != 0 THEN 1 ELSE 0 END) AS LabelCount"
-    };
     nlohmann::json jsonObj;
-    GetMediaAnalysisServiceProgress(jsonObj, idxToCount, columns);
+    GetMediaAnalysisServiceProgress(jsonObj, idxToCount);
     NAPI_INFO_LOG("Progress json is %{public}s", jsonObj.dump().c_str());
     return jsonObj.dump();
 }
@@ -6909,13 +6862,13 @@ static std::string GetFaceAnalysisProgress()
 {
     string curTotalCount = GetTotalCount();
 
-    Uri uri(URI_USER_PHOTOGRAPHY_INFO);
-    vector<string> column = {
-        HIGHLIGHT_ANALYSIS_PROGRESS
-    };
-    DataShare::DataSharePredicates predicates;
     int errCode = 0;
-    shared_ptr<DataShare::DataShareResultSet> ret = UserFileClient::Query(uri, predicates, column, errCode);
+    GetAnalysisProcessReqBody reqBody;
+    reqBody.analysisType = AnalysisType::ANALYSIS_FACE;
+    QueryResultRspBody rspBody;
+    errCode = IPC::UserDefineIPCClient().Call(
+        static_cast<uint32_t>(MediaLibraryBusinessCode::GET_ANALYSIS_PROCESS), reqBody, rspBody);
+    shared_ptr<DataShare::DataShareResultSet> ret = rspBody.resultSet;
     if (ret == nullptr) {
         NAPI_ERR_LOG("ret is nullptr");
         return "";
@@ -6955,17 +6908,13 @@ static std::string GetHighlightAnalysisProgress()
     unordered_map<int, string> idxToCount = {
         {0, "ClearCount"}, {1, "DeleteCount"}, {2, "NotProduceCount"}, {3, "ProduceCount"}, {4, "PushCount"}
     };
-    Uri uri(URI_HIGHLIGHT_ALBUM);
-    vector<string> columns = {
-        "SUM(CASE WHEN highlight_status = -3 THEN 1 ELSE 0 END) AS ClearCount",
-        "SUM(CASE WHEN highlight_status = -2 THEN 1 ELSE 0 END) AS DeleteCount",
-        "SUM(CASE WHEN highlight_status = -1 THEN 1 ELSE 0 END) AS NotProduceCount",
-        "SUM(CASE WHEN highlight_status > 0 THEN 1 ELSE 0 END) AS ProduceCount",
-        "SUM(CASE WHEN highlight_status = 1 THEN 1 ELSE 0 END) AS PushCount",
-    };
-    DataShare::DataSharePredicates predicates;
     int errCode = 0;
-    shared_ptr<DataShare::DataShareResultSet> ret = UserFileClient::Query(uri, predicates, columns, errCode);
+    GetAnalysisProcessReqBody reqBody;
+    reqBody.analysisType = AnalysisType::ANALYSIS_HIGHLIGHT;
+    QueryResultRspBody rspBody;
+    errCode = IPC::UserDefineIPCClient().Call(
+        static_cast<uint32_t>(MediaLibraryBusinessCode::GET_ANALYSIS_PROCESS), reqBody, rspBody);
+    shared_ptr<DataShare::DataShareResultSet> ret = rspBody.resultSet;
     if (ret == nullptr) {
         NAPI_ERR_LOG("ret is nullptr");
         return "";
@@ -6976,7 +6925,7 @@ static std::string GetHighlightAnalysisProgress()
         return "";
     }
     nlohmann::json jsonObj;
-    for (size_t i = 0; i < columns.size(); ++i) {
+    for (size_t i = 0; i < idxToCount.size(); ++i) {
         int tmp = -1;
         ret->GetInt(i, tmp);
         jsonObj[idxToCount[i]] = tmp;
@@ -7096,7 +7045,7 @@ static void JSGetAnalysisDataExecute(napi_env env, MediaLibraryAsyncContext *con
 {
     MediaLibraryTracer tracer;
     tracer.Start("JSGetAnalysisDataExecute");
-    
+
     std::string analysisUri;
     if (context->isForce) {
         analysisUri = PAH_QUERY_ANA_ADDRESS_ASSETS_ACTIVE;
@@ -7106,7 +7055,7 @@ static void JSGetAnalysisDataExecute(napi_env env, MediaLibraryAsyncContext *con
     Uri uri(analysisUri);
     DataSharePredicates predicates;
     vector<string> columns;
-    
+
     if (context->analysisType == ANALYSIS_DETAIL_ADDRESS) {
         columns = { PhotoColumn::PHOTOS_TABLE + "." + MediaColumn::MEDIA_ID, PhotoColumn::PHOTOS_TABLE + "." + LATITUDE,
             PhotoColumn::PHOTOS_TABLE + "." + LONGITUDE, LANGUAGE, COUNTRY, ADMIN_AREA, SUB_ADMIN_AREA, LOCALITY,
@@ -7197,7 +7146,7 @@ static napi_value ParseArgsStartAssetAnalysis(napi_env env, napi_callback_info i
     constexpr size_t maxArgs = ARGS_TWO;
     CHECK_COND_WITH_MESSAGE(env, MediaLibraryNapiUtils::AsyncContextSetObjectInfo(env, info, context, minArgs,
         maxArgs) == napi_ok, "Failed to get object info");
-    
+
     if (!MediaLibraryNapiUtils::IsSystemApp()) {
         NapiError::ThrowError(env, E_CHECK_SYSTEMAPP_FAIL, "This interface can be called only by system apps");
         return nullptr;
@@ -7278,7 +7227,7 @@ static napi_value ParseArgsAnalysisData(napi_env env, napi_callback_info info,
     constexpr size_t maxArgs = ARGS_THREE;
     NAPI_ASSERT(env, MediaLibraryNapiUtils::AsyncContextSetObjectInfo(env, info, context, minArgs, maxArgs) ==
         napi_ok, "Failed to get object info");
-    
+
     if (!MediaLibraryNapiUtils::IsSystemApp()) {
         NapiError::ThrowError(env, E_CHECK_SYSTEMAPP_FAIL, "This interface can be called only by system apps");
         return nullptr;
@@ -7344,11 +7293,10 @@ napi_value MediaLibraryNapi::JSGetPhotoAssets(napi_env env, napi_callback_info i
 // Easter egg operation: query duplicate assets
 static bool EasterEgg(MediaLibraryAsyncContext* context)
 {
-    string queryUri;
     if (context->uri == URI_FIND_ALL_DUPLICATE_ASSETS) {
-        queryUri = PAH_FIND_ALL_DUPLICATE_ASSETS;
+        context->businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::FIND_ALL_DUPLICATE_ASSETS);
     } else if (context->uri == URI_FIND_ALL_DUPLICATE_ASSETS_TO_DELETE) {
-        queryUri = PAH_FIND_DUPLICATE_ASSETS_TO_DELETE;
+        context->businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::FIND_DUPLICATE_ASSETS_TO_DELETE);
     } else {
         return false;
     }
@@ -7361,22 +7309,27 @@ static bool EasterEgg(MediaLibraryAsyncContext* context)
     int64_t startTime = MediaFileUtils::UTCTimeMilliSeconds();
     NAPI_INFO_LOG(
         "Easter egg operation start: %{public}s, is query count: %{public}d",
-        queryUri == PAH_FIND_ALL_DUPLICATE_ASSETS ?
+        context->businessCode == static_cast<uint32_t>(MediaLibraryBusinessCode::FIND_ALL_DUPLICATE_ASSETS) ?
         "find all duplicate assets" : "find all duplicate assets to delete", isQueryCount);
-    int errCode = 0;
-    Uri uri(queryUri);
-    shared_ptr<DataShare::DataShareResultSet> resultSet = UserFileClient::Query(uri,
-        context->predicates, context->fetchColumn, errCode, context->userId);
-    if (resultSet == nullptr) {
+
+    GetAssetsReqBody reqBody;
+    reqBody.predicates = context->predicates;
+    reqBody.columns = context->fetchColumn;
+    GetAssetsRespBody respBody;
+    int32_t errCode =
+        IPC::UserDefineIPCClient().SetUserId(context->userId).Call(context->businessCode, reqBody, respBody);
+
+    if (errCode != E_OK || respBody.resultSet == nullptr) {
         context->SaveError(errCode);
         NAPI_ERR_LOG("Easter egg operation failed, errCode: %{public}d", errCode);
         return true;
     }
-    context->fetchFileResult = make_unique<FetchResult<FileAsset>>(move(resultSet));
+
+    context->fetchFileResult = make_unique<FetchResult<FileAsset>>(move(respBody.resultSet));
     context->fetchFileResult->SetResultNapiType(ResultNapiType::TYPE_PHOTOACCESS_HELPER);
     NAPI_INFO_LOG(
         "Easter egg operation end: %{public}s, is query count: %{public}d, cost time: %{public}" PRId64 "ms",
-        queryUri == PAH_FIND_ALL_DUPLICATE_ASSETS ?
+        context->businessCode == static_cast<uint32_t>(MediaLibraryBusinessCode::FIND_ALL_DUPLICATE_ASSETS) ?
         "find all duplicate assets" : "find all duplicate assets to delete", isQueryCount,
         MediaFileUtils::UTCTimeMilliSeconds() - startTime);
     return true;
@@ -7387,32 +7340,38 @@ static void PhotoAccessGetAssetsExecute(napi_env env, void *data)
     MediaLibraryTracer tracer;
     tracer.Start("PhotoAccessGetAssetsExecute");
 
-    auto *context = static_cast<MediaLibraryAsyncContext*>(data);
+    auto *context = static_cast<MediaLibraryAsyncContext *>(data);
+    CHECK_IF_EQUAL(context != nullptr, "context is nullptr");
+
     if (EasterEgg(context)) {
         return;
     }
-    string queryUri;
-    switch (context->assetType) {
-        case TYPE_PHOTO: {
-            queryUri = PAH_QUERY_PHOTO;
-            MediaLibraryNapiUtils::UriAppendKeyValue(queryUri, API_VERSION, to_string(MEDIA_API_VERSION_V10));
-            break;
+    string queryUri = PAH_QUERY_PHOTO;
+    MediaLibraryNapiUtils::UriAppendKeyValue(queryUri, API_VERSION, to_string(MEDIA_API_VERSION_V10));
+    Uri uri(queryUri);
+    int errCode = 0;
+    auto [accessSandbox, resultSet] = UserFileClient::QueryAccessibleViaSandBox(
+        uri, context->predicates, context->fetchColumn, errCode, context->userId);
+    if (accessSandbox) {
+        if (resultSet == nullptr) {
+            NAPI_ERR_LOG("QueryAccessibleViaSandBox failed, resultSet is nullptr");
         }
-        default: {
-            context->SaveError(-EINVAL);
-            return;
+    } else {
+        GetAssetsReqBody reqBody;
+        reqBody.predicates = context->predicates;
+        reqBody.columns = context->fetchColumn;
+        reqBody.burstKey = context->burstKey;
+        GetAssetsRespBody respBody;
+        errCode = IPC::UserDefineIPCClient()
+                      .SetUserId(context->userId)
+                      .Call(context->businessCode, reqBody, respBody);
+        if (errCode == E_OK) {
+            resultSet = respBody.resultSet;
+        } else {
+            NAPI_ERR_LOG("UserDefineIPCClient Call failed, errCode is %{public}d", errCode);
         }
     }
 
-    Uri uri(queryUri);
-    int errCode = 0;
-    shared_ptr<DataShare::DataShareResultSet> resultSet = UserFileClient::Query(uri,
-        context->predicates, context->fetchColumn, errCode, context->userId);
-    if (resultSet == nullptr && !context->uri.empty() && errCode == E_PERMISSION_DENIED) {
-        Uri queryWithUri(context->uri);
-        resultSet = UserFileClient::Query(queryWithUri, context->predicates, context->fetchColumn, errCode,
-            context->userId);
-    }
     if (resultSet == nullptr) {
         NAPI_ERR_LOG("resultSet is nullptr, errCode is %{public}d", errCode);
         context->SaveError(errCode);
@@ -7477,6 +7436,7 @@ napi_value MediaLibraryNapi::PhotoAccessGetPhotoAssets(napi_env env, napi_callba
     unique_ptr<MediaLibraryAsyncContext> asyncContext = make_unique<MediaLibraryAsyncContext>();
     asyncContext->assetType = TYPE_PHOTO;
     CHECK_NULLPTR_RET(ParseArgsGetAssets(env, info, asyncContext));
+    asyncContext->businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_GET_ASSETS);
 
     SetUserIdFromObjectInfo(asyncContext);
     return MediaLibraryNapiUtils::NapiCreateAsyncWork(env, asyncContext, "JSGetPhotoAssets",
@@ -7489,6 +7449,7 @@ napi_value MediaLibraryNapi::PhotoAccessGetBurstAssets(napi_env env, napi_callba
     unique_ptr<MediaLibraryAsyncContext> asyncContext = make_unique<MediaLibraryAsyncContext>();
     asyncContext->assetType = TYPE_PHOTO;
     CHECK_NULLPTR_RET(ParseArgsGetBurstAssets(env, info, asyncContext));
+    asyncContext->businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::GET_BURST_ASSETS);
 
     SetUserIdFromObjectInfo(asyncContext);
     return MediaLibraryNapiUtils::NapiCreateAsyncWork(env, asyncContext, "JSGetPhotoAssets",
@@ -7699,6 +7660,44 @@ static void JSGetPhotoAlbumsExecute(napi_env env, void *data)
     }
 }
 
+static void JSGetPhotoAlbumsByIdsExecute(napi_env env, void *data)
+{
+    MediaLibraryTracer tracer;
+    tracer.Start("JSGetPhotoAlbumsByIdsExecute");
+
+    auto *context = static_cast<MediaLibraryAsyncContext*>(data);
+    GetAlbumsByIdsReqBody reqBody;
+    GetAlbumsByIdsRspBody rspBody;
+    shared_ptr<DataShareResultSet> resultSet;
+    reqBody.predicates = context->predicates;
+    reqBody.columns = context->fetchColumn;
+    uint32_t businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_QUEUE_GET_ALBUMS_BY_IDS);
+    int errCode = IPC::UserDefineIPCClient().Call(businessCode, reqBody, rspBody);
+    resultSet = rspBody.resultSet;
+
+    if (resultSet == nullptr) {
+        NAPI_ERR_LOG("resultSet == nullptr, errCode is %{public}d", errCode);
+        if (errCode == E_PERMISSION_DENIED || errCode == -E_CHECK_SYSTEMAPP_FAIL) {
+            context->SaveError(errCode);
+        } else {
+            context->SaveError(E_HAS_DB_ERROR);
+        }
+        return;
+    }
+
+    if (context->albumIds.empty()) {
+        context->fetchPhotoAlbumResult = make_unique<FetchResult<PhotoAlbum>>(move(resultSet));
+        context->fetchPhotoAlbumResult->SetResultNapiType(context->resultNapiType);
+        context->fetchPhotoAlbumResult->SetHiddenOnly(context->hiddenOnly);
+        context->fetchPhotoAlbumResult->SetLocationOnly(context->isLocationAlbum ==
+            PhotoAlbumSubType::GEOGRAPHY_LOCATION);
+        context->fetchPhotoAlbumResult->SetUserId(context->userId);
+    } else {
+        std::unordered_map<int32_t, unique_ptr<PhotoAlbum>> albumMap;
+        BuildAlbumMap(context->albumMap, resultSet);
+    }
+}
+
 static napi_value JSGetPhotoAlbumsExecuteSync(napi_env env, MediaLibraryAsyncContext& asyncContext)
 {
     auto context = &asyncContext;
@@ -8211,8 +8210,11 @@ int32_t CallPhotoAccessCreateAlbum(MediaLibraryAsyncContext *context, const std:
 {
     CreateAlbumReqBody reqBody;
     reqBody.albumName = albumName;
-    int32_t result = IPC::UserDefineIPCClient().Call(context->businessCode, reqBody);
-    return result;
+    int32_t errCode = IPC::UserDefineIPCClient().Call(context->businessCode, reqBody);
+    if (errCode < 0) {
+        NAPI_ERR_LOG("after IPC::UserDefineIPCClient().Call, errCode: %{public}d.", errCode);
+    }
+    return errCode;
 }
 
 static void JSCreatePhotoAlbumExecute(napi_env env, void *data)
@@ -8635,17 +8637,17 @@ static napi_value ParseAlbumTypes(napi_env env, unique_ptr<MediaLibraryAsyncCont
     return result;
 }
 
-static void RestrictAlbumSubtypeOptions(unique_ptr<MediaLibraryAsyncContext> &context)
+static void RestrictAlbumSubtypeOptions(DataSharePredicates &predicates)
 {
     if (!MediaLibraryNapiUtils::IsSystemApp()) {
-        context->predicates.And()->In(PhotoAlbumColumns::ALBUM_SUBTYPE, vector<string>({
+        predicates.And()->In(PhotoAlbumColumns::ALBUM_SUBTYPE, vector<string>({
             to_string(PhotoAlbumSubType::USER_GENERIC),
             to_string(PhotoAlbumSubType::FAVORITE),
             to_string(PhotoAlbumSubType::VIDEO),
             to_string(PhotoAlbumSubType::IMAGE),
         }));
     } else {
-        context->predicates.And()->NotEqualTo(PhotoAlbumColumns::ALBUM_SUBTYPE, to_string(PhotoAlbumSubType::HIDDEN));
+        predicates.And()->NotEqualTo(PhotoAlbumColumns::ALBUM_SUBTYPE, to_string(PhotoAlbumSubType::HIDDEN));
     }
 }
 
@@ -8683,10 +8685,11 @@ static napi_value ParseArgsGetPhotoAlbum(napi_env env, napi_callback_info info,
         default:
             return nullptr;
     }
-    RestrictAlbumSubtypeOptions(context);
+    RestrictAlbumSubtypeOptions(context->predicates);
     if (context->isLocationAlbum != PhotoAlbumSubType::GEOGRAPHY_LOCATION &&
         context->isLocationAlbum != PhotoAlbumSubType::GEOGRAPHY_CITY) {
-        CHECK_NULLPTR_RET(AddDefaultPhotoAlbumColumns(env, context->fetchColumn));
+        CHECK_COND(env, CheckAlbumFetchColumns(context->fetchColumn), JS_ERR_PARAMETER_INVALID);
+        AddDefaultPhotoAlbumColumns(context->fetchColumn);
         AddDefaultColumnsForNonAnalysisAlbums(*context);
         if (context->isHighlightAlbum) {
             context->fetchColumn.erase(std::remove(context->fetchColumn.begin(), context->fetchColumn.end(),
@@ -8711,6 +8714,179 @@ napi_value MediaLibraryNapi::GetPhotoAlbums(napi_env env, napi_callback_info inf
         JSGetPhotoAlbumsCompleteCallback);
 }
 
+static void ReplaceFetchColumn(std::vector<std::string> &fetchColumn,
+    const std::string &oldColumn, const std::string &newColumn)
+{
+    auto it = std::find(fetchColumn.begin(), fetchColumn.end(), oldColumn);
+    if (it != fetchColumn.end()) {
+        it->assign(newColumn);
+    }
+}
+
+static void AddNoSmartFetchColumns(std::vector<std::string> &fetchColumn)
+{
+    AddDefaultPhotoAlbumColumns(fetchColumn);
+    fetchColumn.push_back(PhotoAlbumColumns::ALBUM_IMAGE_COUNT);
+    fetchColumn.push_back(PhotoAlbumColumns::ALBUM_VIDEO_COUNT);
+    fetchColumn.push_back(PhotoAlbumColumns::ALBUM_LPATH);
+    fetchColumn.push_back(PhotoAlbumColumns::ALBUM_DATE_ADDED);
+}
+
+static void AddPhotoAlbumTypeFilter(DataSharePredicates &predicates, int32_t albumType, int32_t albumSubType)
+{
+    if (albumType != PhotoAlbumType::INVALID) {
+        predicates.And()->EqualTo(PhotoAlbumColumns::ALBUM_TYPE, to_string(albumType));
+    }
+    if (albumSubType != PhotoAlbumSubType::ANY) {
+        predicates.And()->EqualTo(PhotoAlbumColumns::ALBUM_SUBTYPE, to_string(albumSubType));
+        if (albumSubType == PhotoAlbumSubType::SHOOTING_MODE || albumSubType == PhotoAlbumSubType::GEOGRAPHY_CITY) {
+            predicates.OrderByDesc(PhotoAlbumColumns::ALBUM_COUNT);
+        }
+    }
+    RestrictAlbumSubtypeOptions(predicates);
+}
+
+static napi_value ParseArgsPahGetAlbums(napi_env env, napi_callback_info info,
+    unique_ptr<MediaLibraryAsyncContext> &context)
+{
+    napi_value result = nullptr;
+    CHECK_ARGS(env, napi_get_boolean(env, true, &result), JS_INNER_FAIL);
+    napi_status status = MediaLibraryNapiUtils::AsyncContextSetObjectInfo(env, info, context, ARGS_ZERO, ARGS_FOUR);
+    CHECK_ARGS(env, status, JS_ERR_PARAMETER_INVALID);
+
+    bool hasCallback = false;
+    status = MediaLibraryNapiUtils::HasCallback(env, context->argc, context->argv, hasCallback);
+    CHECK_ARGS(env, status, JS_ERR_PARAMETER_INVALID);
+
+    context->photoAlbumType = PhotoAlbumType::INVALID;
+    context->photoAlbumSubType = PhotoAlbumSubType::ANY;
+    if (context->argc < ARGS_TWO) {
+        bool hasFetchOpt = false;
+        CHECK_ARGS(env, MediaLibraryNapiUtils::hasFetchOpt(env, context->argv[PARAM0], hasFetchOpt), JS_INNER_FAIL);
+        if (!hasFetchOpt) {
+            NapiError::ThrowError(env, JS_ERR_PARAMETER_INVALID);
+            return nullptr;
+        }
+        CHECK_NULLPTR_RET(GetAlbumFetchOption(env, context, hasCallback));
+        CHECK_COND(env, CheckAlbumFetchColumns(context->fetchColumn), JS_ERR_PARAMETER_INVALID);
+        return result;
+    }
+
+    CHECK_NULLPTR_RET(MediaLibraryNapiUtils::GetInt32Arg(env, context->argv[PARAM0], context->photoAlbumType));
+    if (!PhotoAlbum::CheckPhotoAlbumType(static_cast<PhotoAlbumType>(context->photoAlbumType))) {
+        NapiError::ThrowError(env, JS_ERR_PARAMETER_INVALID);
+        return nullptr;
+    }
+
+    CHECK_NULLPTR_RET(MediaLibraryNapiUtils::GetInt32Arg(env, context->argv[PARAM1], context->photoAlbumSubType));
+    if (!PhotoAlbum::CheckPhotoAlbumSubType(static_cast<PhotoAlbumSubType>(context->photoAlbumSubType))) {
+        NapiError::ThrowError(env, JS_ERR_PARAMETER_INVALID);
+        return nullptr;
+    }
+
+    if ((context->argc - hasCallback) == ARGS_THREE) {
+        CHECK_NULLPTR_RET(GetAlbumFetchOption(env, context, hasCallback));
+        if (context->photoAlbumSubType != PhotoAlbumSubType::GEOGRAPHY_LOCATION &&
+            context->photoAlbumSubType != PhotoAlbumSubType::GEOGRAPHY_CITY) {
+            CHECK_COND(env, CheckAlbumFetchColumns(context->fetchColumn), JS_ERR_PARAMETER_INVALID);
+        }
+    }
+
+    return result;
+}
+
+static std::shared_ptr<DataShareResultSet> CallPahGetAlbums(MediaLibraryAsyncContext *context, int32_t &errCode)
+{
+    if (context->businessCode != 0) {
+        QueryAlbumsReqBody reqBody;
+        QueryAlbumsRspBody rspBody;
+        reqBody.albumType = context->photoAlbumType;
+        reqBody.albumSubType = context->photoAlbumSubType;
+        reqBody.columns = context->fetchColumn;
+        reqBody.predicates = context->predicates;
+        errCode = IPC::UserDefineIPCClient().SetUserId(context->userId).Call(context->businessCode, reqBody, rspBody);
+        if (errCode != 0) {
+            NAPI_ERR_LOG("after IPC::UserDefineIPCClient().Call, errCode: %{public}d.", errCode);
+            return nullptr;
+        }
+        return rspBody.resultSet;
+    }
+
+    if (context->photoAlbumType != PhotoAlbumType::SMART) {
+        Uri uri(PAH_QUERY_PHOTO_ALBUM);
+        AddNoSmartFetchColumns(context->fetchColumn);
+        AddPhotoAlbumTypeFilter(context->predicates, context->photoAlbumType, context->photoAlbumSubType);
+        return UserFileClient::Query(uri, context->predicates, context->fetchColumn, errCode, context->userId);
+    }
+
+    if (context->photoAlbumSubType == PhotoAlbumSubType::GEOGRAPHY_LOCATION) {
+        Uri uri(PAH_QUERY_GEO_PHOTOS);
+        MediaLibraryNapiUtils::GetAllLocationPredicates(context->predicates);
+        const auto &locations = PhotoAlbumColumns::LOCATION_DEFAULT_FETCH_COLUMNS;
+        context->fetchColumn.insert(context->fetchColumn.end(), locations.begin(), locations.end());
+        return UserFileClient::Query(uri, context->predicates, context->fetchColumn, errCode, context->userId);
+    }
+
+    if (context->photoAlbumSubType == PhotoAlbumSubType::GEOGRAPHY_CITY) {
+        context->fetchColumn = PhotoAlbumColumns::CITY_DEFAULT_FETCH_COLUMNS;
+        std::string onClause = PhotoAlbumColumns::ALBUM_NAME  + " = " + CITY_ID;
+        context->predicates.InnerJoin(GEO_DICTIONARY_TABLE)->On({ onClause });
+        context->predicates.NotEqualTo(PhotoAlbumColumns::ALBUM_COUNT, to_string(0));
+    } else {
+        AddDefaultPhotoAlbumColumns(context->fetchColumn);
+        if (context->photoAlbumSubType == PhotoAlbumSubType::HIGHLIGHT ||
+            context->photoAlbumSubType == PhotoAlbumSubType::HIGHLIGHT_SUGGESTIONS) {
+            AddHighlightAlbumPredicates(context->predicates, context->photoAlbumSubType);
+            std::string highLightAlbumId = ANALYSIS_ALBUM_TABLE + "." + PhotoAlbumColumns::ALBUM_ID +
+                " AS " + PhotoAlbumColumns::ALBUM_ID;
+            ReplaceFetchColumn(context->fetchColumn, PhotoAlbumColumns::ALBUM_ID, highLightAlbumId);
+        }
+    }
+
+    Uri uri(PAH_QUERY_ANA_PHOTO_ALBUM);
+    AddPhotoAlbumTypeFilter(context->predicates, context->photoAlbumType, context->photoAlbumSubType);
+    return UserFileClient::Query(uri, context->predicates, context->fetchColumn, errCode, context->userId);
+}
+
+static void JSPahGetAlbumsExecute(napi_env env, void *data)
+{
+    MediaLibraryTracer tracer;
+    tracer.Start("JSPahGetAlbumsExecute");
+
+    int errCode = 0;
+    auto *context = static_cast<MediaLibraryAsyncContext*>(data);
+    std::shared_ptr<DataShareResultSet> resultSet = CallPahGetAlbums(context, errCode);
+    if (resultSet == nullptr) {
+        NAPI_ERR_LOG("resultSet == nullptr, errCode is %{public}d", errCode);
+        if (errCode == E_PERMISSION_DENIED || errCode == -E_CHECK_SYSTEMAPP_FAIL) {
+            context->SaveError(errCode);
+        } else {
+            context->SaveError(E_HAS_DB_ERROR);
+        }
+        return;
+    }
+
+    context->fetchPhotoAlbumResult = make_unique<FetchResult<PhotoAlbum>>(move(resultSet));
+    context->fetchPhotoAlbumResult->SetResultNapiType(context->resultNapiType);
+    context->fetchPhotoAlbumResult->SetHiddenOnly(false);
+    context->fetchPhotoAlbumResult->SetLocationOnly(false);
+    context->fetchPhotoAlbumResult->SetUserId(context->userId);
+}
+
+napi_value MediaLibraryNapi::PahGetAlbums(napi_env env, napi_callback_info info)
+{
+    MediaLibraryTracer tracer;
+    tracer.Start("PahGetAlbums");
+
+    unique_ptr<MediaLibraryAsyncContext> asyncContext = make_unique<MediaLibraryAsyncContext>();
+    asyncContext->resultNapiType = ResultNapiType::TYPE_PHOTOACCESS_HELPER;
+    CHECK_NULLPTR_RET(ParseArgsPahGetAlbums(env, info, asyncContext));
+    asyncContext->businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_QUERY_PHOTO_ALBUMS);
+    SetUserIdFromObjectInfo(asyncContext);
+    return MediaLibraryNapiUtils::NapiCreateAsyncWork(env, asyncContext, "PahGetAlbums", JSPahGetAlbumsExecute,
+        JSGetPhotoAlbumsCompleteCallback);
+}
+
 napi_value MediaLibraryNapi::PhotoAccessGetPhotoAlbums(napi_env env, napi_callback_info info)
 {
     MediaLibraryTracer tracer;
@@ -8725,6 +8901,20 @@ napi_value MediaLibraryNapi::PhotoAccessGetPhotoAlbums(napi_env env, napi_callba
         JSGetPhotoAlbumsCompleteCallback);
 }
 
+napi_value MediaLibraryNapi::PhotoAccessGetPhotoAlbumsByIds(napi_env env, napi_callback_info info)
+{
+    MediaLibraryTracer tracer;
+    tracer.Start("PhotoAccessGetPhotoAlbumsByIds");
+
+    unique_ptr<MediaLibraryAsyncContext> asyncContext = make_unique<MediaLibraryAsyncContext>();
+    asyncContext->resultNapiType = ResultNapiType::TYPE_PHOTOACCESS_HELPER;
+    CHECK_NULLPTR_RET(ParseArgsGetPhotoAlbum(env, info, asyncContext));
+
+    SetUserIdFromObjectInfo(asyncContext);
+    return MediaLibraryNapiUtils::NapiCreateAsyncWork(env, asyncContext, "GetPhotoAlbums", JSGetPhotoAlbumsByIdsExecute,
+        JSGetPhotoAlbumsCompleteCallback);
+}
+
 napi_value MediaLibraryNapi::PhotoAccessGetPhotoAlbumsSync(napi_env env, napi_callback_info info)
 {
     MediaLibraryTracer tracer;
@@ -8795,7 +8985,7 @@ static int32_t CallPhotoAccessCreateAsset(MediaLibraryAsyncContext* context, std
     }
 
     CreateAssetRspBody rspBody;
-    int32_t errCode = IPC::UserDefineIPCClient().Call(context->businessCode, reqBody, rspBody);
+    int32_t errCode = IPC::UserDefineIPCClient().SetUserId(context->userId).Call(context->businessCode, reqBody, rspBody);
     if (errCode != 0) {
         NAPI_ERR_LOG("after IPC::UserDefineIPCClient().Call, errCode: %{public}d.", errCode);
         return errCode;
@@ -8857,7 +9047,7 @@ static void PhotoAccessGrantPhotoUriPermissionExecute(napi_env env, void *data)
 {
     MediaLibraryTracer tracer;
     tracer.Start("PhotoAccessGrantPhotoUriPermissionExecute");
- 
+
     auto *context = static_cast<MediaLibraryAsyncContext*>(data);
     if (context == nullptr) {
         NAPI_ERR_LOG("Async context is null");
@@ -8938,12 +9128,12 @@ static void PhotoAccessGrantPhotoUrisPermissionExecuteEx(MediaLibraryAsyncContex
         context->retVal = result;
     }
 }
- 
+
 static void PhotoAccessGrantPhotoUrisPermissionExecute(napi_env env, void *data)
 {
     MediaLibraryTracer tracer;
     tracer.Start("PhotoAccessGrantPhotoUrisPermissionExecute");
- 
+
     auto *context = static_cast<MediaLibraryAsyncContext*>(data);
     if (context == nullptr) {
         NAPI_ERR_LOG("Async context is null");
@@ -8956,7 +9146,7 @@ static void PhotoAccessGrantPhotoUrisPermissionExecute(napi_env env, void *data)
     string uri = PAH_CREATE_APP_URI_PERMISSION;
     MediaLibraryNapiUtils::UriAppendKeyValue(uri, API_VERSION, to_string(MEDIA_API_VERSION_V10));
     Uri createUri(uri);
-    
+
     int result = UserFileClient::BatchInsert(createUri, context->valuesBucketArray);
     if (result < 0) {
         context->SaveError(result);
@@ -8965,7 +9155,7 @@ static void PhotoAccessGrantPhotoUrisPermissionExecute(napi_env env, void *data)
         context->retVal = result;
     }
 }
- 
+
 static void PhotoAccessCancelPhotoUriPermissionExecute(napi_env env, void *data)
 {
     MediaLibraryTracer tracer;
@@ -9027,9 +9217,9 @@ napi_value MediaLibraryNapi::PhotoAccessGrantPhotoUriPermission(napi_env env, na
 {
     MediaLibraryTracer tracer;
     tracer.Start("PhotoAccessGrantPhotoUriPermission");
- 
+
     NAPI_INFO_LOG("enter");
- 
+
     unique_ptr<MediaLibraryAsyncContext> asyncContext = make_unique<MediaLibraryAsyncContext>();
     asyncContext->resultNapiType = ResultNapiType::TYPE_PHOTOACCESS_HELPER;
     asyncContext->assetType = TYPE_PHOTO;
@@ -9039,14 +9229,14 @@ napi_value MediaLibraryNapi::PhotoAccessGrantPhotoUriPermission(napi_env env, na
     return MediaLibraryNapiUtils::NapiCreateAsyncWork(env, asyncContext, "PhotoAccessGrantPhotoUriPermission",
         PhotoAccessGrantPhotoUriPermissionExecute, JSPhotoUriPermissionCallback);
 }
- 
+
 napi_value MediaLibraryNapi::PhotoAccessGrantPhotoUrisPermission(napi_env env, napi_callback_info info)
 {
     MediaLibraryTracer tracer;
     tracer.Start("PhotoAccessGrantPhotoUrisPermission");
- 
+
     NAPI_INFO_LOG("enter");
- 
+
     unique_ptr<MediaLibraryAsyncContext> asyncContext = make_unique<MediaLibraryAsyncContext>();
     asyncContext->resultNapiType = ResultNapiType::TYPE_PHOTOACCESS_HELPER;
     asyncContext->assetType = TYPE_PHOTO;
@@ -9057,14 +9247,14 @@ napi_value MediaLibraryNapi::PhotoAccessGrantPhotoUrisPermission(napi_env env, n
     return MediaLibraryNapiUtils::NapiCreateAsyncWork(env, asyncContext, "PhotoAccessGrantPhotoUrisPermission",
         PhotoAccessGrantPhotoUrisPermissionExecute, JSPhotoUriPermissionCallback);
 }
- 
+
 napi_value MediaLibraryNapi::PhotoAccessCancelPhotoUriPermission(napi_env env, napi_callback_info info)
 {
     MediaLibraryTracer tracer;
     tracer.Start("PhotoAccessCancelPhotoUriPermission");
- 
+
     NAPI_INFO_LOG("enter");
- 
+
     unique_ptr<MediaLibraryAsyncContext> asyncContext = make_unique<MediaLibraryAsyncContext>();
     asyncContext->resultNapiType = ResultNapiType::TYPE_PHOTOACCESS_HELPER;
     asyncContext->assetType = TYPE_PHOTO;
@@ -9138,7 +9328,7 @@ static int32_t CallPhotoAccessCreateAssetForApp(MediaLibraryAsyncContext* contex
     reqBody.ownerAlbumId = ownerAlbumId;
 
     CreateAssetForAppRspBody rspBody;
-    int32_t errCode = IPC::UserDefineIPCClient().Call(context->businessCode, reqBody, rspBody);
+    int32_t errCode = IPC::UserDefineIPCClient().SetUserId(context->userId).Call(context->businessCode, reqBody, rspBody);
     if (errCode != 0) {
         NAPI_ERR_LOG("after IPC::UserDefineIPCClient().Call, errCode: %{public}d.", errCode);
         return errCode;
@@ -9190,7 +9380,7 @@ static void PhotoAccessAgentCreateAssetsExecute(napi_env env, void *data)
                 NAPI_ERR_LOG("PERMISSION_DENIED, index: %{public}d.", index);
                 return;
             }
-            
+
             if (index == E_HAS_DB_ERROR) {
                 index = OHOS_INVALID_PARAM_CODE;
             }
@@ -9218,11 +9408,9 @@ static void JSStartAssetAnalysisExecute(napi_env env, void *data)
     }
 
     context->taskId = ForegroundAnalysisMeta::GetIncTaskId();
-    std::string uriStr = FOREGROUND_ANALYSIS_ASSETS_MAP.at(context->analysisType);
-    MediaLibraryNapiUtils::UriAppendKeyValue(uriStr, FOREGROUND_ANALYSIS_TYPE, to_string(context->analysisType));
-    MediaLibraryNapiUtils::UriAppendKeyValue(uriStr, FOREGROUND_ANALYSIS_TASK_ID, to_string(context->taskId));
-    Uri uri(uriStr);
-    DataShare::DataSharePredicates predicates;
+    uint32_t businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_START_ASSET_ANALYSIS);
+    StartAssetAnalysisReqBody reqBody;
+    StartAssetAnalysisRspBody rspBody;
     std::vector<std::string> fileIds;
     for (const auto &uri : context->uris) {
         std::string fileId = MediaLibraryNapiUtils::GetFileIdFromUriString(uri);
@@ -9231,13 +9419,11 @@ static void JSStartAssetAnalysisExecute(napi_env env, void *data)
         }
     }
     if (!fileIds.empty()) {
-        predicates.In(PhotoColumn::PHOTOS_TABLE + "." + PhotoColumn::MEDIA_ID, fileIds);
+        reqBody.predicates.In(PhotoColumn::PHOTOS_TABLE + "." + PhotoColumn::MEDIA_ID, fileIds);
     }
-    int errCode = E_OK;
-    std::vector<std::string> columns;
-    auto result = UserFileClient::Query(uri, predicates, columns, errCode, context->userId);
-    if (result != nullptr) {
-        result->Close();
+    int errCode = IPC::UserDefineIPCClient().SetUserId(context->userId).Call(businessCode, reqBody, rspBody);
+    if (rspBody.resultSet != nullptr) {
+        rspBody.resultSet->Close();
     }
     if (errCode != E_OK) {
         context->SaveError(errCode);
@@ -9656,27 +9842,7 @@ napi_value MediaLibraryNapi::SetHidden(napi_env env, napi_callback_info info)
         SetHiddenExecute, SetHiddenCompleteCallback);
 }
 
-napi_value ParseHiddenPhotosDisplayMode(napi_env env,
-    const unique_ptr<MediaLibraryAsyncContext> &context, const int32_t fetchMode)
-{
-    switch (fetchMode) {
-        case ASSETS_MODE:
-            context->predicates.EqualTo(PhotoAlbumColumns::ALBUM_SUBTYPE, PhotoAlbumSubType::HIDDEN);
-            break;
-        case ALBUMS_MODE:
-            context->predicates.EqualTo(PhotoAlbumColumns::CONTAINS_HIDDEN, to_string(1));
-            break;
-        default:
-            NapiError::ThrowError(
-                env, OHOS_INVALID_PARAM_CODE, "Invalid fetch mode: " + to_string(fetchMode));
-            return nullptr;
-    }
-    napi_value result = nullptr;
-    CHECK_ARGS(env, napi_get_boolean(env, true, &result), JS_INNER_FAIL);
-    return result;
-}
-
-napi_value ParseArgsGetHiddenAlbums(napi_env env, napi_callback_info info,
+napi_value ParseArgsPahGetHiddenAlbums(napi_env env, napi_callback_info info,
     unique_ptr<MediaLibraryAsyncContext> &context)
 {
     if (!MediaLibraryNapiUtils::IsSystemApp()) {
@@ -9685,61 +9851,92 @@ napi_value ParseArgsGetHiddenAlbums(napi_env env, napi_callback_info info,
     }
     napi_value result = nullptr;
     CHECK_ARGS(env, napi_get_boolean(env, true, &result), JS_INNER_FAIL);
+    napi_status status = MediaLibraryNapiUtils::AsyncContextSetObjectInfo(env, info, context, ARGS_ONE, ARGS_THREE);
+    CHECK_ARGS(env, status, OHOS_INVALID_PARAM_CODE);
 
-    constexpr size_t minArgs = ARGS_ONE;
-    constexpr size_t maxArgs = ARGS_THREE;
-    CHECK_ARGS(env, MediaLibraryNapiUtils::AsyncContextSetObjectInfo(env, info, context, minArgs, maxArgs),
-        OHOS_INVALID_PARAM_CODE);
+    int32_t fetchMode = 0;
+    status = MediaLibraryNapiUtils::GetInt32(env, context->argv[PARAM0], fetchMode);
+    CHECK_ARGS(env, status, OHOS_INVALID_PARAM_CODE);
+    if (fetchMode != HiddenPhotosDisplayMode::ASSETS_MODE && fetchMode != HiddenPhotosDisplayMode::ALBUMS_MODE) {
+        NapiError::ThrowError(env, OHOS_INVALID_PARAM_CODE, "Invalid fetch mode: " + to_string(fetchMode));
+        return nullptr;
+    }
 
     bool hasCallback = false;
-    CHECK_ARGS(env, MediaLibraryNapiUtils::HasCallback(env, context->argc, context->argv, hasCallback),
-        OHOS_INVALID_PARAM_CODE);
-    if (context->argc == ARGS_THREE) {
-        napi_valuetype valueType = napi_undefined;
-        if (napi_typeof(env, context->argv[PARAM2], &valueType) == napi_ok &&
-            (valueType == napi_undefined || valueType == napi_null)) {
-            context->argc -= 1;
-        }
+    status = MediaLibraryNapiUtils::HasCallback(env, context->argc, context->argv, hasCallback);
+    CHECK_ARGS(env, status, OHOS_INVALID_PARAM_CODE);
+    if ((context->argc - hasCallback) == ARGS_TWO) {
+        status = MediaLibraryNapiUtils::GetFetchOption(env, context->argv[PARAM1], ALBUM_FETCH_OPT, context);
+        CHECK_ARGS(env, status, OHOS_INVALID_PARAM_CODE);
     }
-    int32_t fetchMode = 0;
-    switch (context->argc - hasCallback) {
-        case ARGS_ONE:
-            CHECK_ARGS(
-                env, MediaLibraryNapiUtils::GetInt32(env, context->argv[PARAM0], fetchMode), OHOS_INVALID_PARAM_CODE);
-            break;
-        case ARGS_TWO:
-            CHECK_ARGS(
-                env, MediaLibraryNapiUtils::GetInt32(env, context->argv[PARAM0], fetchMode), OHOS_INVALID_PARAM_CODE);
-            CHECK_ARGS(
-                env, MediaLibraryNapiUtils::GetFetchOption(
-                    env, context->argv[PARAM1], ALBUM_FETCH_OPT, context), OHOS_INVALID_PARAM_CODE);
-            break;
-        default:
-            NapiError::ThrowError(
-                env, OHOS_INVALID_PARAM_CODE, "Invalid parameter count: " + to_string(context->argc));
-            return nullptr;
-    }
-    CHECK_NULLPTR_RET(ParseHiddenPhotosDisplayMode(env, context, fetchMode));
-    CHECK_NULLPTR_RET(AddDefaultPhotoAlbumColumns(env, context->fetchColumn));
+
+    CHECK_COND(env, CheckAlbumFetchColumns(context->fetchColumn), JS_ERR_PARAMETER_INVALID);
     context->hiddenAlbumFetchMode = fetchMode;
-    if (fetchMode == HiddenPhotosDisplayMode::ASSETS_MODE) {
-        return result;
-    }
-    context->hiddenOnly = true;
-    context->fetchColumn.push_back(PhotoAlbumColumns::HIDDEN_COUNT);
-    context->fetchColumn.push_back(PhotoAlbumColumns::HIDDEN_COVER);
     return result;
 }
 
+static std::shared_ptr<DataShareResultSet> CallPahGetHiddenAlbums(MediaLibraryAsyncContext *context, int32_t &errCode)
+{
+    if (context->businessCode != 0) {
+        QueryAlbumsReqBody reqBody;
+        QueryAlbumsRspBody rspBody;
+        reqBody.columns = context->fetchColumn;
+        reqBody.predicates = context->predicates;
+        reqBody.hiddenAlbumFetchMode = context->hiddenAlbumFetchMode;
+        errCode = IPC::UserDefineIPCClient().SetUserId(context->userId).Call(context->businessCode, reqBody, rspBody);
+        if (errCode != 0) {
+            NAPI_ERR_LOG("after IPC::UserDefineIPCClient().Call, errCode: %{public}d.", errCode);
+            return nullptr;
+        }
+        return rspBody.resultSet;
+    }
+
+    Uri uri(PAH_QUERY_HIDDEN_ALBUM);
+    AddDefaultPhotoAlbumColumns(context->fetchColumn);
+    if (context->hiddenAlbumFetchMode == ALBUMS_MODE) {
+        context->fetchColumn.push_back(PhotoAlbumColumns::HIDDEN_COUNT);
+        context->fetchColumn.push_back(PhotoAlbumColumns::HIDDEN_COVER);
+        context->predicates.EqualTo(PhotoAlbumColumns::CONTAINS_HIDDEN, to_string(1));
+    } else {
+        context->predicates.EqualTo(PhotoAlbumColumns::ALBUM_SUBTYPE, PhotoAlbumSubType::HIDDEN);
+    }
+    return UserFileClient::Query(uri, context->predicates, context->fetchColumn, errCode, context->userId);
+}
+
+static void JSPahGetHiddenAlbumsExecute(napi_env env, void *data)
+{
+    MediaLibraryTracer tracer;
+    tracer.Start("JSPahGetHiddenAlbumsExecute");
+
+    int32_t errCode = 0;
+    auto *context = static_cast<MediaLibraryAsyncContext*>(data);
+    std::shared_ptr<DataShareResultSet> resultSet = CallPahGetHiddenAlbums(context, errCode);
+    if (resultSet == nullptr) {
+        NAPI_ERR_LOG("resultSet == nullptr, errCode is %{public}d", errCode);
+        if (errCode == E_PERMISSION_DENIED || errCode == -E_CHECK_SYSTEMAPP_FAIL) {
+            context->SaveError(errCode);
+        } else {
+            context->SaveError(E_HAS_DB_ERROR);
+        }
+        return;
+    }
+    context->fetchPhotoAlbumResult = make_unique<FetchResult<PhotoAlbum>>(move(resultSet));
+    context->fetchPhotoAlbumResult->SetResultNapiType(context->resultNapiType);
+    context->fetchPhotoAlbumResult->SetHiddenOnly(context->hiddenAlbumFetchMode == ALBUMS_MODE);
+    context->fetchPhotoAlbumResult->SetLocationOnly(false);
+    context->fetchPhotoAlbumResult->SetUserId(context->userId);
+}
+
 napi_value MediaLibraryNapi::PahGetHiddenAlbums(napi_env env, napi_callback_info info)
 {
     auto asyncContext = make_unique<MediaLibraryAsyncContext>();
     asyncContext->resultNapiType = ResultNapiType::TYPE_PHOTOACCESS_HELPER;
-    CHECK_NULLPTR_RET(ParseArgsGetHiddenAlbums(env, info, asyncContext));
+    CHECK_NULLPTR_RET(ParseArgsPahGetHiddenAlbums(env, info, asyncContext));
+    asyncContext->businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_QUERY_HIDDEN_ALBUMS);
 
     SetUserIdFromObjectInfo(asyncContext);
     return MediaLibraryNapiUtils::NapiCreateAsyncWork(env, asyncContext, "PahGetHiddenAlbums",
-        JSGetPhotoAlbumsExecute, JSGetPhotoAlbumsCompleteCallback);
+        JSPahGetHiddenAlbumsExecute, JSGetPhotoAlbumsCompleteCallback);
 }
 
 napi_value MediaLibraryNapi::JSApplyChanges(napi_env env, napi_callback_info info)
@@ -10575,14 +10772,14 @@ napi_value MediaLibraryNapi::PhotoAccessHelperSetForceHideSensitiveType(napi_env
 {
     MediaLibraryTracer tracer;
     tracer.Start("PhotoAccessHelperSetForceHideSensitiveType");
- 
+
     NAPI_INFO_LOG("enter");
- 
+
     unique_ptr<MediaLibraryAsyncContext> asyncContext = make_unique<MediaLibraryAsyncContext>();
     asyncContext->resultNapiType = ResultNapiType::TYPE_PHOTOACCESS_HELPER;
     asyncContext->assetType = TYPE_PHOTO;
     NAPI_ASSERT(env, ParseArgsGrantPhotoUrisForForceSensitive(env, info, asyncContext), "Failed to parse js args");
- 
+
     SetUserIdFromObjectInfo(asyncContext);
     return MediaLibraryNapiUtils::NapiCreateAsyncWork(env, asyncContext, "PhotoAccessGrantPhotoUrisPermission",
         PhotoAccessGrantPhotoUrisPermissionExecute, JSPhotoUriPermissionCallback);
@@ -10680,7 +10877,7 @@ int32_t MediaLibraryNapi::GetUserId()
 {
     return userId_;
 }
- 
+
 void MediaLibraryNapi::SetUserId(const int32_t &userId)
 {
     userId_ = userId;
diff --git a/frameworks/js/src/moving_photo_napi.cpp b/frameworks/js/src/moving_photo_napi.cpp
index f5f980d44c..0a0b87c6fc 100644
--- a/frameworks/js/src/moving_photo_napi.cpp
+++ b/frameworks/js/src/moving_photo_napi.cpp
@@ -35,6 +35,11 @@
 #include "userfile_manager_types.h"
 #include "moving_photo_call_transcoder.h"
 #include "permission_utils.h"
+#include "medialibrary_business_code.h"
+#include "request_content_vo.h"
+#include "user_define_ipc_client.h"
+#include "medialibrary_operation.h"
+#include "media_asset_rdbstore.h"
 
 using namespace std;
 using namespace OHOS::Security::AccessToken;
@@ -43,6 +48,9 @@ namespace OHOS {
 namespace Media {
 
 static const string MOVING_PHOTO_NAPI_CLASS = "MovingPhoto";
+static const string URI_TPYE = "uriType";
+static const string TPYE_PHOTOS = "1";
+
 thread_local napi_ref MovingPhotoNapi::constructor_ = nullptr;
 enum class MovingPhotoResourceType : int32_t {
     DEFAULT = 0,
@@ -542,6 +550,26 @@ static bool IsValidResourceType(int32_t resourceType)
                MediaLibraryNapiUtils::IsSystemApp());
 }
 
+static int32_t QueryPhotoPositionIPCExecute(const string &movingPhotoUri, int32_t userId, int32_t &position)
+{
+    RequestContentRespBody respBody;
+    RequestContentReqBody reqBody;
+    reqBody.mediaId = MediaFileUtils::GetIdFromUri(movingPhotoUri);
+    uint32_t businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_REQUEST_CONTENT);
+
+    std::unordered_map<std::string, std::string> headerMap{
+        {MediaColumn::MEDIA_ID, reqBody.mediaId}, {URI_TPYE, TPYE_PHOTOS}};
+    int32_t err =
+        IPC::UserDefineIPCClient().SetUserId(userId).SetHeader(headerMap).Call(businessCode, reqBody, respBody);
+    if (err != E_OK) {
+        NAPI_ERR_LOG("get position fail. err:%{public}d", err);
+        return E_ERR;
+    }
+
+    position = respBody.position;
+    return E_OK;
+}
+
 static int32_t QueryPhotoPosition(const string &movingPhotoUri, bool hasReadPermission, int32_t &position)
 {
     if (!MediaFileUtils::IsMediaLibraryUri(movingPhotoUri)) {
@@ -575,6 +603,11 @@ static int32_t QueryPhotoPosition(const string &movingPhotoUri, bool hasReadPerm
         MediaFileUri::RemoveAllFragment(queryUri);
     }
     Uri uri(queryUri);
+    OperationObject object = OperationObject::UNKNOWN_OBJECT;
+    if (!MediaAssetRdbStore::GetInstance()->IsQueryAccessibleViaSandBox(uri, object, predicates) || userId != -1) {
+        return QueryPhotoPositionIPCExecute(movingPhotoUri, userId, position);
+    }
+
     int errCode = 0;
     auto resultSet = UserFileClient::Query(uri, predicates, fetchColumn, errCode, userId);
     if (resultSet == nullptr || resultSet->GoToFirstRow() != E_OK) {
diff --git a/frameworks/js/src/photo_album_napi.cpp b/frameworks/js/src/photo_album_napi.cpp
index ba8ed75f38..e3c7f83862 100644
--- a/frameworks/js/src/photo_album_napi.cpp
+++ b/frameworks/js/src/photo_album_napi.cpp
@@ -37,6 +37,8 @@
 #include "album_remove_assets_vo.h"
 #include "album_recover_assets_vo.h"
 #include "album_photo_query_vo.h"
+#include "album_get_assets_vo.h"
+#include "get_face_id_vo.h"
 
 using namespace std;
 using namespace OHOS::DataShare;
@@ -1166,6 +1168,7 @@ static napi_value ParseArgsGetPhotoAssets(napi_env env, napi_callback_info info,
             NapiError::ThrowError(env, E_CHECK_SYSTEMAPP_FAIL, "This interface can be called only by system apps");
             return nullptr;
         }
+        context->isSystemApi = true;
         // sort by hidden time desc if is hidden asset
         context->predicates.IndexedBy(PhotoColumn::PHOTO_HIDDEN_TIME_INDEX);
     }
@@ -1232,6 +1235,7 @@ static void JSPhotoAccessGetPhotoAssetsExecute(napi_env env, void *data)
     tracer.Start("JSPhotoAccessGetPhotoAssetsExecute");
 
     auto *context = static_cast<PhotoAlbumNapiAsyncContext *>(data);
+    CHECK_IF_EQUAL(context != nullptr, "context is nullptr");
     Uri uri(PAH_QUERY_PHOTO_MAP);
     ConvertColumnsForPortrait(context);
     int32_t errCode = 0;
@@ -1242,7 +1246,28 @@ static void JSPhotoAccessGetPhotoAssetsExecute(napi_env env, void *data)
             userId = photoAlbum->GetUserId();
         }
     }
-    auto resultSet = UserFileClient::Query(uri, context->predicates, context->fetchColumn, errCode, userId);
+    auto [accessSandbox, resultSet] =
+        UserFileClient::QueryAccessibleViaSandBox(uri, context->predicates, context->fetchColumn, errCode, userId);
+    if (accessSandbox) {
+        if (resultSet == nullptr) {
+            NAPI_ERR_LOG("QueryAccessibleViaSandBox failed, resultSet is nullptr");
+        }
+    } else {
+        AlbumGetAssetsReqBody reqBody;
+        reqBody.predicates = context->predicates;
+        reqBody.columns = context->fetchColumn;
+        AlbumGetAssetsRespBody respBody;
+        uint32_t businessCode = context->isSystemApi
+                                    ? static_cast<uint32_t>(MediaLibraryBusinessCode::ALBUM_SYS_GET_ASSETS)
+                                    : static_cast<uint32_t>(MediaLibraryBusinessCode::ALBUM_GET_ASSETS);
+        errCode = IPC::UserDefineIPCClient().SetUserId(userId).Call(businessCode, reqBody, respBody);
+        if (errCode == E_OK) {
+            resultSet = respBody.resultSet;
+        } else {
+            NAPI_ERR_LOG("UserDefineIPCClient Call failed, errCode is %{public}d", errCode);
+        }
+    }
+
     if (resultSet == nullptr) {
         context->SaveError(E_HAS_DB_ERROR);
         return;
@@ -1701,24 +1726,23 @@ static void PhotoAccessHelperGetFaceIdExec(napi_env env, void *data)
         return;
     }
 
-    Uri uri(PAH_QUERY_ANA_PHOTO_ALBUM);
-    DataShare::DataSharePredicates predicates;
-    predicates.EqualTo(PhotoAlbumColumns::ALBUM_ID, objectInfo->GetAlbumId());
-    vector<string> fetchColumn = { GROUP_TAG };
-    int errCode = 0;
-
-    auto resultSet = UserFileClient::Query(uri, predicates, fetchColumn, errCode);
-    if (resultSet == nullptr || resultSet->GoToFirstRow() != 0) {
-        if (errCode == E_PERMISSION_DENIED) {
+    GetFaceIdReqBody reqBody;
+    GetFaceIdRespBody respBody;
+    reqBody.albumId = objectInfo->GetAlbumId();
+    reqBody.albumSubType = static_cast<int32_t>(albumSubType);
+    uint32_t businessCode = static_cast<uint32_t>(MediaLibraryBusinessCode::GET_FACE_ID);
+    int32_t ret = IPC::UserDefineIPCClient().Call(businessCode, reqBody, respBody);
+    if (ret < 0) {
+        if (ret == E_PERMISSION_DENIED) {
             context->error = OHOS_PERMISSION_DENIED_CODE;
         } else {
             context->SaveError(E_FAIL);
         }
-        NAPI_ERR_LOG("get face id failed, errCode is %{public}d", errCode);
+        NAPI_ERR_LOG("get face id failed, errCode is %{public}d", ret);
         return;
     }
-
-    context->faceTag = GetStringVal(GROUP_TAG, resultSet);
+    NAPI_INFO_LOG("respBody.groupTag: %{public}s", respBody.groupTag.c_str());
+    context->faceTag = respBody.groupTag;
 }
 
 static void GetFaceIdCompleteCallback(napi_env env, napi_status status, void *data)
diff --git a/frameworks/js/src/userfile_client.cpp b/frameworks/js/src/userfile_client.cpp
index 0263e3693b..3a1d172a21 100644
--- a/frameworks/js/src/userfile_client.cpp
+++ b/frameworks/js/src/userfile_client.cpp
@@ -255,6 +255,16 @@ shared_ptr<DataShareResultSet> UserFileClient::Query(Uri &uri, const DataSharePr
     return resultSet;
 }
 
+std::pair<bool, shared_ptr<DataShareResultSet>> UserFileClient::QueryAccessibleViaSandBox(Uri &uri,
+    const DataSharePredicates &predicates, std::vector<std::string> &columns, int &errCode, const int32_t userId)
+{
+    OperationObject object = OperationObject::UNKNOWN_OBJECT;
+    if (MediaAssetRdbStore::GetInstance()->IsQueryAccessibleViaSandBox(uri, object, predicates) && userId == -1) {
+        return {true, MediaAssetRdbStore::GetInstance()->Query(predicates, columns, object, errCode)};
+    }
+    return {false, nullptr};
+}
+
 std::shared_ptr<NativeRdb::ResultSet> UserFileClient::QueryRdb(Uri &uri,
     const DataShare::DataSharePredicates &predicates, std::vector<std::string> &columns)
 {
diff --git a/frameworks/utils/include/parameter_utils.h b/frameworks/utils/include/parameter_utils.h
index 0611b094ff..d205e1415e 100644
--- a/frameworks/utils/include/parameter_utils.h
+++ b/frameworks/utils/include/parameter_utils.h
@@ -60,6 +60,7 @@ public:
     static int32_t CheckOrientation(const AssetChangeReqBody &reqBody);
     static int32_t CheckVideoEnhancementAttr(const AssetChangeReqBody &reqBody);
     static int32_t CheckWatermarkType(const AssetChangeReqBody &reqBody);
+    static int32_t CheckWhereClause(const std::string &whereClause);
 };
 }  // namespace Media
 }  // namespace OHOS
diff --git a/frameworks/utils/src/parameter_utils.cpp b/frameworks/utils/src/parameter_utils.cpp
index 5fae595c3d..5687bdd52c 100644
--- a/frameworks/utils/src/parameter_utils.cpp
+++ b/frameworks/utils/src/parameter_utils.cpp
@@ -22,6 +22,8 @@
 #include "photo_album.h"
 #include "userfile_manager_types.h"
 #include "media_file_uri.h"
+#include "medialibrary_common_utils.h"
+#include "post_event_utils.h"
 
 namespace OHOS {
 namespace Media {
@@ -344,5 +346,20 @@ int32_t ParameterUtils::CheckWatermarkType(const AssetChangeReqBody &reqBody)
 
     return E_OK;
 }
+
+int32_t ParameterUtils::CheckWhereClause(const std::string &whereClause)
+{
+    int32_t ret = E_OK;
+    MEDIA_DEBUG_LOG("CheckWhereClause start");
+    if (!MediaLibraryCommonUtils::CheckWhereClause(whereClause)) {
+        ret = E_INVALID_VALUES;
+        MEDIA_ERR_LOG("illegal query whereClause input %{private}s", whereClause.c_str());
+        VariantMap map = {
+            {KEY_ERR_FILE, __FILE__}, {KEY_ERR_LINE, __LINE__}, {KEY_ERR_CODE, ret}, {KEY_OPT_TYPE, OptType::QUERY}};
+        PostEventUtils::GetInstance().PostErrorProcess(ErrType::DB_OPT_ERR, map);
+    }
+    MEDIA_DEBUG_LOG("CheckWhereClause end");
+    return ret;
+}
 }  // namespace Media
 }  // namespace OHOS
\ No newline at end of file
diff --git a/interfaces/kits/js/BUILD.gn b/interfaces/kits/js/BUILD.gn
index 60e78f41f0..b5860cb0ae 100644
--- a/interfaces/kits/js/BUILD.gn
+++ b/interfaces/kits/js/BUILD.gn
@@ -85,7 +85,6 @@ config("napi_config") {
     "${MEDIALIB_INNERKITS_PATH}/medialibrary_data_extension/include/ipc/util",
     "${MEDIALIB_INNERKITS_PATH}/medialibrary_data_extension/include/ipc/vo",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/include/vo",
-    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/include/dto",
     "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/include/vo",
   ]
 
@@ -215,6 +214,8 @@ ohos_shared_library("medialibrary_nutils") {
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/add_image_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/save_camera_photo_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/trash_photos_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_assets_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_index_construct_progress_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/revert_to_original_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/cloud_enhancement_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/modify_assets_vo.cpp",
@@ -225,6 +226,17 @@ ohos_shared_library("medialibrary_nutils") {
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/cancel_photo_uri_permission_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/start_thumbnail_creation_task_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/stop_thumbnail_creation_task_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_asset_analysis_data_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/is_edited_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/request_edit_data_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_edit_data_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/start_asset_analysis_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_cloudmedia_asset_status_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/request_content_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/get_cloud_enhancement_pair_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/query_cloud_enhancement_task_state_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/query_photo_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_assets_manager/src/vo/adapted_vo.cpp",
   ]
 
   media_album_service_vo_source = [
@@ -252,6 +264,15 @@ ohos_shared_library("medialibrary_nutils") {
     "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/album_remove_assets_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/album_recover_assets_vo.cpp",
     "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/album_photo_query_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/album_get_assets_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/query_albums_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_albums_by_ids_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_order_position_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_face_id_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_analysis_process_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_highlight_album_info_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/get_photo_index_vo.cpp",
+    "${MEDIALIB_BUSINESS_PATH}/media_albums_manager/src/vo/query_result_vo.cpp",
   ]
 
   sources += media_asset_service_vo_source
diff --git a/interfaces/kits/js/include/media_library_napi.h b/interfaces/kits/js/include/media_library_napi.h
index 0f1b0b88c3..e076c719f7 100644
--- a/interfaces/kits/js/include/media_library_napi.h
+++ b/interfaces/kits/js/include/media_library_napi.h
@@ -240,6 +240,7 @@ private:
     EXPORT static napi_value JSGetPublicDirectory(napi_env env, napi_callback_info info);
     EXPORT static napi_value JSGetFileAssets(napi_env env, napi_callback_info info);
     EXPORT static napi_value JSGetAlbums(napi_env env, napi_callback_info info);
+    EXPORT static napi_value PahGetAlbums(napi_env env, napi_callback_info info);
 
     EXPORT static napi_value JSCreateAsset(napi_env env, napi_callback_info info);
     EXPORT static napi_value JSDeleteAsset(napi_env env, napi_callback_info info);
@@ -322,6 +323,7 @@ private:
     EXPORT static napi_value PhotoAccessCreatePhotoAlbum(napi_env env, napi_callback_info info);
     EXPORT static napi_value PhotoAccessDeletePhotoAlbums(napi_env env, napi_callback_info info);
     EXPORT static napi_value PhotoAccessGetPhotoAlbums(napi_env env, napi_callback_info info);
+    EXPORT static napi_value PhotoAccessGetPhotoAlbumsByIds(napi_env env, napi_callback_info info);
     EXPORT static napi_value PhotoAccessGetPhotoAlbumsSync(napi_env env, napi_callback_info info);
     EXPORT static napi_value PhotoAccessSaveFormInfo(napi_env env, napi_callback_info info);
     EXPORT static napi_value PhotoAccessSaveGalleryFormInfo(napi_env env, napi_callback_info info);
@@ -337,7 +339,7 @@ private:
     EXPORT static napi_value PhotoAccessHelperGetDataAnalysisProgress(napi_env env, napi_callback_info info);
     EXPORT static napi_value PhotoAccessHelperGetAnalysisData(napi_env env, napi_callback_info info);
     EXPORT static napi_value PhotoAccessStartAssetAnalysis(napi_env env, napi_callback_info info);
-    
+
     EXPORT static napi_value SetHidden(napi_env env, napi_callback_info info);
     EXPORT static napi_value PahGetHiddenAlbums(napi_env env, napi_callback_info info);
 
@@ -500,6 +502,7 @@ struct MediaLibraryAsyncContext : public NapiError {
     int32_t hiddenAlbumFetchMode = -1;
     std::string formId;
     std::string indexProgress;
+    std::string burstKey;
     std::shared_ptr<PickerCallBack> pickerCallBack;
     std::vector<std::string> analysisDatas;
     uint32_t tokenId;
@@ -510,6 +513,8 @@ struct MediaLibraryAsyncContext : public NapiError {
     bool isFullAnalysis = false;
     uint32_t businessCode = 0;
     int32_t userId = -1;
+    int32_t photoAlbumType;
+    int32_t photoAlbumSubType;
 };
 
 struct MediaLibraryInitContext : public NapiError  {
diff --git a/interfaces/kits/js/include/photo_album_napi.h b/interfaces/kits/js/include/photo_album_napi.h
index feb1f6e118..556b91b104 100644
--- a/interfaces/kits/js/include/photo_album_napi.h
+++ b/interfaces/kits/js/include/photo_album_napi.h
@@ -123,6 +123,7 @@ struct PhotoAlbumNapiAsyncContext : public NapiError {
     int32_t newImageCount;
     int32_t newVideoCount;
     int32_t businessCode;
+    bool isSystemApi{false};
     std::vector<std::string> fetchColumn;
     std::vector<std::string> uris;
     std::vector<std::string> assetsArray;
diff --git a/interfaces/kits/js/include/userfile_client.h b/interfaces/kits/js/include/userfile_client.h
index 1dde681a8e..69981037d1 100644
--- a/interfaces/kits/js/include/userfile_client.h
+++ b/interfaces/kits/js/include/userfile_client.h
@@ -48,6 +48,9 @@ public:
     EXPORT static std::shared_ptr<DataShare::DataShareResultSet> Query(Uri &uri,
         const DataShare::DataSharePredicates &predicates, std::vector<std::string> &columns,
         int &errCode, const int32_t userId = -1);
+    EXPORT static std::pair<bool, std::shared_ptr<DataShare::DataShareResultSet>> QueryAccessibleViaSandBox(Uri &uri,
+        const DataShare::DataSharePredicates &predicates, std::vector<std::string> &columns, int &errCode,
+        const int32_t userId = -1);
     EXPORT static int Insert(Uri &uri, const DataShare::DataShareValuesBucket &value, const int32_t userId = -1);
     EXPORT static int InsertExt(Uri &uri, const DataShare::DataShareValuesBucket &value, std::string &result,
         const int32_t userId = -1);
diff --git a/services/media_albums_manager/include/controller/media_albums_controller_service.h b/services/media_albums_manager/include/controller/media_albums_controller_service.h
index a995107f77..0ae8149ef3 100644
--- a/services/media_albums_manager/include/controller/media_albums_controller_service.h
+++ b/services/media_albums_manager/include/controller/media_albums_controller_service.h
@@ -49,6 +49,15 @@ public:
     EXPORT void AlbumAddAssets(MessageParcel &data, MessageParcel &reply);
     EXPORT void AlbumRemoveAssets(MessageParcel &data, MessageParcel &reply);
     EXPORT void AlbumRecoverAssets(MessageParcel &data, MessageParcel &reply);
+    EXPORT void AlbumGetAssets(MessageParcel &data, MessageParcel &reply, OHOS::Media::IPC::IPCContext &context);
+    EXPORT void QueryAlbums(MessageParcel &data, MessageParcel &reply);
+    EXPORT void QueryHiddenAlbums(MessageParcel &data, MessageParcel &reply);
+    EXPORT void GetAlbumsByIds(MessageParcel &data, MessageParcel &reply);
+    EXPORT void GetOrderPosition(MessageParcel &data, MessageParcel &reply);
+    EXPORT void GetFaceId(MessageParcel &data, MessageParcel &reply);
+    EXPORT void GetPhotoIndex(MessageParcel &data, MessageParcel &reply);
+    EXPORT void GetAnalysisProcess(MessageParcel &data, MessageParcel &reply);
+    EXPORT void GetHighlightAlbumInfo(MessageParcel &data, MessageParcel &reply);
 public:
     virtual ~MediaAlbumsControllerService() = default;
     bool Accept(uint32_t code) override;
diff --git a/services/media_albums_manager/include/dto/album_get_assets_dto.h b/services/media_albums_manager/include/dto/album_get_assets_dto.h
new file mode 100755
index 0000000000..3df1578141
--- /dev/null
+++ b/services/media_albums_manager/include/dto/album_get_assets_dto.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ALBUMS_MANAGER_ALBUM_GET_ASSETS_DTO_H
+#define OHOS_MEDIA_ALBUMS_MANAGER_ALBUM_GET_ASSETS_DTO_H
+
+#include "album_get_assets_vo.h"
+
+namespace OHOS::Media {
+class AlbumGetAssetsDto {
+public:
+    DataShare::DataSharePredicates predicates;
+    std::vector<std::string> columns;
+
+    static AlbumGetAssetsDto Create(const AlbumGetAssetsReqBody &req);
+};
+}  // namespace OHOS::Media
+#endif  // OHOS_MEDIA_ALBUMS_MANAGER_ALBUM_GET_ASSETS_DTO_H
\ No newline at end of file
diff --git a/services/media_albums_manager/include/dto/get_order_position_dto.h b/services/media_albums_manager/include/dto/get_order_position_dto.h
new file mode 100755
index 0000000000..2c221c2962
--- /dev/null
+++ b/services/media_albums_manager/include/dto/get_order_position_dto.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_GET_ORDER_POSITION_DTO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_GET_ORDER_POSITION_DTO_H
+
+#include <string>
+#include <sstream>
+
+namespace OHOS::Media {
+class GetOrderPositionDto {
+public:
+    int32_t albumId;
+    std::vector<std::string> assetIdArray;
+ 
+public:
+    std::string ToString() const;
+};
+}  // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_GET_ORDER_POSITION_DTO_H
\ No newline at end of file
diff --git a/services/media_albums_manager/include/dto/query_albums_dto.h b/services/media_albums_manager/include/dto/query_albums_dto.h
new file mode 100644
index 0000000000..8f4f0173d9
--- /dev/null
+++ b/services/media_albums_manager/include/dto/query_albums_dto.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ALBUMS_MANAGER_QUERY_ALBUMS_DTO_H
+#define OHOS_MEDIA_ALBUMS_MANAGER_QUERY_ALBUMS_DTO_H
+
+#include <stdint.h>
+#include <string>
+#include <vector>
+
+#include "datashare_predicates.h"
+#include "datashare_result_set.h"
+
+namespace OHOS::Media {
+class QueryAlbumsDto {
+public:
+    int32_t albumType;
+    int32_t albumSubType;
+    int32_t hiddenAlbumFetchMode;
+    std::vector<std::string> columns;
+    DataShare::DataSharePredicates predicates;
+
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ALBUMS_MANAGER_QUERY_ALBUMS_DTO_H
\ No newline at end of file
diff --git a/services/media_albums_manager/include/media_albums_rdb_operations.h b/services/media_albums_manager/include/media_albums_rdb_operations.h
index d08ec4d09b..bf8a126acd 100644
--- a/services/media_albums_manager/include/media_albums_rdb_operations.h
+++ b/services/media_albums_manager/include/media_albums_rdb_operations.h
@@ -33,6 +33,7 @@ public:
     
     int32_t DeleteHighlightAlbums(const std::vector<std::string>& albumIds);
     int32_t SetHighlightUserActionData(const SetHighlightUserActionDataDto& dto);
+    int32_t GetFaceId(int32_t albumId, std::string& groupTag);
 };
 
 } // namespace OHOS::Media
diff --git a/services/media_albums_manager/include/media_albums_service.h b/services/media_albums_manager/include/media_albums_service.h
index 5e5ebdb3d1..8da7527b59 100644
--- a/services/media_albums_manager/include/media_albums_service.h
+++ b/services/media_albums_manager/include/media_albums_service.h
@@ -28,6 +28,14 @@
 #include "album_remove_assets_dto.h"
 #include "album_recover_assets_dto.h"
 #include "album_photo_query_vo.h"
+#include "album_get_assets_dto.h"
+#include "get_order_position_dto.h"
+#include "get_order_position_vo.h"
+#include "get_photo_index_vo.h"
+#include "query_result_vo.h"
+#include "get_analysis_process_vo.h"
+#include "get_highlight_album_info_vo.h"
+#include "query_albums_dto.h"
 
 namespace OHOS::Media {
 class MediaAlbumsService {
@@ -48,6 +56,15 @@ public:
     int32_t AlbumAddAssets(const AlbumAddAssetsDto& addAssetsDto, AlbumPhotoQueryRespBody& respBody);
     int32_t AlbumRemoveAssets(const AlbumRemoveAssetsDto& removeAssetsDto, AlbumPhotoQueryRespBody& respBody);
     int32_t AlbumRecoverAssets(const AlbumRecoverAssetsDto& recoverAssetsDto);
+    std::shared_ptr<DataShare::DataShareResultSet> AlbumGetAssets(const AlbumGetAssetsDto &dto);
+    int32_t QueryAlbums(QueryAlbumsDto &dto);
+    int32_t QueryHiddenAlbums(QueryAlbumsDto &dto);
+    int32_t GetOrderPosition(const GetOrderPositionDto& getOrderPositionDto, GetOrderPositionRespBody& resp);
+    int32_t GetFaceId(int32_t albumId, std::string& groupTag);
+    int32_t GetPhotoIndex(GetPhotoIndexReqBody &reqBody, QueryResultRspBody &rspBody);
+    int32_t GetMediaAnalysisServiceProcess(GetAnalysisProcessReqBody &reqBody, QueryResultRspBody &rspBody);
+    int32_t GetAnalysisProcess(GetAnalysisProcessReqBody &reqBody, QueryResultRspBody &rspBody);
+    int32_t GetHighlightAlbumInfo(GetHighlightAlbumReqBody &reqBody, QueryResultRspBody &rspBody);
 
 private:
     int32_t SetPortraitAlbumName(const ChangeRequestSetAlbumNameDto& dto);
diff --git a/services/media_albums_manager/include/vo/album_get_assets_vo.h b/services/media_albums_manager/include/vo/album_get_assets_vo.h
new file mode 100755
index 0000000000..3b801d358d
--- /dev/null
+++ b/services/media_albums_manager/include/vo/album_get_assets_vo.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ALBUMS_MANAGER_ALBUM_GET_ASSETS_VO_H
+#define OHOS_MEDIA_ALBUMS_MANAGER_ALBUM_GET_ASSETS_VO_H
+
+#include "datashare_predicates.h"
+#include "datashare_result_set.h"
+#include "i_media_parcelable.h"
+
+namespace OHOS::Media {
+class AlbumGetAssetsReqBody : public IPC::IMediaParcelable {
+public:
+    DataShare::DataSharePredicates predicates;
+    std::vector<std::string> columns;
+
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+
+class AlbumGetAssetsRespBody : public IPC::IMediaParcelable {
+public:
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+}  // namespace OHOS::Media
+#endif  // OHOS_MEDIA_ALBUMS_MANAGER_ALBUM_GET_ASSETS_VO_H
\ No newline at end of file
diff --git a/services/media_albums_manager/include/vo/get_albums_by_ids_vo.h b/services/media_albums_manager/include/vo/get_albums_by_ids_vo.h
new file mode 100644
index 0000000000..5ec26a9d23
--- /dev/null
+++ b/services/media_albums_manager/include/vo/get_albums_by_ids_vo.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ALBUMS_MANAGER_GET_ALBUMS_BY_IDS_VO_H
+#define OHOS_MEDIA_ALBUMS_MANAGER_GET_ALBUMS_BY_IDS_VO_H
+
+#include <string>
+#include <sstream>
+#include <vector>
+
+#include "i_media_parcelable.h"
+#include "datashare_predicates.h"
+#include "datashare_result_set.h"
+#include "data_ability_predicates.h"
+
+namespace OHOS::Media {
+class GetAlbumsByIdsReqBody : public IPC::IMediaParcelable {
+public:
+    DataShare::DataSharePredicates predicates;
+    std::vector<std::string> columns;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+
+public:  // basic functions
+    std::string ToString() const;
+};
+
+class GetAlbumsByIdsRspBody : public IPC::IMediaParcelable {
+public:
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+
+public:  // basic functions
+    std::string ToString() const;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ALBUMS_MANAGER_GET_ALBUMS_BY_IDS_VO_H
\ No newline at end of file
diff --git a/services/media_albums_manager/include/vo/get_analysis_process_vo.h b/services/media_albums_manager/include/vo/get_analysis_process_vo.h
new file mode 100644
index 0000000000..d2c776d44a
--- /dev/null
+++ b/services/media_albums_manager/include/vo/get_analysis_process_vo.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_GET_ANALYSIS_PROCESS_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_GET_ANALYSIS_PROCESS_VO_H
+ 
+#include <string>
+ 
+#include "datashare_predicates.h"
+#include "i_media_parcelable.h"
+ 
+namespace OHOS::Media {
+class GetAnalysisProcessReqBody : public IPC::IMediaParcelable {
+public:
+    int32_t analysisType;
+ 
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_GET_ANALYSIS_PROCESS_VO_H
\ No newline at end of file
diff --git a/services/media_albums_manager/include/vo/get_face_id_vo.h b/services/media_albums_manager/include/vo/get_face_id_vo.h
new file mode 100644
index 0000000000..c2bc22cb7e
--- /dev/null
+++ b/services/media_albums_manager/include/vo/get_face_id_vo.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ALBUMS_GET_FACE_ID_VO_H
+#define OHOS_MEDIA_ALBUMS_GET_FACE_ID_VO_H
+
+#include <string>
+
+#include "i_media_parcelable.h"
+
+namespace OHOS::Media {
+class GetFaceIdReqBody : public IPC::IMediaParcelable {
+public:
+    int32_t albumId;
+    int32_t albumSubType {-1};
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+ 
+public:  // basic functions
+    std::string ToString() const;
+};
+
+class GetFaceIdRespBody : public IPC::IMediaParcelable {
+public:
+    std::string groupTag;
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+ 
+public:  // basic functions
+    std::string ToString() const;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ALBUMS_GET_FACE_ID_VO_H
\ No newline at end of file
diff --git a/services/media_albums_manager/include/vo/get_highlight_album_info_vo.h b/services/media_albums_manager/include/vo/get_highlight_album_info_vo.h
new file mode 100644
index 0000000000..616ee5014f
--- /dev/null
+++ b/services/media_albums_manager/include/vo/get_highlight_album_info_vo.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_GET_HIGHLIGHT_ALBUM_INFO_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_GET_HIGHLIGHT_ALBUM_INFO_VO_H
+ 
+#include <string>
+ 
+#include "datashare_predicates.h"
+#include "i_media_parcelable.h"
+ 
+namespace OHOS::Media {
+class GetHighlightAlbumReqBody : public IPC::IMediaParcelable {
+public:
+    int32_t highlightAlbumInfoType = 0;
+    int32_t albumId = 0;
+    int32_t subType = 0;
+ 
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_GET_HIGHLIGHT_ALBUM_INFO_VO_H
\ No newline at end of file
diff --git a/services/media_albums_manager/include/vo/get_order_position_vo.h b/services/media_albums_manager/include/vo/get_order_position_vo.h
new file mode 100755
index 0000000000..322e7c9ee3
--- /dev/null
+++ b/services/media_albums_manager/include/vo/get_order_position_vo.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_GET_ORDER_POSITION_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_GET_ORDER_POSITION_VO_H
+
+#include <string>
+
+#include "i_media_parcelable.h"
+
+namespace OHOS::Media {
+class GetOrderPositionReqBody : public IPC::IMediaParcelable {
+public:
+    int32_t albumId;
+    int32_t albumType {-1};
+    int32_t albumSubType {-1};
+    std::vector<std::string> assetIdArray;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+
+class GetOrderPositionRespBody : public IPC::IMediaParcelable {
+public:
+    std::vector<int32_t> orderPositionArray;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_GET_ORDER_POSITION_VO_H
\ No newline at end of file
diff --git a/services/media_albums_manager/include/vo/get_photo_index_vo.h b/services/media_albums_manager/include/vo/get_photo_index_vo.h
new file mode 100644
index 0000000000..ad3f17b8d6
--- /dev/null
+++ b/services/media_albums_manager/include/vo/get_photo_index_vo.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_GET_PHOTO_INDEX_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_GET_PHOTO_INDEX_VO_H
+ 
+#include <string>
+ 
+#include "datashare_predicates.h"
+#include "i_media_parcelable.h"
+ 
+namespace OHOS::Media {
+class GetPhotoIndexReqBody : public IPC::IMediaParcelable {
+public:
+    DataShare::DataSharePredicates predicates;
+    bool isAnalysisAlbum = false;
+    std::string photoId = "";
+    std::string albumId = "";
+ 
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_GET_PHOTO_INDEX_VO_H
\ No newline at end of file
diff --git a/services/media_albums_manager/include/vo/query_albums_vo.h b/services/media_albums_manager/include/vo/query_albums_vo.h
new file mode 100644
index 0000000000..a77b1d684a
--- /dev/null
+++ b/services/media_albums_manager/include/vo/query_albums_vo.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ALBUMS_MANAGER_QUERY_ALBUMS_VO_H
+#define OHOS_MEDIA_ALBUMS_MANAGER_QUERY_ALBUMS_VO_H
+
+#include <stdint.h>
+#include <string>
+#include <sstream>
+#include <vector>
+
+#include "i_media_parcelable.h"
+#include "datashare_predicates.h"
+#include "datashare_result_set.h"
+
+namespace OHOS::Media {
+
+class QueryAlbumsReqBody : public IPC::IMediaParcelable {
+public:
+    int32_t albumType;
+    int32_t albumSubType;
+    int32_t hiddenAlbumFetchMode;
+    std::vector<std::string> columns;
+    DataShare::DataSharePredicates predicates;
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+
+class QueryAlbumsRspBody : public IPC::IMediaParcelable {
+public:
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ALBUMS_MANAGER_QUERY_ALBUMS_VO_H
\ No newline at end of file
diff --git a/services/media_albums_manager/include/vo/query_result_vo.h b/services/media_albums_manager/include/vo/query_result_vo.h
new file mode 100644
index 0000000000..92b1043998
--- /dev/null
+++ b/services/media_albums_manager/include/vo/query_result_vo.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_QUERY_RESULT_SET_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_QUERY_RESULT_SET_VO_H
+ 
+#include <string>
+ 
+#include "datashare_result_set.h"
+#include "i_media_parcelable.h"
+ 
+namespace OHOS::Media {
+class QueryResultRspBody : public IPC::IMediaParcelable {
+public:
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet = nullptr;
+ 
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_QUERY_RESULT_SET_VO_H
\ No newline at end of file
diff --git a/services/media_albums_manager/src/controller/media_albums_controller_service.cpp b/services/media_albums_manager/src/controller/media_albums_controller_service.cpp
index e5b50defb1..9f1482bbb5 100644
--- a/services/media_albums_manager/src/controller/media_albums_controller_service.cpp
+++ b/services/media_albums_manager/src/controller/media_albums_controller_service.cpp
@@ -67,11 +67,36 @@
 #include "album_recover_assets_vo.h"
 #include "album_recover_assets_dto.h"
 #include "album_photo_query_vo.h"
+#include "query_albums_vo.h"
+#include "query_albums_dto.h"
+#include "get_order_position_dto.h"
+#include "get_order_position_vo.h"
+#include "get_face_id_vo.h"
+#include "permission_common.h"
+#include "photo_album_column.h"
+#include "medialibrary_rdb_utils.h"
+#include "medialibrary_vision_operations.h"
+#include "get_albums_by_ids_vo.h"
+#include "rdb_utils.h"
 
 namespace OHOS::Media {
 using namespace std;
+using SpecialRequestHandle = void (MediaAlbumsControllerService::*)(
+    MessageParcel &, MessageParcel &, OHOS::Media::IPC::IPCContext &);
+
 using RequestHandle = void (MediaAlbumsControllerService::*)(MessageParcel &, MessageParcel &);
 
+const std::map<uint32_t, SpecialRequestHandle> SPECIAL_HANDLERS = {
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::ALBUM_SYS_GET_ASSETS),
+        &MediaAlbumsControllerService::AlbumGetAssets
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::ALBUM_GET_ASSETS),
+        &MediaAlbumsControllerService::AlbumGetAssets
+    },
+};
+
 const std::map<uint32_t, RequestHandle> HANDLERS = {
     {
         static_cast<uint32_t>(MediaLibraryBusinessCode::DELETE_HIGH_LIGHT_ALBUMS),
@@ -169,21 +194,57 @@ const std::map<uint32_t, RequestHandle> HANDLERS = {
         static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_SET_COVER_URI),
         &MediaAlbumsControllerService::AlbumCommitModify
     },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_QUERY_PHOTO_ALBUMS),
+        &MediaAlbumsControllerService::QueryAlbums
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_QUERY_HIDDEN_ALBUMS),
+        &MediaAlbumsControllerService::QueryHiddenAlbums
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_QUEUE_GET_ALBUMS_BY_IDS),
+        &MediaAlbumsControllerService::GetAlbumsByIds
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_GET_ORDER_POSITION),
+        &MediaAlbumsControllerService::GetOrderPosition
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::GET_FACE_ID),
+        &MediaAlbumsControllerService::GetFaceId
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::GET_PHOTO_INDEX),
+        &MediaAlbumsControllerService::GetPhotoIndex
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::GET_ANALYSIS_PROCESS),
+        &MediaAlbumsControllerService::GetAnalysisProcess
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::GET_HIGHLIGHT_ALBUM_INFO),
+        &MediaAlbumsControllerService::GetHighlightAlbumInfo
+    },
 };
 
 bool MediaAlbumsControllerService::Accept(uint32_t code)
 {
-    return HANDLERS.find(code) != HANDLERS.end();
+    return HANDLERS.find(code) != HANDLERS.end() || SPECIAL_HANDLERS.find(code) != SPECIAL_HANDLERS.end();
 }
 
-void MediaAlbumsControllerService::OnRemoteRequest(uint32_t code, MessageParcel &data,
-    MessageParcel &reply, OHOS::Media::IPC::IPCContext &context)
+void MediaAlbumsControllerService::OnRemoteRequest(
+    uint32_t code, MessageParcel &data, MessageParcel &reply, OHOS::Media::IPC::IPCContext &context)
 {
-    auto it = HANDLERS.find(code);
-    if (it == HANDLERS.end()) {
-        return IPC::UserDefineIPC().WriteResponseBody(reply, E_IPC_SEVICE_NOT_FOUND);
+    auto handlersIt = HANDLERS.find(code);
+    if (handlersIt != HANDLERS.end()) {
+        return (this->*(handlersIt->second))(data, reply);
     }
-    return (this->*(it->second))(data, reply);
+    auto specialHandlersIt = SPECIAL_HANDLERS.find(code);
+    if (specialHandlersIt != SPECIAL_HANDLERS.end()) {
+        return (this->*(specialHandlersIt->second))(data, reply, context);
+    }
+    return IPC::UserDefineIPC().WriteResponseBody(reply, E_IPC_SEVICE_NOT_FOUND);
 }
 
 static const map<int32_t, std::string> HIGHLIGHT_USER_ACTION_MAP = {
@@ -948,4 +1009,234 @@ void MediaAlbumsControllerService::AlbumRecoverAssets(MessageParcel &data, Messa
     IPC::UserDefineIPC().WriteResponseBody(reply, ret);
     return;
 }
+
+void MediaAlbumsControllerService::QueryAlbums(MessageParcel &data, MessageParcel &reply)
+{
+    QueryAlbumsReqBody reqBody;
+    QueryAlbumsRspBody rspBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+        MEDIA_ERR_LOG("CreateAssetForApp Read Request Error");
+        return;
+    }
+
+    QueryAlbumsDto dto;
+    dto.albumType = reqBody.albumType;
+    dto.albumSubType = reqBody.albumSubType;
+    dto.columns = reqBody.columns;
+    dto.predicates = reqBody.predicates;
+    ret = MediaAlbumsService::GetInstance().QueryAlbums(dto);
+    if (ret != E_OK) {
+        IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+        MEDIA_ERR_LOG("QueryAlbums failed, ret:%{public}d", ret);
+        return;
+    }
+
+    rspBody.resultSet = dto.resultSet;
+    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody);
+}
+
+void MediaAlbumsControllerService::QueryHiddenAlbums(MessageParcel &data, MessageParcel &reply)
+{
+    QueryAlbumsReqBody reqBody;
+    QueryAlbumsRspBody rspBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+        MEDIA_ERR_LOG("CreateAssetForApp Read Request Error");
+        return;
+    }
+
+    QueryAlbumsDto dto;
+    dto.columns = reqBody.columns;
+    dto.predicates = reqBody.predicates;
+    dto.hiddenAlbumFetchMode = reqBody.hiddenAlbumFetchMode;
+    ret = MediaAlbumsService::GetInstance().QueryHiddenAlbums(dto);
+    if (ret != E_OK) {
+        IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+        MEDIA_ERR_LOG("QueryHiddenAlbums failed, ret:%{public}d", ret);
+        return;
+    }
+
+    rspBody.resultSet = dto.resultSet;
+    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody);
+}
+
+void MediaAlbumsControllerService::GetAlbumsByIds(MessageParcel &data, MessageParcel &reply)
+{
+    GetAlbumsByIdsReqBody reqBody;
+    GetAlbumsByIdsRspBody rspBody;
+    std::shared_ptr<NativeRdb::ResultSet> resultSet;
+    std::vector<std::string> columns = reqBody.columns;
+    MediaLibraryRdbUtils::AddVirtualColumnsOfDateType(columns);
+
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("QueueGetEditData Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+
+    NativeRdb::RdbPredicates rdbPredicates =
+        RdbDataShareAdapter::RdbUtils::ToPredicates(reqBody.predicates, PhotoAlbumColumns::TABLE);
+    if (rdbPredicates.GetOrder().empty()) {
+        rdbPredicates.OrderByAsc(PhotoAlbumColumns::ALBUM_ORDER);
+    }
+    resultSet = MediaLibraryRdbStore::QueryWithFilter(rdbPredicates, columns);
+    if (resultSet != nullptr) {
+        auto bridge = RdbDataShareAdapter::RdbUtils::ToResultSetBridge(resultSet);
+        rspBody.resultSet = make_shared<DataShare::DataShareResultSet>(bridge);
+    }
+
+    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+}
+
+void MediaAlbumsControllerService::GetOrderPosition(MessageParcel &data, MessageParcel &reply)
+{
+    MEDIA_INFO_LOG("enter GetOrderPosition");
+    GetOrderPositionReqBody reqBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("GetOrderPosition Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+
+    PhotoAlbumType albumType = GetPhotoAlbumType(reqBody.albumType);
+    PhotoAlbumSubType albumSubtype = GetPhotoAlbumSubType(reqBody.albumSubType);
+    if (!PhotoAlbum::IsAnalysisAlbum(albumType, albumSubtype)) {
+        MEDIA_ERR_LOG("Only analysis album can get asset order positions");
+        IPC::UserDefineIPC().WriteResponseBody(reply, E_INVALID_VALUES);
+        return;
+    }
+
+    if (reqBody.assetIdArray.size() <= 0) {
+        MEDIA_ERR_LOG("needs at least one asset id");
+        IPC::UserDefineIPC().WriteResponseBody(reply, E_INVALID_VALUES);
+        return;
+    }
+    std::set<std::string> idSet(reqBody.assetIdArray.begin(), reqBody.assetIdArray.end());
+    if (reqBody.assetIdArray.size() != idSet.size()) {
+        MEDIA_ERR_LOG("has same assets");
+        IPC::UserDefineIPC().WriteResponseBody(reply, E_INVALID_VALUES);
+        return;
+    }
+
+    GetOrderPositionRespBody respBody;
+    GetOrderPositionDto getOrderPositionDto;
+    getOrderPositionDto.albumId = reqBody.albumId;
+    getOrderPositionDto.assetIdArray = reqBody.assetIdArray;
+
+    ret = MediaAlbumsService::GetInstance().GetOrderPosition(getOrderPositionDto, respBody);
+    IPC::UserDefineIPC().WriteResponseBody(reply, respBody, ret);
+    return;
+}
+
+void MediaAlbumsControllerService::GetFaceId(MessageParcel &data, MessageParcel &reply)
+{
+    MEDIA_INFO_LOG("enter GetFaceId");
+    GetFaceIdReqBody reqBody;
+    GetFaceIdRespBody respBody;
+
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("GetFaceId Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+
+    if (reqBody.albumSubType != PhotoAlbumSubType::PORTRAIT && reqBody.albumSubType != PhotoAlbumSubType::GROUP_PHOTO) {
+        MEDIA_WARN_LOG("albumSubType: %{public}d, not support getFaceId", reqBody.albumSubType);
+        IPC::UserDefineIPC().WriteResponseBody(reply, E_INVALID_VALUES);
+        return;
+    }
+
+    string groupTag;
+    ret = MediaAlbumsService::GetInstance().GetFaceId(reqBody.albumId, groupTag);
+    respBody.groupTag = groupTag;
+    IPC::UserDefineIPC().WriteResponseBody(reply, respBody, ret);
+}
+
+void MediaAlbumsControllerService::GetPhotoIndex(MessageParcel &data, MessageParcel &reply)
+{
+    GetPhotoIndexReqBody reqBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("GetPhotoIndex Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+    QueryResultRspBody rspBody;
+    ret = MediaAlbumsService::GetInstance().GetPhotoIndex(reqBody, rspBody);
+    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+}
+
+void MediaAlbumsControllerService::GetAnalysisProcess(MessageParcel &data, MessageParcel &reply)
+{
+    GetAnalysisProcessReqBody reqBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("GetAnalysisProcess Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+    QueryResultRspBody rspBody;
+    ret = MediaAlbumsService::GetInstance().GetAnalysisProcess(reqBody, rspBody);
+    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+}
+
+void MediaAlbumsControllerService::GetHighlightAlbumInfo(MessageParcel &data, MessageParcel &reply)
+{
+    GetHighlightAlbumReqBody reqBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("GetHighlightAlbumInfo Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+    QueryResultRspBody rspBody;
+    ret = MediaAlbumsService::GetInstance().GetHighlightAlbumInfo(reqBody, rspBody);
+    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+}
+
+void MediaAlbumsControllerService::AlbumGetAssets(
+    MessageParcel &data, MessageParcel &reply, OHOS::Media::IPC::IPCContext &context)
+{
+    MEDIA_INFO_LOG("enter");
+    AlbumGetAssetsReqBody reqBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+
+    ret = ParameterUtils::CheckWhereClause(reqBody.predicates.GetWhereClause());
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("CheckWhereClause fialed");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+    AlbumGetAssetsDto dto = AlbumGetAssetsDto::Create(reqBody);
+    if (context.GetByPassCode() == E_PERMISSION_DB_BYPASS) {
+        string clientAppId = GetClientAppId();
+        if (clientAppId.empty()) {
+            MEDIA_ERR_LOG("clientAppId is empty");
+            IPC::UserDefineIPC().WriteResponseBody(reply, Media::E_PERMISSION_DENIED);
+            return;
+        }
+        dto.predicates.And()->EqualTo("owner_appid", clientAppId);
+    }
+    MediaLibraryRdbUtils::AddVirtualColumnsOfDateType(dto.columns);
+    auto resultSet = MediaAlbumsService::GetInstance().AlbumGetAssets(dto);
+    if (resultSet == nullptr) {
+        MEDIA_ERR_LOG("resultSet is null");
+        IPC::UserDefineIPC().WriteResponseBody(reply, E_FAIL);
+        return;
+    }
+    AlbumGetAssetsRespBody respBody;
+    respBody.resultSet = resultSet;
+    IPC::UserDefineIPC().WriteResponseBody(reply, respBody);
+}
 } // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_albums_manager/src/controller/media_albums_permission_policy.cpp b/services/media_albums_manager/src/controller/media_albums_permission_policy.cpp
index c5b3b903ee..43231e6510 100755
--- a/services/media_albums_manager/src/controller/media_albums_permission_policy.cpp
+++ b/services/media_albums_manager/src/controller/media_albums_permission_policy.cpp
@@ -63,11 +63,29 @@ static std::unordered_map<uint32_t, std::vector<std::vector<PermissionType>>> me
     {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_REMOVE_ASSETS), { {WRITE_PERM} }},
     {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_RECOVER_ASSETS), { {SYSTEMAPI_PERM, WRITE_PERM} }},
     {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_SET_COVER_URI), { {SYSTEMAPI_PERM, WRITE_PERM} }},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_QUERY_PHOTO_ALBUMS), { {READ_PERM} }},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_QUERY_HIDDEN_ALBUMS), { {SYSTEMAPI_PERM, READ_PERM} }},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_QUEUE_GET_ALBUMS_BY_IDS), { {SYSTEMAPI_PERM, READ_PERM} }},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_GET_ORDER_POSITION), { {SYSTEMAPI_PERM, READ_PERM} }},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::GET_FACE_ID), { {SYSTEMAPI_PERM, READ_PERM} }},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::GET_ANALYSIS_PROCESS), {{READ_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::GET_PHOTO_INDEX), {{SYSTEMAPI_PERM, READ_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::GET_HIGHLIGHT_ALBUM_INFO), {{SYSTEMAPI_PERM, READ_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::ALBUM_SYS_GET_ASSETS), {{SYSTEMAPI_PERM, READ_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::ALBUM_GET_ASSETS), {{READ_PERM}}},
+};
+
+static std::unordered_set<uint32_t> mediaAlbumsPermissionDbBypass = {
+    static_cast<uint32_t>(MediaLibraryBusinessCode::ALBUM_SYS_GET_ASSETS),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::ALBUM_GET_ASSETS),
 };
 
 int32_t MediaAlbumsControllerService::GetPermissionPolicy(
     uint32_t code, std::vector<std::vector<PermissionType>> &permissionPolicy, bool &isBypass)
 {
+    if (mediaAlbumsPermissionDbBypass.find(code) != mediaAlbumsPermissionDbBypass.end()) {
+        isBypass = true;
+    }
     auto it = mediaAlbumsPermissionPolicy.find(code);
     if (it != mediaAlbumsPermissionPolicy.end()) {
         permissionPolicy = it->second;
diff --git a/services/media_albums_manager/src/dto/album_get_assets_dto.cpp b/services/media_albums_manager/src/dto/album_get_assets_dto.cpp
new file mode 100755
index 0000000000..9a27b6390f
--- /dev/null
+++ b/services/media_albums_manager/src/dto/album_get_assets_dto.cpp
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "album_get_assets_dto.h"
+
+namespace OHOS::Media {
+AlbumGetAssetsDto AlbumGetAssetsDto::Create(const AlbumGetAssetsReqBody &req)
+{
+    AlbumGetAssetsDto dto;
+    dto.predicates = req.predicates;
+    dto.columns = req.columns;
+    return dto;
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_albums_manager/src/dto/get_order_position_dto.cpp b/services/media_albums_manager/src/dto/get_order_position_dto.cpp
new file mode 100755
index 0000000000..2e37fff013
--- /dev/null
+++ b/services/media_albums_manager/src/dto/get_order_position_dto.cpp
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaGetOrderPositionDto"
+
+#include "get_order_position_dto.h"
+
+#include <sstream>
+
+namespace OHOS::Media {
+using namespace std;
+std::string GetOrderPositionDto::ToString() const
+{
+    std::stringstream ss;
+    ss << "{"
+       << "\"albumId\": \"" << std::to_string(this->albumId) << "\", "
+       << "\"assetIdArray\": \" [";
+    for (size_t i = 0; i < assetIdArray.size(); i++) {
+        ss << assetIdArray[i];
+        if (i != assetIdArray.size() - 1) {
+            ss << ", ";
+        }
+    }
+    ss << "]"
+       << "}";
+    return ss.str();
+}
+} // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_albums_manager/src/media_albums_rdb_operations.cpp b/services/media_albums_manager/src/media_albums_rdb_operations.cpp
index ecf8cb7e5f..bee033846e 100644
--- a/services/media_albums_manager/src/media_albums_rdb_operations.cpp
+++ b/services/media_albums_manager/src/media_albums_rdb_operations.cpp
@@ -30,6 +30,7 @@
 #include "medialibrary_rdb_utils.h"
 #include "media_file_utils.h"
 #include "result_set_utils.h"
+#include "vision_column.h"
 
 using namespace std;
 using namespace OHOS::NativeRdb;
@@ -37,6 +38,7 @@ using namespace OHOS::NativeRdb;
 namespace OHOS::Media {
 static constexpr int32_t HIGHLIGHT_DELETED = -2;
 const std::string ALBUM_LPATH_PREFIX = "/Pictures/Users/";
+static const string GROUP_TAG = "group_tag";
 
 MediaAlbumsRdbOperations::MediaAlbumsRdbOperations() {}
 
@@ -93,4 +95,16 @@ int32_t MediaAlbumsRdbOperations::SetHighlightUserActionData(const SetHighlightU
     }
     return static_cast<int32_t>(updateRows);
 }
+
+int32_t MediaAlbumsRdbOperations::GetFaceId(int32_t albumId, string& groupTag)
+{
+    NativeRdb::RdbPredicates predicates(ANALYSIS_ALBUM_TABLE);
+    predicates.EqualTo(PhotoAlbumColumns::ALBUM_ID, to_string(albumId));
+    vector<string> columns = { GROUP_TAG };
+    auto resultSet = MediaLibraryRdbStore::StepQueryWithoutCheck(predicates, columns);
+    bool cond = (resultSet == nullptr || resultSet->GoToFirstRow() != NativeRdb::E_OK);
+    CHECK_AND_RETURN_RET_LOG(!cond, E_HAS_DB_ERROR, "Failed to query group tag!");
+    groupTag = GetStringVal(GROUP_TAG, resultSet);
+    return E_OK;
+}
 } // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_albums_manager/src/media_albums_service.cpp b/services/media_albums_manager/src/media_albums_service.cpp
index 77f1092e02..527827cffe 100644
--- a/services/media_albums_manager/src/media_albums_service.cpp
+++ b/services/media_albums_manager/src/media_albums_service.cpp
@@ -22,12 +22,15 @@
 #include "medialibrary_album_operations.h"
 #include "media_albums_rdb_operations.h"
 #include "media_log.h"
+#include "medialibrary_data_manager.h"
 #include "medialibrary_errno.h"
 #include "medialibrary_notify.h"
+#include "medialibrary_rdbstore.h"
+#include "location_column.h"
 #include "photo_album_column.h"
+#include "story_album_column.h"
 #include "media_file_utils.h"
 #include "result_set_utils.h"
-#include "medialibrary_album_operations.h"
 #include "medialibrary_analysis_album_operations.h"
 #include "photo_map_operations.h"
 #include "medialibrary_common_utils.h"
@@ -37,12 +40,40 @@
 #include "rdb_utils.h"
 #include "medialibrary_rdb_utils.h"
 #include "photo_map_column.h"
+#include "permission_utils.h"
+#include "album_operation_uri.h"
+#include "datashare_result_set.h"
+#include "user_photography_info_column.h"
+#include "story_album_column.h"
+#include "userfile_manager_types.h"
+#include "story_cover_info_column.h"
+#include "story_play_info_column.h"
+#include "vision_column_comm.h"
+#include "medialibrary_photo_operations.h"
+#include "rdb_predicates.h"
 
 using namespace std;
+using namespace OHOS::RdbDataShareAdapter;
 
 namespace OHOS::Media {
-static const string USER_DISPLAY_LEVEL = "user_display_level";
-static const string SUB_TITLE = "sub_title";
+
+struct HighlightAlbumInfo {
+    std::string uriStr;
+    std::vector<std::string> fetchColumn;
+};
+
+static const std::map<int32_t, struct HighlightAlbumInfo> HIGHLIGHT_ALBUM_INFO_MAP = {
+    { COVER_INFO, { PAH_QUERY_HIGHLIGHT_COVER, { ID, HIGHLIGHT_ALBUM_TABLE + "." + PhotoAlbumColumns::ALBUM_ID,
+        AI_ALBUM_ID, SUB_TITLE, CLUSTER_TYPE, CLUSTER_SUB_TYPE,
+        CLUSTER_CONDITION, MIN_DATE_ADDED, MAX_DATE_ADDED, GENERATE_TIME, HIGHLIGHT_VERSION,
+        REMARKS, HIGHLIGHT_STATUS, RATIO, BACKGROUND, FOREGROUND, WORDART, IS_COVERED, COLOR,
+        RADIUS, SATURATION, BRIGHTNESS, BACKGROUND_COLOR_TYPE, SHADOW_LEVEL, TITLE_SCALE_X,
+        TITLE_SCALE_Y, TITLE_RECT_WIDTH, TITLE_RECT_HEIGHT, BACKGROUND_SCALE_X, BACKGROUND_SCALE_Y,
+        BACKGROUND_RECT_WIDTH, BACKGROUND_RECT_HEIGHT, LAYOUT_INDEX, COVER_ALGO_VERSION, COVER_KEY, COVER_STATUS,
+        HIGHLIGHT_IS_MUTED, HIGHLIGHT_IS_FAVORITE, HIGHLIGHT_THEME, HIGHLIGHT_PIN_TIME, HIGHLIGHT_USE_SUBTITLE } } },
+    { PLAY_INFO, { PAH_QUERY_HIGHLIGHT_PLAY, { ID, HIGHLIGHT_ALBUM_TABLE + "." + PhotoAlbumColumns::ALBUM_ID,
+        MUSIC, FILTER, HIGHLIGHT_PLAY_INFO, IS_CHOSEN, PLAY_INFO_VERSION, PLAY_INFO_ID } } },
+};
 
 MediaAlbumsService &MediaAlbumsService::GetInstance()
 {
@@ -340,4 +371,399 @@ int32_t MediaAlbumsService::AlbumRecoverAssets(const AlbumRecoverAssetsDto& reco
 
     return MediaLibraryAlbumOperations::RecoverPhotoAssets(predicates);
 }
+
+std::shared_ptr<DataShare::DataShareResultSet> MediaAlbumsService::AlbumGetAssets(const AlbumGetAssetsDto &dto)
+{
+    NativeRdb::RdbPredicates predicates =
+        RdbDataShareAdapter::RdbUtils::ToPredicates(dto.predicates, PhotoColumn::PHOTOS_TABLE);
+    auto resultSet = PhotoMapOperations::QueryPhotoAssets(predicates, dto.columns);
+    CHECK_AND_RETURN_RET_LOG(resultSet, nullptr, "Failed to query album assets");
+    auto resultSetBridge = RdbDataShareAdapter::RdbUtils::ToResultSetBridge(resultSet);
+    return make_shared<DataShare::DataShareResultSet>(resultSetBridge);
+}
+
+static void LogQueryParams(const DataShare::DataSharePredicates &predicates, const vector<string> &fetchColumn)
+{
+    std::string sqlColumns;
+    for (const auto &column : fetchColumn) {
+        if (!sqlColumns.empty()) {
+            sqlColumns += ",";
+        }
+        sqlColumns += column;
+    }
+    NativeRdb::RdbPredicates rdbPredicate = RdbUtils::ToPredicates(predicates, PhotoAlbumColumns::TABLE);
+    std::string sqlWhere = rdbPredicate.GetWhereClause();
+    for (const auto &whereArg : rdbPredicate.GetWhereArgs()) {
+        sqlWhere.replace(sqlWhere.find("?"), 1, whereArg);
+    }
+    std::string sqlOrder = rdbPredicate.GetOrder();
+    MEDIA_INFO_LOG("sqlColumns: %{public}s", sqlColumns.c_str());
+    MEDIA_INFO_LOG("sqlWhere: %{public}s", sqlWhere.c_str());
+    MEDIA_INFO_LOG("sqlOrder: %{public}s", sqlOrder.c_str());
+}
+
+static bool CheckAlbumFetchColumns(const vector<string> &fetchColumn)
+{
+    for (const auto &column : fetchColumn) {
+        if (!PhotoAlbumColumns::IsPhotoAlbumColumn(column)) {
+            MEDIA_ERR_LOG("Invalid columns:%{public}s", column.c_str());
+            return false;
+        }
+    }
+    return true;
+}
+
+static void ReplaceFetchColumn(std::vector<std::string> &fetchColumn,
+    const std::string &oldColumn, const std::string &newColumn)
+{
+    auto it = std::find(fetchColumn.begin(), fetchColumn.end(), oldColumn);
+    if (it != fetchColumn.end()) {
+        it->assign(newColumn);
+    }
+}
+
+static void AddDefaultPhotoAlbumColumns(vector<string> &fetchColumn)
+{
+    auto columns = PhotoAlbumColumns::DEFAULT_FETCH_COLUMNS;
+    for (const auto &column : fetchColumn) {
+        if (columns.count(column) == 0) {
+            columns.insert(column);
+        }
+    }
+    fetchColumn.assign(columns.begin(), columns.end());
+}
+
+static void AddNoSmartFetchColumns(std::vector<std::string> &fetchColumn)
+{
+    AddDefaultPhotoAlbumColumns(fetchColumn);
+    fetchColumn.push_back(PhotoAlbumColumns::ALBUM_IMAGE_COUNT);
+    fetchColumn.push_back(PhotoAlbumColumns::ALBUM_VIDEO_COUNT);
+    fetchColumn.push_back(PhotoAlbumColumns::ALBUM_LPATH);
+    fetchColumn.push_back(PhotoAlbumColumns::ALBUM_DATE_ADDED);
+}
+
+static void AddPhotoAlbumTypeFilter(DataShare::DataSharePredicates &predicates,
+    int32_t albumType, int32_t albumSubType)
+{
+    if (albumType != PhotoAlbumType::INVALID) {
+        predicates.And()->EqualTo(PhotoAlbumColumns::ALBUM_TYPE, to_string(albumType));
+    }
+    if (albumSubType != PhotoAlbumSubType::ANY) {
+        predicates.And()->EqualTo(PhotoAlbumColumns::ALBUM_SUBTYPE, to_string(albumSubType));
+        if (albumSubType == PhotoAlbumSubType::SHOOTING_MODE || albumSubType == PhotoAlbumSubType::GEOGRAPHY_CITY) {
+            predicates.OrderByDesc(PhotoAlbumColumns::ALBUM_COUNT);
+        }
+    }
+    if (PermissionUtils::IsSystemApp()) {
+        predicates.And()->NotEqualTo(PhotoAlbumColumns::ALBUM_SUBTYPE, to_string(PhotoAlbumSubType::HIDDEN));
+    } else {
+        predicates.And()->In(PhotoAlbumColumns::ALBUM_SUBTYPE, vector<string>({
+            to_string(PhotoAlbumSubType::USER_GENERIC),
+            to_string(PhotoAlbumSubType::FAVORITE),
+            to_string(PhotoAlbumSubType::VIDEO),
+            to_string(PhotoAlbumSubType::IMAGE),
+        }));
+    }
+}
+
+static NativeRdb::RdbPredicates GetAllLocationPredicates(DataShare::DataSharePredicates &predicates)
+{
+    predicates.EqualTo(MediaColumn::MEDIA_DATE_TRASHED, to_string(0));
+    predicates.EqualTo(MediaColumn::MEDIA_HIDDEN, to_string(0));
+    predicates.EqualTo(MediaColumn::MEDIA_TIME_PENDING, to_string(0));
+    predicates.EqualTo(PhotoColumn::PHOTO_IS_TEMP, to_string(0));
+    predicates.EqualTo(PhotoColumn::PHOTO_BURST_COVER_LEVEL,
+        to_string(static_cast<int32_t>(BurstCoverLevelType::COVER)));
+    predicates.And()->NotEqualTo(PhotoColumn::PHOTO_LATITUDE, to_string(0));
+    predicates.And()->NotEqualTo(PhotoColumn::PHOTO_LONGITUDE, to_string(0));
+    return RdbUtils::ToPredicates(predicates, PhotoColumn::PHOTOS_TABLE);
+}
+
+static void ReplacePredicatesColumn(DataShare::DataSharePredicates& predicates,
+    const std::string &oldColumn, const std::string &newColumn)
+{
+    constexpr int32_t fieldIdx = 0;
+    auto& items = predicates.GetOperationList();
+    std::vector<DataShare::OperationItem> tmpOperations = {};
+    for (const DataShare::OperationItem& item : items) {
+        if (item.singleParams.empty()) {
+            tmpOperations.push_back(item);
+            continue;
+        }
+        if (static_cast<string>(item.GetSingle(fieldIdx)) == oldColumn) {
+            DataShare::OperationItem tmpItem = item;
+            tmpItem.singleParams[fieldIdx] = newColumn;
+            tmpOperations.push_back(tmpItem);
+            continue;
+        }
+        tmpOperations.push_back(item);
+    }
+    predicates = DataShare::DataSharePredicates(move(tmpOperations));
+}
+
+static void AddHighlightAlbumPredicates(DataShare::DataSharePredicates& predicates, int32_t albumSubType)
+{
+    std::string analysisAlbumId = ANALYSIS_ALBUM_TABLE + "." + PhotoAlbumColumns::ALBUM_ID;
+    vector<string> onClause = {
+        analysisAlbumId + " = " + HIGHLIGHT_ALBUM_TABLE + "." + PhotoAlbumColumns::ALBUM_ID,
+    };
+    if (albumSubType == PhotoAlbumSubType::HIGHLIGHT_SUGGESTIONS) {
+        onClause = {
+            analysisAlbumId + " = " + HIGHLIGHT_ALBUM_TABLE + "." + AI_ALBUM_ID,
+        };
+    }
+    predicates.InnerJoin(HIGHLIGHT_ALBUM_TABLE)->On(onClause);
+    predicates.OrderByDesc(MAX_DATE_ADDED + ", " + GENERATE_TIME);
+    ReplacePredicatesColumn(predicates, PhotoAlbumColumns::ALBUM_ID, analysisAlbumId);
+}
+
+int32_t MediaAlbumsService::QueryAlbums(QueryAlbumsDto &dto)
+{
+    std::shared_ptr<NativeRdb::ResultSet> resultSet;
+    std::vector<std::string> &columns = dto.columns;
+    MediaLibraryRdbUtils::AddVirtualColumnsOfDateType(columns);
+    if (dto.albumType == PhotoAlbumType::SMART) {
+        if (dto.albumSubType == PhotoAlbumSubType::GEOGRAPHY_LOCATION) {
+            NativeRdb::RdbPredicates rdbPredicate = GetAllLocationPredicates(dto.predicates);
+            const auto &locations = PhotoAlbumColumns::LOCATION_DEFAULT_FETCH_COLUMNS;
+            columns.insert(columns.end(), locations.begin(), locations.end());
+            resultSet = MediaLibraryRdbStore::QueryWithFilter(rdbPredicate, columns);
+        } else if (dto.albumSubType == PhotoAlbumSubType::GEOGRAPHY_CITY) {
+            columns = PhotoAlbumColumns::CITY_DEFAULT_FETCH_COLUMNS;
+            std::string onClause = PhotoAlbumColumns::ALBUM_NAME  + " = " + CITY_ID;
+            dto.predicates.InnerJoin(GEO_DICTIONARY_TABLE)->On({ onClause });
+            dto.predicates.NotEqualTo(PhotoAlbumColumns::ALBUM_COUNT, to_string(0));
+            AddPhotoAlbumTypeFilter(dto.predicates, dto.albumType, dto.albumSubType);
+            MediaLibraryCommand cmd(OperationObject::ANALYSIS_PHOTO_ALBUM, OperationType::QUERY);
+            resultSet = MediaLibraryDataManager::QueryAnalysisAlbum(cmd, columns, dto.predicates);
+        } else {
+            AddDefaultPhotoAlbumColumns(columns);
+            if (dto.albumSubType == PhotoAlbumSubType::HIGHLIGHT ||
+                dto.albumSubType == PhotoAlbumSubType::HIGHLIGHT_SUGGESTIONS) {
+                AddHighlightAlbumPredicates(dto.predicates, dto.albumSubType);
+                std::string analysisAlbumId = ANALYSIS_ALBUM_TABLE + "." + PhotoAlbumColumns::ALBUM_ID +
+                    " AS " + PhotoAlbumColumns::ALBUM_ID;
+                ReplaceFetchColumn(columns, PhotoAlbumColumns::ALBUM_ID, analysisAlbumId);
+            }
+            AddPhotoAlbumTypeFilter(dto.predicates, dto.albumType, dto.albumSubType);
+            MediaLibraryCommand cmd(OperationObject::ANALYSIS_PHOTO_ALBUM, OperationType::QUERY);
+            resultSet = MediaLibraryDataManager::QueryAnalysisAlbum(cmd, columns, dto.predicates);
+        }
+    } else {
+        AddNoSmartFetchColumns(columns);
+        AddPhotoAlbumTypeFilter(dto.predicates, dto.albumType, dto.albumSubType);
+        NativeRdb::RdbPredicates rdbPredicate = RdbUtils::ToPredicates(dto.predicates, PhotoAlbumColumns::TABLE);
+        if (rdbPredicate.GetOrder().empty()) {
+            rdbPredicate.OrderByAsc(PhotoAlbumColumns::ALBUM_ORDER);
+        }
+        resultSet = MediaLibraryRdbStore::QueryWithFilter(rdbPredicate, columns);
+    }
+
+    LogQueryParams(dto.predicates, columns);
+
+    CHECK_AND_RETURN_RET_LOG(resultSet != nullptr, E_HAS_DB_ERROR, "resultSet nullptr");
+    auto bridge = RdbUtils::ToResultSetBridge(resultSet);
+    dto.resultSet = make_shared<DataShare::DataShareResultSet>(bridge);
+    return E_OK;
+}
+
+int32_t MediaAlbumsService::QueryHiddenAlbums(QueryAlbumsDto &dto)
+{
+    std::vector<std::string> &columns = dto.columns;
+    if (!CheckAlbumFetchColumns(columns)) {
+        return E_INVALID_VALUES;
+    }
+
+    AddDefaultPhotoAlbumColumns(columns);
+    if (dto.hiddenAlbumFetchMode == 1) {
+        columns.push_back(PhotoAlbumColumns::HIDDEN_COUNT);
+        columns.push_back(PhotoAlbumColumns::HIDDEN_COVER);
+        dto.predicates.And()->EqualTo(PhotoAlbumColumns::CONTAINS_HIDDEN, to_string(1));
+    } else {
+        dto.predicates.And()->EqualTo(PhotoAlbumColumns::ALBUM_SUBTYPE, PhotoAlbumSubType::HIDDEN);
+    }
+
+    NativeRdb::RdbPredicates rdbPredicate = RdbUtils::ToPredicates(dto.predicates, PhotoAlbumColumns::TABLE);
+    if (rdbPredicate.GetOrder().empty()) {
+        rdbPredicate.OrderByAsc(PhotoAlbumColumns::ALBUM_ORDER);
+    }
+
+    std::shared_ptr<NativeRdb::ResultSet> resultSet;
+    MediaLibraryRdbUtils::AddVirtualColumnsOfDateType(columns);
+    resultSet = MediaLibraryRdbStore::QueryWithFilter(rdbPredicate, columns);
+
+    LogQueryParams(dto.predicates, columns);
+
+    CHECK_AND_RETURN_RET_LOG(resultSet != nullptr, E_HAS_DB_ERROR, "resultSet nullptr");
+    auto bridge = RdbUtils::ToResultSetBridge(resultSet);
+    dto.resultSet = make_shared<DataShare::DataShareResultSet>(bridge);
+    return E_OK;
+}
+
+int32_t MediaAlbumsService::GetOrderPosition(const GetOrderPositionDto& getOrderPositionDto,
+    GetOrderPositionRespBody& resp)
+{
+    NativeRdb::RdbPredicates predicates(ANALYSIS_PHOTO_MAP_TABLE);
+    const string mapTable = ANALYSIS_PHOTO_MAP_TABLE;
+    predicates.EqualTo(mapTable + "." + MAP_ALBUM, getOrderPositionDto.albumId)->
+        And()->In(mapTable + "." + MAP_ASSET, getOrderPositionDto.assetIdArray);
+    std::vector<std::string> fetchColumn{MAP_ASSET, ORDER_POSITION};
+
+    auto resultSet = MediaLibraryRdbStore::QueryWithFilter(predicates, fetchColumn);
+    if (resultSet == nullptr) {
+        MEDIA_ERR_LOG("query resultSet is nullptr");
+        return E_ERR;
+    }
+
+    int count = 0;
+    int ret = resultSet->GetRowCount(count);
+    if (ret != NativeRdb::E_OK || count <= 0) {
+        MEDIA_ERR_LOG("GetRowCount failed, error code: %{public}d, count: %{public}d", ret, count);
+        return JS_INNER_FAIL;
+    }
+    unordered_map<std::string, int32_t> idOrderMap;
+    while (resultSet->GoToNextRow() == NativeRdb::E_OK) {
+        int32_t mapAsset = get<int32_t>(ResultSetUtils::GetValFromColumn(MAP_ASSET, resultSet, TYPE_INT32));
+        int32_t orderPosition = get<int32_t>(ResultSetUtils::GetValFromColumn(ORDER_POSITION, resultSet, TYPE_INT32));
+        idOrderMap[std::to_string(mapAsset)] = orderPosition;
+    }
+    resp.orderPositionArray.clear();
+    for (const string& assetId : getOrderPositionDto.assetIdArray) {
+        resp.orderPositionArray.push_back(idOrderMap[assetId]);
+    }
+    return E_OK;
+}
+
+int32_t MediaAlbumsService::GetFaceId(int32_t albumId, string& groupTag)
+{
+    return this->rdbOperation_.GetFaceId(albumId, groupTag);
+}
+
+int32_t MediaAlbumsService::GetPhotoIndex(GetPhotoIndexReqBody &reqBody, QueryResultRspBody &rspBody)
+{
+    DataShare::DataSharePredicates &predicates = reqBody.predicates;
+    predicates.And()->EqualTo(MediaColumn::MEDIA_DATE_TRASHED, to_string(0));
+    predicates.And()->EqualTo(MediaColumn::MEDIA_TIME_PENDING, to_string(0));
+    predicates.And()->EqualTo(MediaColumn::MEDIA_HIDDEN, to_string(0));
+    predicates.And()->EqualTo(PhotoColumn::PHOTO_IS_TEMP, to_string(0));
+    predicates.And()->EqualTo(PhotoColumn::PHOTO_BURST_COVER_LEVEL,
+        to_string(static_cast<int32_t>(BurstCoverLevelType::COVER)));
+    const string &photoId = reqBody.photoId;
+    const string &albumId = reqBody.albumId;
+
+    MediaLibraryCommand cmd(predicates);
+    shared_ptr<NativeRdb::ResultSet> resSet = nullptr;
+    if (reqBody.isAnalysisAlbum) {
+        resSet = MediaLibraryPhotoOperations::HandleAnalysisIndex(cmd, photoId, albumId);
+    } else {
+        NativeRdb::RdbPredicates predicates =
+            RdbDataShareAdapter::RdbUtils::ToPredicates(cmd.GetDataSharePred(), PhotoColumn::PHOTOS_TABLE);
+        resSet = MediaLibraryPhotoOperations::HandleIndexOfUri(cmd, predicates, photoId, albumId);
+    }
+    if (resSet == nullptr) {
+        return E_FAIL;
+    }
+    auto resultSetBridge = RdbDataShareAdapter::RdbUtils::ToResultSetBridge(resSet);
+    rspBody.resultSet = make_shared<DataShare::DataShareResultSet>(resultSetBridge);
+    return E_SUCCESS;
+}
+
+int32_t MediaAlbumsService::GetAnalysisProcess(GetAnalysisProcessReqBody &reqBody, QueryResultRspBody &rspBody)
+{
+    std::string tableName;
+    DataShare::DataSharePredicates predicates;
+    std::vector<std::string> columns;
+    if (reqBody.analysisType == static_cast<int32_t>(AnalysisType::ANALYSIS_LABEL)) {
+        tableName = VISION_TOTAL_TABLE;
+        columns = {
+            "COUNT(*) AS totalCount",
+            "SUM(CASE WHEN ((aesthetics_score != 0 AND label != 0 AND ocr != 0 AND face != 0 AND face != 1 "
+                "AND face != 2 "
+                "AND saliency != 0 AND segmentation != 0 AND head != 0 AND Photos.media_type = 1) OR "
+                "(label != 0 AND face != 0 AND Photos.media_type = 2)) THEN 1 ELSE 0 END) AS finishedCount",
+            "SUM(CASE WHEN label != 0 THEN 1 ELSE 0 END) AS LabelCount"
+        };
+        string clause = VISION_TOTAL_TABLE + "." + MediaColumn::MEDIA_ID + " = " + PhotoColumn::PHOTOS_TABLE+ "." +
+            MediaColumn::MEDIA_ID;
+        predicates.InnerJoin(PhotoColumn::PHOTOS_TABLE)->On({ clause });
+        predicates.EqualTo(PhotoColumn::PHOTO_HIDDEN_TIME, 0)->And()
+            ->EqualTo(MediaColumn::MEDIA_DATE_TRASHED, 0)->And()
+            ->EqualTo(MediaColumn::MEDIA_TIME_PENDING, 0);
+    } else if (reqBody.analysisType == static_cast<int32_t>(AnalysisType::ANALYSIS_FACE)) {
+        tableName = USER_PHOTOGRAPHY_INFO_TABLE;
+        std::vector<std::string> columns = {
+            HIGHLIGHT_ANALYSIS_PROGRESS
+        };
+    } else if (reqBody.analysisType == static_cast<int32_t>(AnalysisType::ANALYSIS_HIGHLIGHT)) {
+        tableName = HIGHLIGHT_ALBUM_TABLE;
+        columns = {
+            "SUM(CASE WHEN highlight_status = -3 THEN 1 ELSE 0 END) AS ClearCount",
+            "SUM(CASE WHEN highlight_status = -2 THEN 1 ELSE 0 END) AS DeleteCount",
+            "SUM(CASE WHEN highlight_status = -1 THEN 1 ELSE 0 END) AS NotProduceCount",
+            "SUM(CASE WHEN highlight_status > 0 THEN 1 ELSE 0 END) AS ProduceCount",
+            "SUM(CASE WHEN highlight_status = 1 THEN 1 ELSE 0 END) AS PushCount",
+        };
+    }
+    shared_ptr<NativeRdb::ResultSet> resSet = MediaLibraryRdbStore::QueryWithFilter(
+        RdbDataShareAdapter::RdbUtils::ToPredicates(predicates, tableName), columns);
+    if (resSet == nullptr) {
+        return E_FAIL;
+    }
+    auto resultSetBridge = RdbDataShareAdapter::RdbUtils::ToResultSetBridge(resSet);
+    rspBody.resultSet = make_shared<DataShare::DataShareResultSet>(resultSetBridge);
+    return E_SUCCESS;
+}
+
+int32_t MediaAlbumsService::GetHighlightAlbumInfo(GetHighlightAlbumReqBody &reqBody, QueryResultRspBody &rspBody)
+{
+    std::vector<std::string> columns;
+    DataShare::DataSharePredicates predicates;
+                                       
+    if (HIGHLIGHT_ALBUM_INFO_MAP.find(reqBody.highlightAlbumInfoType) != HIGHLIGHT_ALBUM_INFO_MAP.end()) {
+        columns = HIGHLIGHT_ALBUM_INFO_MAP.at(reqBody.highlightAlbumInfoType).fetchColumn;
+        string tabStr;
+        if (reqBody.highlightAlbumInfoType == COVER_INFO) {
+            tabStr = HIGHLIGHT_COVER_INFO_TABLE;
+        } else {
+            tabStr = HIGHLIGHT_PLAY_INFO_TABLE;
+        }
+        vector<string> onClause = {
+            tabStr + "." + PhotoAlbumColumns::ALBUM_ID + " = " +
+            HIGHLIGHT_ALBUM_TABLE + "." + ID
+        };
+        predicates.InnerJoin(HIGHLIGHT_ALBUM_TABLE)->On(onClause);
+    } else {
+        MEDIA_ERR_LOG("Invalid highlightAlbumInfoType");
+        return E_ERR;
+    }
+    int32_t albumId = reqBody.albumId;
+    int32_t subType = reqBody.subType;
+    if (subType == static_cast<int32_t>(PhotoAlbumSubType::HIGHLIGHT)) {
+        predicates.EqualTo(HIGHLIGHT_ALBUM_TABLE + "." + PhotoAlbumColumns::ALBUM_ID, to_string(albumId));
+    } else if (subType == static_cast<int32_t>(PhotoAlbumSubType::HIGHLIGHT_SUGGESTIONS)) {
+        predicates.EqualTo(HIGHLIGHT_ALBUM_TABLE + "." + AI_ALBUM_ID, to_string(albumId));
+    } else {
+        MEDIA_ERR_LOG("Invalid highlight album subType");
+        return E_ERR;
+    }
+
+    std::string tableName = "";
+    if (reqBody.highlightAlbumInfoType == static_cast<int32_t>(HighlightAlbumInfoType::COVER_INFO)) {
+        tableName = HIGHLIGHT_COVER_INFO_TABLE;
+    } else if (reqBody.highlightAlbumInfoType == static_cast<int32_t>(HighlightAlbumInfoType::PLAY_INFO)) {
+        tableName = HIGHLIGHT_PLAY_INFO_TABLE;
+    } else {
+        MEDIA_ERR_LOG("highlightAlbumInfoType not valid");
+        return E_ERR;
+    }
+
+    shared_ptr<NativeRdb::ResultSet> resSet = MediaLibraryRdbStore::QueryWithFilter(
+        RdbDataShareAdapter::RdbUtils::ToPredicates(predicates, tableName), columns);
+    if (resSet == nullptr) {
+        return E_FAIL;
+    }
+    auto resultSetBridge = RdbDataShareAdapter::RdbUtils::ToResultSetBridge(resSet);
+    rspBody.resultSet = make_shared<DataShare::DataShareResultSet>(resultSetBridge);
+    return E_SUCCESS;
+}
 } // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_albums_manager/src/vo/album_get_assets_vo.cpp b/services/media_albums_manager/src/vo/album_get_assets_vo.cpp
new file mode 100644
index 0000000000..d400a2ac04
--- /dev/null
+++ b/services/media_albums_manager/src/vo/album_get_assets_vo.cpp
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "album_get_assets_vo.h"
+
+#include "itypes_util.h"
+#include "media_log.h"
+
+namespace OHOS::Media {
+
+bool AlbumGetAssetsReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = DataShare::DataSharePredicates::Unmarshal(predicates, parcel);
+
+    CHECK_AND_RETURN_RET_LOG(status, false, "predicates Unmarshal failed");
+
+    return ITypesUtil::Unmarshal(parcel, columns);
+}
+
+bool AlbumGetAssetsReqBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = DataShare::DataSharePredicates::Marshal(predicates, parcel);
+
+    CHECK_AND_RETURN_RET_LOG(status, false, "predicates Marshal failed");
+
+    return ITypesUtil::Marshal(parcel, columns);
+}
+
+bool AlbumGetAssetsRespBody::Unmarshalling(MessageParcel &parcel)
+{
+    resultSet = DataShare::DataShareResultSet::Unmarshal(parcel);
+    CHECK_AND_RETURN_RET_LOG(resultSet != nullptr, false, "resultSet Unmarshal failed");
+    return true;
+}
+
+bool AlbumGetAssetsRespBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = resultSet == nullptr || !DataShare::DataShareResultSet::Marshal(resultSet, parcel);
+    CHECK_AND_RETURN_RET_LOG(!status, false, "resultSet Marshal failed");
+    return true;
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_albums_manager/src/vo/get_albums_by_ids_vo.cpp b/services/media_albums_manager/src/vo/get_albums_by_ids_vo.cpp
new file mode 100644
index 0000000000..b85e3243c4
--- /dev/null
+++ b/services/media_albums_manager/src/vo/get_albums_by_ids_vo.cpp
@@ -0,0 +1,81 @@
+ /*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "get_albums_by_ids_vo.h"
+
+#include <sstream>
+#include "media_log.h"
+#include "itypes_util.h"
+
+namespace OHOS::Media {
+
+bool GetAlbumsByIdsReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    if (!DataShare::DataSharePredicates::Unmarshal(this->predicates, parcel)) {
+        return false;
+    }
+    if (!ITypesUtil::Unmarshalling(this->columns, parcel)) {
+        return false;
+    }
+    return true;
+}
+
+bool GetAlbumsByIdsReqBody::Marshalling(MessageParcel &parcel) const
+{
+    if (!DataShare::DataSharePredicates::Marshal(this->predicates, parcel)) {
+        return false;
+    }
+    if (!ITypesUtil::Marshalling(this->columns, parcel)) {
+        return false;
+    }
+    return true;
+}
+
+
+std::string GetAlbumsByIdsReqBody::ToString() const
+{
+    std::stringstream ss;
+    // todo: add the content of GetAssetsReqBody
+    return ss.str();
+}
+
+bool GetAlbumsByIdsRspBody::Unmarshalling(MessageParcel &parcel)
+{
+    this->resultSet = DataShare::DataShareResultSet::Unmarshal(parcel);
+    if (this->resultSet == nullptr) {
+        MEDIA_ERR_LOG("QueueEditDataRspBody ReadFromParcel failed");
+        return false;
+    }
+    MEDIA_INFO_LOG("QueueEditDataRspBody ReadFromParcel success");
+    return true;
+}
+
+bool GetAlbumsByIdsRspBody::Marshalling(MessageParcel &parcel) const
+{
+    if (this->resultSet == nullptr || !DataShare::DataShareResultSet::Marshal(this->resultSet, parcel)) {
+        MEDIA_ERR_LOG("QueueEditDataRspBody Marshalling failed");
+        return false;
+    }
+    MEDIA_INFO_LOG("QueueEditDataRspBody Marshalling success");
+    return true;
+}
+
+std::string GetAlbumsByIdsRspBody::ToString() const
+{
+    std::stringstream ss;
+    // todo: add the content of GetAssetsRespBody
+    return ss.str();
+}
+};
\ No newline at end of file
diff --git a/services/media_albums_manager/src/vo/get_analysis_process_vo.cpp b/services/media_albums_manager/src/vo/get_analysis_process_vo.cpp
new file mode 100755
index 0000000000..e063111f64
--- /dev/null
+++ b/services/media_albums_manager/src/vo/get_analysis_process_vo.cpp
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "get_analysis_process_vo.h"
+
+#include <sstream>
+#include <string>
+#include <vector>
+
+#include "message_parcel.h"
+
+namespace OHOS::Media {
+
+bool GetAnalysisProcessReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    return parcel.ReadInt32(this->analysisType);
+}
+
+bool GetAnalysisProcessReqBody::Marshalling(MessageParcel &parcel) const
+{
+    return parcel.WriteInt32(this->analysisType);
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_albums_manager/src/vo/get_face_id_vo.cpp b/services/media_albums_manager/src/vo/get_face_id_vo.cpp
new file mode 100644
index 0000000000..7ad2acf85e
--- /dev/null
+++ b/services/media_albums_manager/src/vo/get_face_id_vo.cpp
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#define MLOG_TAG "MediaGetFaceIdVo"
+ 
+#include "get_face_id_vo.h"
+ 
+#include <sstream>
+ 
+#include "media_log.h"
+ 
+namespace OHOS::Media {
+using namespace std;
+bool GetFaceIdReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = parcel.ReadInt32(this->albumId);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.ReadInt32(this->albumSubType);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+ 
+bool GetFaceIdReqBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = parcel.WriteInt32(this->albumId);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.WriteInt32(this->albumSubType);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+bool GetFaceIdRespBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = parcel.ReadString(this->groupTag);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+ 
+bool GetFaceIdRespBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = parcel.WriteString(this->groupTag);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+} // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_albums_manager/src/vo/get_highlight_album_info_vo.cpp b/services/media_albums_manager/src/vo/get_highlight_album_info_vo.cpp
new file mode 100644
index 0000000000..4d31bb346b
--- /dev/null
+++ b/services/media_albums_manager/src/vo/get_highlight_album_info_vo.cpp
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "get_highlight_album_info_vo.h"
+
+#include <sstream>
+#include <string>
+#include <vector>
+
+#include "message_parcel.h"
+#include "media_log.h"
+
+namespace OHOS::Media {
+bool GetHighlightAlbumReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = parcel.ReadInt32(this->highlightAlbumInfoType);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.ReadInt32(this->albumId);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.ReadInt32(this->subType);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+bool GetHighlightAlbumReqBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = parcel.WriteInt32(this->highlightAlbumInfoType);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.WriteInt32(this->albumId);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.WriteInt32(this->subType);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_albums_manager/src/vo/get_order_position_vo.cpp b/services/media_albums_manager/src/vo/get_order_position_vo.cpp
new file mode 100755
index 0000000000..619c3f8e36
--- /dev/null
+++ b/services/media_albums_manager/src/vo/get_order_position_vo.cpp
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaGetOrderPositionVo"
+
+#include "get_order_position_vo.h"
+
+#include <sstream>
+
+#include "media_itypes_utils.h"
+#include "media_log.h"
+
+namespace OHOS::Media {
+using namespace std;
+bool GetOrderPositionReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = parcel.ReadInt32(this->albumId);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.ReadInt32(this->albumType);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.ReadInt32(this->albumSubType);
+    CHECK_AND_RETURN_RET(status, status);
+    status = IPC::ITypeMediaUtil::Unmarshalling<std::string>(this->assetIdArray, parcel);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+bool GetOrderPositionReqBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = parcel.WriteInt32(this->albumId);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.WriteInt32(this->albumType);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.WriteInt32(this->albumSubType);
+    CHECK_AND_RETURN_RET(status, status);
+    status = IPC::ITypeMediaUtil::Marshalling<std::string>(this->assetIdArray, parcel);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+bool GetOrderPositionRespBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = IPC::ITypeMediaUtil::Unmarshalling<int32_t>(this->orderPositionArray, parcel);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+bool GetOrderPositionRespBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = IPC::ITypeMediaUtil::Marshalling<int32_t>(this->orderPositionArray, parcel);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+} // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_albums_manager/src/vo/get_photo_index_vo.cpp b/services/media_albums_manager/src/vo/get_photo_index_vo.cpp
new file mode 100755
index 0000000000..76a438b949
--- /dev/null
+++ b/services/media_albums_manager/src/vo/get_photo_index_vo.cpp
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "get_photo_index_vo.h"
+
+#include <sstream>
+#include <string>
+#include <vector>
+
+#include "datashare_predicates.h"
+#include "message_parcel.h"
+#include "media_log.h"
+
+namespace OHOS::Media {
+bool GetPhotoIndexReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    if (!DataShare::DataSharePredicates::Unmarshal(this->predicates, parcel)) {
+        return false;
+    }
+    bool status = parcel.ReadBool(this->isAnalysisAlbum);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.ReadString(this->photoId);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.ReadString(this->albumId);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+bool GetPhotoIndexReqBody::Marshalling(MessageParcel &parcel) const
+{
+    if (!DataShare::DataSharePredicates::Marshal(this->predicates, parcel)) {
+        return false;
+    }
+    bool status = parcel.WriteBool(this->isAnalysisAlbum);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.WriteString(this->photoId);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.WriteString(this->albumId);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_albums_manager/src/vo/query_albums_vo.cpp b/services/media_albums_manager/src/vo/query_albums_vo.cpp
new file mode 100644
index 0000000000..511b58700f
--- /dev/null
+++ b/services/media_albums_manager/src/vo/query_albums_vo.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "query_albums_vo.h"
+
+#include "media_itypes_utils.h"
+#include "media_log.h"
+
+namespace OHOS::Media {
+
+bool QueryAlbumsReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = parcel.ReadInt32(this->albumType);
+    CHECK_AND_RETURN_RET_LOG(status, status, "Read albumType failed");
+    status = parcel.ReadInt32(this->albumSubType);
+    CHECK_AND_RETURN_RET_LOG(status, status, "Read albumSubType failed");
+    status = parcel.ReadInt32(this->hiddenAlbumFetchMode);
+    CHECK_AND_RETURN_RET_LOG(status, status, "Read hiddenAlbumFetchMode failed");
+    status = IPC::ITypeMediaUtil::Unmarshalling(this->columns, parcel);
+    CHECK_AND_RETURN_RET_LOG(status, status, "Unmarshalling columns failed");
+    return DataShare::DataSharePredicates::Unmarshal(this->predicates, parcel);
+}
+
+bool QueryAlbumsReqBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = parcel.WriteInt32(this->albumType);
+    CHECK_AND_RETURN_RET_LOG(status, status, "Write albumType failed");
+    status = parcel.WriteInt32(this->albumSubType);
+    CHECK_AND_RETURN_RET_LOG(status, status, "Write albumSubType failed");
+    status = parcel.WriteInt32(this->hiddenAlbumFetchMode);
+    CHECK_AND_RETURN_RET_LOG(status, status, "Write hiddenAlbumFetchMode failed");
+    status = IPC::ITypeMediaUtil::Marshalling(this->columns, parcel);
+    CHECK_AND_RETURN_RET_LOG(status, status, "Marshalling columns failed");
+    return DataShare::DataSharePredicates::Marshal(this->predicates, parcel);
+}
+
+bool QueryAlbumsRspBody::Unmarshalling(MessageParcel &parcel)
+{
+    this->resultSet = DataShare::DataShareResultSet::Unmarshal(parcel);
+    CHECK_AND_RETURN_RET_LOG(this->resultSet != nullptr, false, "resultSet nullptr");
+    return true;
+}
+
+bool QueryAlbumsRspBody::Marshalling(MessageParcel &parcel) const
+{
+    CHECK_AND_RETURN_RET_LOG(this->resultSet != nullptr, false, "resultSet nullptr");
+    return DataShare::DataShareResultSet::Marshal(this->resultSet, parcel);
+}
+} // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_albums_manager/src/vo/query_result_vo.cpp b/services/media_albums_manager/src/vo/query_result_vo.cpp
new file mode 100755
index 0000000000..b997139a39
--- /dev/null
+++ b/services/media_albums_manager/src/vo/query_result_vo.cpp
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "query_result_vo.h"
+
+#include <sstream>
+#include <string>
+#include <vector>
+
+#include "message_parcel.h"
+#include "media_log.h"
+
+namespace OHOS::Media {
+bool QueryResultRspBody::Unmarshalling(MessageParcel &parcel)
+{
+    this->resultSet = DataShare::DataShareResultSet::Unmarshal(parcel);
+    if (this->resultSet == nullptr) {
+        MEDIA_ERR_LOG("QueryResultRspBody ReadFromParcel failed");
+        return false;
+    }
+    MEDIA_INFO_LOG("QueryResultRspBody ReadFromParcel success");
+    return true;
+}
+
+bool QueryResultRspBody::Marshalling(MessageParcel &parcel) const
+{
+    if (this->resultSet == nullptr || !DataShare::DataShareResultSet::Marshal(this->resultSet, parcel)) {
+        MEDIA_ERR_LOG("QueryResultRspBody Marshalling failed");
+        return false;
+    }
+    MEDIA_INFO_LOG("QueryResultRspBody Marshalling success");
+    return true;
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/include/controller/media_assets_controller_service.h b/services/media_assets_manager/include/controller/media_assets_controller_service.h
index 8639f4d51c..3fbf32d9d6 100644
--- a/services/media_assets_manager/include/controller/media_assets_controller_service.h
+++ b/services/media_assets_manager/include/controller/media_assets_controller_service.h
@@ -52,6 +52,11 @@ public:
     EXPORT void SetOrientation(MessageParcel &data, MessageParcel &reply);
     EXPORT void SetVideoEnhancementAttr(MessageParcel &data, MessageParcel &reply);
     EXPORT void SetSupportedWatermarkType(MessageParcel &data, MessageParcel &reply);
+    EXPORT void GetAssets(MessageParcel &data, MessageParcel &reply, OHOS::Media::IPC::IPCContext &context);
+    EXPORT void GetBurstAssets(MessageParcel &data, MessageParcel &reply, OHOS::Media::IPC::IPCContext &context);
+    EXPORT void GetAllDuplicateAssets(MessageParcel &data, MessageParcel &reply);
+    EXPORT void GetDuplicateAssetsToDelete(MessageParcel &data, MessageParcel &reply);
+    EXPORT void GetIndexConstructProgress(MessageParcel &data, MessageParcel &reply);
     EXPORT void PublicCreateAsset(MessageParcel &data, MessageParcel &reply);
     EXPORT void SystemCreateAsset(MessageParcel &data, MessageParcel &reply);
     EXPORT void PublicCreateAssetForApp(MessageParcel &data, MessageParcel &reply);
@@ -63,6 +68,7 @@ public:
     EXPORT void SetAssetsHiddenStatus(MessageParcel &data, MessageParcel &reply);
     EXPORT void SetAssetsRecentShowStatus(MessageParcel &data, MessageParcel &reply);
     EXPORT void SetAssetsUserComment(MessageParcel &data, MessageParcel &reply);
+    EXPORT void GetAssetAnalysisData(MessageParcel &data, MessageParcel &reply);
     EXPORT void CloneAsset(MessageParcel &data, MessageParcel &reply);
     EXPORT void RevertToOriginal(MessageParcel &data, MessageParcel &reply);
     EXPORT void UpdateGalleryFormInfo(MessageParcel &data, MessageParcel &reply);
@@ -70,7 +76,6 @@ public:
     EXPORT void PrioritizeCloudEnhancementTask(MessageParcel &data, MessageParcel &reply);
     EXPORT void CancelCloudEnhancementTasks(MessageParcel &data, MessageParcel &reply);
     EXPORT void CancelAllCloudEnhancementTasks(MessageParcel &data, MessageParcel &reply);
-
     EXPORT void StartDownloadCloudMedia(MessageParcel &data, MessageParcel &reply);
     EXPORT void PauseDownloadCloudMedia(MessageParcel &data, MessageParcel &reply);
     EXPORT void CancelDownloadCloudMedia(MessageParcel &data, MessageParcel &reply);
@@ -86,6 +91,12 @@ public:
     EXPORT void CancelPhotoUriPermission(MessageParcel &data, MessageParcel &reply);
     EXPORT void StartThumbnailCreationTask(MessageParcel &data, MessageParcel &reply);
     EXPORT void StopThumbnailCreationTask(MessageParcel &data, MessageParcel &reply);
+    EXPORT void RequestContent(MessageParcel &data, MessageParcel &reply);
+    EXPORT void GetCloudEnhancementPair(MessageParcel &data, MessageParcel &reply);
+    EXPORT void QueryCloudEnhancementTaskState(MessageParcel &data, MessageParcel &reply);
+    EXPORT void SyncCloudEnhancementTaskStatus(MessageParcel &data, MessageParcel &reply);
+    EXPORT void QueryPhotoStatus(MessageParcel &data, MessageParcel &reply);
+    EXPORT void LogMovingPhoto(MessageParcel &data, MessageParcel &reply);
 public:
     virtual ~MediaAssetsControllerService() = default;
     bool Accept(uint32_t code) override;
diff --git a/services/media_assets_manager/include/dto/create_asset_dto.h b/services/media_assets_manager/include/dto/create_asset_dto.h
index bf66c16241..afdd44e05f 100644
--- a/services/media_assets_manager/include/dto/create_asset_dto.h
+++ b/services/media_assets_manager/include/dto/create_asset_dto.h
@@ -19,6 +19,8 @@
 #include <stdint.h>
 #include <string>
 
+#include "create_asset_vo.h"
+
 namespace OHOS::Media {
 class CreateAssetDto {
 public:
@@ -36,6 +38,11 @@ public:
 
     int32_t fileId{0};
     std::string outUri;
+
+public:
+    CreateAssetDto(const CreateAssetReqBody &reqBody);
+    CreateAssetDto(const CreateAssetForAppReqBody &reqBody);
+    CreateAssetRspBody GetRspBody();
 };
 }  // namespace OHOS::Media
 #endif  // OHOS_MEDIA_ASSETS_MANAGER_CREATE_ASSET_DTO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/dto/get_asset_analysis_data_dto.h b/services/media_assets_manager/include/dto/get_asset_analysis_data_dto.h
new file mode 100644
index 0000000000..d05ddd21c4
--- /dev/null
+++ b/services/media_assets_manager/include/dto/get_asset_analysis_data_dto.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_GET_ASSET_ANALYSIS_DATA_DTO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_GET_ASSET_ANALYSIS_DATA_DTO_H
+
+#include <stdint.h>
+#include <string>
+
+#include "datashare_result_set.h"
+
+namespace OHOS::Media {
+
+class GetAssetAnalysisDataDto {
+public:
+    int32_t fileId;
+    int32_t analysisType;
+    std::string language;
+    bool analysisTotal;
+
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_GET_ASSET_ANALYSIS_DATA_DTO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/dto/get_assets_dto.h b/services/media_assets_manager/include/dto/get_assets_dto.h
new file mode 100755
index 0000000000..59bb763949
--- /dev/null
+++ b/services/media_assets_manager/include/dto/get_assets_dto.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_GET_ASSETS_DTO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_GET_ASSETS_DTO_H
+
+#include "get_assets_vo.h"
+
+namespace OHOS::Media {
+class GetAssetsDto {
+public:
+    DataShare::DataSharePredicates predicates;
+    std::vector<std::string> columns;
+
+    static GetAssetsDto Create(const GetAssetsReqBody &req);
+};
+}  // namespace OHOS::Media
+#endif  // OHOS_MEDIA_ASSETS_MANAGER_GET_ASSETS_DTO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/dto/query_cloud_enhancement_task_state_dto.h b/services/media_assets_manager/include/dto/query_cloud_enhancement_task_state_dto.h
new file mode 100644
index 0000000000..0948b2d95a
--- /dev/null
+++ b/services/media_assets_manager/include/dto/query_cloud_enhancement_task_state_dto.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_QUERY_CLOUD_ENHANCEMENT_TASK_STATE_DTO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_QUERY_CLOUD_ENHANCEMENT_TASK_STATE_DTO_H
+
+#include <stdint.h>
+#include <string>
+
+namespace OHOS::Media {
+class QueryCloudEnhancementTaskStateDto {
+public:
+    std::string photoUri;
+    int32_t fileId{0};
+    std::string photoId;
+    int32_t ceAvailable{0};
+    int32_t CEErrorCode{0};
+public:
+    std::string ToString() const;
+};
+}  // namespace OHOS::Media
+#endif  // OHOS_MEDIA_ASSETS_MANAGER_QUERY_CLOUD_ENHANCEMENT_TASK_STATE_DTO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/media_assets_rdb_operations.h b/services/media_assets_manager/include/media_assets_rdb_operations.h
index d65fb3b69b..5259d81daf 100644
--- a/services/media_assets_manager/include/media_assets_rdb_operations.h
+++ b/services/media_assets_manager/include/media_assets_rdb_operations.h
@@ -26,6 +26,7 @@
 #include "file_asset.h"
 #include "medialibrary_operation.h"
 #include "datashare_values_bucket.h"
+#include "query_cloud_enhancement_task_state_dto.h"
 
 namespace OHOS::Media {
 
@@ -46,6 +47,7 @@ public:
     bool QueryFileIdIfExists(const std::string& fileId);
     bool QueryFormIdIfExists(const std::string& formId);
     int32_t CommitEditInsert(const std::string& editData, int32_t fileId);
+    int32_t QueryEnhancementTaskState(const std::string& photoUri, QueryCloudEnhancementTaskStateDto& dto);
     static void DeleteFromVisionTables(const std::string& fileId);
 
     int32_t GrantPhotoUriPermission(MediaLibraryCommand &cmd);
diff --git a/services/media_assets_manager/include/media_assets_service.h b/services/media_assets_manager/include/media_assets_service.h
index 19ed4aefca..e4266e27f8 100644
--- a/services/media_assets_manager/include/media_assets_service.h
+++ b/services/media_assets_manager/include/media_assets_service.h
@@ -23,6 +23,7 @@
 #include "form_info_dto.h"
 #include "commit_edited_asset_dto.h"
 #include "create_asset_dto.h"
+#include "get_asset_analysis_data_dto.h"
 #include "clone_asset_dto.h"
 #include "revert_to_original_dto.h"
 #include "cloud_enhancement_dto.h"
@@ -36,6 +37,10 @@
 #include "asset_change_create_asset_dto.h"
 #include "add_image_dto.h"
 #include "save_camera_photo_dto.h"
+#include "get_assets_dto.h"
+#include "query_cloud_enhancement_task_state_dto.h"
+#include "query_photo_vo.h"
+#include "adapted_vo.h"
 
 namespace OHOS::Media {
 class MediaAssetsService {
@@ -66,6 +71,10 @@ public:
     int32_t SetOrientation(const int32_t fileId, const int32_t orientation);
     int32_t SetVideoEnhancementAttr(const int32_t fileId, const std::string &photoId, const std::string &path);
     int32_t SetSupportedWatermarkType(const int32_t fileId, const int32_t watermarkType);
+    std::shared_ptr<DataShare::DataShareResultSet> GetAssets(const GetAssetsDto &dto);
+    std::shared_ptr<DataShare::DataShareResultSet> GetAllDuplicateAssets(const GetAssetsDto &dto);
+    std::shared_ptr<DataShare::DataShareResultSet> GetDuplicateAssetsToDelete(const GetAssetsDto &dto);
+    int32_t GetIndexConstructProgress(std::string &indexProgress);
     int32_t CreateAsset(CreateAssetDto &dto);
     int32_t CreateAssetForApp(CreateAssetDto &dto);
     int32_t CreateAssetForAppWithAlbum(CreateAssetDto &dto);
@@ -75,6 +84,7 @@ public:
     int32_t SetAssetsHiddenStatus(const std::vector<int32_t> &fileIds, int32_t hiddenStatus);
     int32_t SetAssetsRecentShowStatus(const std::vector<int32_t> &fileIds, int32_t recentShowStatus);
     int32_t SetAssetsUserComment(const std::vector<int32_t> &fileIds, const std::string &userComment);
+    int32_t GetAssetAnalysisData(GetAssetAnalysisDataDto &dto);
     int32_t CloneAsset(const CloneAssetDto& cloneAssetDto);
     int32_t RevertToOriginal(const RevertToOriginalDto& revertToOriginalDto);
     int32_t SubmitCloudEnhancementTasks(const CloudEnhancementDto& cloudEnhancementDto);
@@ -86,6 +96,13 @@ public:
     int32_t CancelPhotoUriPermission(const CancelUriPermissionDto& cancelUriPermissionDto);
     int32_t StartThumbnailCreationTask(const StartThumbnailCreationTaskDto& startThumbnailCreationTaskDto);
     int32_t StopThumbnailCreationTask(const StopThumbnailCreationTaskDto& stopThumbnailCreationTaskDto);
+    int32_t RequestContent(const std::string& mediaId, int32_t& position);
+    int32_t QueryCloudEnhancementTaskState(const std::string& photoUri, QueryCloudEnhancementTaskStateDto& dto);
+    std::shared_ptr<NativeRdb::ResultSet> GetCloudEnhancementPair(const std::string& photoUri);
+    int32_t SyncCloudEnhancementTaskStatus();
+    int32_t QueryPhotoStatus(const QueryPhotoReqBody &req, QueryPhotoRspBody &rsp);
+    int32_t LogMovingPhoto(const AdaptedReqBody &req);
+
 private:
     MediaAssetsRdbOperations rdbOperation_;
 };
diff --git a/services/media_assets_manager/include/vo/adapted_vo.h b/services/media_assets_manager/include/vo/adapted_vo.h
new file mode 100644
index 0000000000..40da866b87
--- /dev/null
+++ b/services/media_assets_manager/include/vo/adapted_vo.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_ADAPTED_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_ADAPTED_VO_H
+ 
+#include <string>
+ 
+#include "i_media_parcelable.h"
+ 
+namespace OHOS::Media {
+class AdaptedReqBody : public IPC::IMediaParcelable {
+public:
+    bool adapted;
+ 
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_ADAPTED_VO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/vo/create_asset_vo.h b/services/media_assets_manager/include/vo/create_asset_vo.h
index 6ae75f9860..d5a6215661 100644
--- a/services/media_assets_manager/include/vo/create_asset_vo.h
+++ b/services/media_assets_manager/include/vo/create_asset_vo.h
@@ -18,10 +18,8 @@
 
 #include <stdint.h>
 #include <string>
-#include <sstream>
 
 #include "i_media_parcelable.h"
-#include "create_asset_dto.h"
 
 namespace OHOS::Media {
 class CreateAssetReqBody : public IPC::IMediaParcelable {
@@ -36,8 +34,6 @@ public:
 public:  // functions of Parcelable.
     bool Unmarshalling(MessageParcel &parcel) override;
     bool Marshalling(MessageParcel &parcel) const override;
-public:
-    void Convert2Dto(CreateAssetDto &dto);
 };
 
 class CreateAssetRspBody : public IPC::IMediaParcelable {
@@ -48,8 +44,6 @@ public:
 public:  // functions of Parcelable.
     bool Unmarshalling(MessageParcel &parcel) override;
     bool Marshalling(MessageParcel &parcel) const override;
-public:
-    void InitByDto(const CreateAssetDto &dto);
 };
 
 class CreateAssetForAppReqBody : public IPC::IMediaParcelable {
@@ -67,8 +61,6 @@ public:
 public:  // functions of Parcelable.
     bool Unmarshalling(MessageParcel &parcel) override;
     bool Marshalling(MessageParcel &parcel) const override;
-public:
-    void Convert2Dto(CreateAssetDto &dto);
 };
 
 using CreateAssetForAppRspBody = CreateAssetRspBody;
diff --git a/services/media_assets_manager/include/vo/get_asset_analysis_data_vo.h b/services/media_assets_manager/include/vo/get_asset_analysis_data_vo.h
new file mode 100644
index 0000000000..ac2650b598
--- /dev/null
+++ b/services/media_assets_manager/include/vo/get_asset_analysis_data_vo.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_GET_ASSET_ANALYSIS_DATA_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_GET_ASSET_ANALYSIS_DATA_VO_H
+
+#include <stdint.h>
+#include <string>
+
+#include "i_media_parcelable.h"
+#include "datashare_result_set.h"
+
+namespace OHOS::Media {
+
+class GetAssetAnalysisDataReqBody : public IPC::IMediaParcelable {
+public:
+    int32_t fileId;
+    int32_t analysisType;
+    std::string language;
+    bool analysisTotal;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+
+class GetAssetAnalysisDataRspBody : public IPC::IMediaParcelable {
+public:
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_GET_ASSET_ANALYSIS_DATA_VO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/vo/get_assets_vo.h b/services/media_assets_manager/include/vo/get_assets_vo.h
new file mode 100755
index 0000000000..d9fe63d065
--- /dev/null
+++ b/services/media_assets_manager/include/vo/get_assets_vo.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_GET_ASSETS_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_GET_ASSETS_VO_H
+
+#include "datashare_predicates.h"
+#include "datashare_result_set.h"
+#include "i_media_parcelable.h"
+
+namespace OHOS::Media {
+class GetAssetsReqBody : public IPC::IMediaParcelable {
+public:
+    DataShare::DataSharePredicates predicates;
+    std::vector<std::string> columns;
+    std::string burstKey;
+
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+
+class GetAssetsRespBody : public IPC::IMediaParcelable {
+public:
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+}  // namespace OHOS::Media
+#endif  // OHOS_MEDIA_ASSETS_MANAGER_GET_ASSETS_VO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/vo/get_cloud_enhancement_pair_vo.h b/services/media_assets_manager/include/vo/get_cloud_enhancement_pair_vo.h
new file mode 100644
index 0000000000..080e35b587
--- /dev/null
+++ b/services/media_assets_manager/include/vo/get_cloud_enhancement_pair_vo.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_GET_CLOUD_ENHANCEMENT_PAIR_VO_H
+#define OHOS_MEDIA_GET_CLOUD_ENHANCEMENT_PAIR_VO_H
+
+#include <string>
+ 
+#include "i_media_parcelable.h"
+#include "datashare_result_set.h"
+ 
+namespace OHOS::Media {
+class GetCloudEnhancementPairReqBody : public IPC::IMediaParcelable {
+public:
+    std::string photoUri;
+ 
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+ 
+public:  // basic functions
+    std::string ToString() const;
+};
+
+class GetCloudEnhancementPairRespBody : public IPC::IMediaParcelable {
+public:
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_GET_CLOUD_ENHANCEMENT_PAIR_VO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/vo/get_cloudmedia_asset_status_vo.h b/services/media_assets_manager/include/vo/get_cloudmedia_asset_status_vo.h
new file mode 100644
index 0000000000..ecdf58d20d
--- /dev/null
+++ b/services/media_assets_manager/include/vo/get_cloudmedia_asset_status_vo.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_GET_CLOUD_MEDIA_ASSET_STATUS_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_GET_CLOUD_MEDIA_ASSET_STATUS_VO_H
+
+#include <string>
+
+#include "i_media_parcelable.h"
+
+namespace OHOS::Media {
+class GetCloudMediaAssetStatusReqBody : public IPC::IMediaParcelable {
+public:
+    std::string status;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+
+public:  // basic functions
+    std::string ToString() const;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_GET_CLOUD_MEDIA_ASSET_STATUS_VO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/vo/get_edit_data_vo.h b/services/media_assets_manager/include/vo/get_edit_data_vo.h
new file mode 100644
index 0000000000..334a888743
--- /dev/null
+++ b/services/media_assets_manager/include/vo/get_edit_data_vo.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_GET_EDIT_DATA_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_GET_EDIT_DATA_VO_H
+
+#include <string>
+#include <vector>
+#include "i_media_parcelable.h"
+#include "datashare_predicates.h"
+#include "datashare_result_set.h"
+#include "data_ability_predicates.h"
+
+namespace OHOS::Media {
+class GetEditDataReqBody : public IPC::IMediaParcelable {
+public:
+    DataShare::DataSharePredicates predicates;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+
+public:  // basic functions
+    std::string ToString() const;
+};
+
+class GetEditDataRspBody : public IPC::IMediaParcelable {
+public:
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+
+public:  // basic functions
+    std::string ToString() const;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_GET_EDIT_DATA_VO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/vo/get_index_construct_progress_vo.h b/services/media_assets_manager/include/vo/get_index_construct_progress_vo.h
new file mode 100755
index 0000000000..4fbe782093
--- /dev/null
+++ b/services/media_assets_manager/include/vo/get_index_construct_progress_vo.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_GET_INDEX_CONSTRUCT_PROGRESS_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_GET_INDEX_CONSTRUCT_PROGRESS_VO_H
+
+#include "i_media_parcelable.h"
+
+namespace OHOS::Media {
+class GetIndexConstructProgressRespBody : public IPC::IMediaParcelable {
+public:
+    std::string indexProgress;
+
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+}  // namespace OHOS::Media
+#endif  // OHOS_MEDIA_ASSETS_MANAGER_GET_INDEX_CONSTRUCT_PROGRESS_VO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/vo/is_edited_vo.h b/services/media_assets_manager/include/vo/is_edited_vo.h
new file mode 100644
index 0000000000..a633407cc4
--- /dev/null
+++ b/services/media_assets_manager/include/vo/is_edited_vo.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_IS_EDITED_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_IS_EDITED_VO_H
+
+#include <string>
+#include <vector>
+#include "i_media_parcelable.h"
+#include "datashare_predicates.h"
+#include "datashare_result_set.h"
+#include "data_ability_predicates.h"
+
+namespace OHOS::Media {
+class IsEditedReqBody : public IPC::IMediaParcelable {
+public:
+    int32_t fileId = 0;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+
+class IsEditedRspBody : public IPC::IMediaParcelable {
+public:
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+
+public:  // basic functions
+    std::string ToString() const;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_IS_EDITED_VO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/vo/modify_assets_vo.h b/services/media_assets_manager/include/vo/modify_assets_vo.h
index 82c747a0cc..a4073857f5 100644
--- a/services/media_assets_manager/include/vo/modify_assets_vo.h
+++ b/services/media_assets_manager/include/vo/modify_assets_vo.h
@@ -18,7 +18,6 @@
 
 #include <stdint.h>
 #include <string>
-#include <sstream>
 #include <vector>
 
 #include "i_media_parcelable.h"
diff --git a/services/media_assets_manager/include/vo/query_cloud_enhancement_task_state_vo.h b/services/media_assets_manager/include/vo/query_cloud_enhancement_task_state_vo.h
new file mode 100644
index 0000000000..bc7cd8c00c
--- /dev/null
+++ b/services/media_assets_manager/include/vo/query_cloud_enhancement_task_state_vo.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_QUERY_CLOUD_ENHANCEMENT_TASK_STATE_VO_H
+#define OHOS_MEDIA_QUERY_CLOUD_ENHANCEMENT_TASK_STATE_VO_H
+
+#include <string>
+
+#include "i_media_parcelable.h"
+#include "message_parcel.h"
+
+namespace OHOS::Media {
+class QueryCloudEnhancementTaskStateReqBody : public IPC::IMediaParcelable {
+public:
+    std::string photoUri;
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+ 
+public:  // basic functions
+    std::string ToString() const;
+};
+
+class QueryCloudEnhancementTaskStateRespBody : public IPC::IMediaParcelable {
+public:
+    int32_t fileId;
+    std::string photoId;
+    int32_t ceAvailable;
+    int32_t CEErrorCode;
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+ 
+public:  // basic functions
+    std::string ToString() const;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_QUERY_CLOUD_ENHANCEMENT_TASK_STATE_VO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/vo/query_photo_vo.h b/services/media_assets_manager/include/vo/query_photo_vo.h
new file mode 100644
index 0000000000..6aa5f66ab0
--- /dev/null
+++ b/services/media_assets_manager/include/vo/query_photo_vo.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_QUERY_PHOTO_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_QUERY_PHOTO_VO_H
+ 
+#include <string>
+ 
+#include "i_media_parcelable.h"
+ 
+namespace OHOS::Media {
+class QueryPhotoReqBody : public IPC::IMediaParcelable {
+public:
+    std::string fileId;
+ 
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+
+class QueryPhotoRspBody : public IPC::IMediaParcelable {
+public:
+    std::string photoId;
+    int32_t photoQuality;
+ 
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_QUERY_PHOTO_VO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/vo/request_content_vo.h b/services/media_assets_manager/include/vo/request_content_vo.h
new file mode 100755
index 0000000000..377d9cc34d
--- /dev/null
+++ b/services/media_assets_manager/include/vo/request_content_vo.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_REQUEST_CONTENT_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_REQUEST_CONTENT_VO_H
+
+#include <string>
+
+#include "i_media_parcelable.h"
+
+namespace OHOS::Media {
+class RequestContentReqBody : public IPC::IMediaParcelable {
+public:
+    std::string mediaId;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+
+class RequestContentRespBody : public IPC::IMediaParcelable {
+public:
+    int32_t position {0};
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_REQUEST_CONTENT_VO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/vo/request_edit_data_vo.h b/services/media_assets_manager/include/vo/request_edit_data_vo.h
new file mode 100644
index 0000000000..1b352a007b
--- /dev/null
+++ b/services/media_assets_manager/include/vo/request_edit_data_vo.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_REQUEST_EDIT_DATA_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_REQUEST_EDIT_DATA_VO_H
+
+#include <string>
+#include <vector>
+#include "i_media_parcelable.h"
+#include "datashare_predicates.h"
+#include "datashare_result_set.h"
+#include "data_ability_predicates.h"
+
+namespace OHOS::Media {
+class RequestEditDataReqBody : public IPC::IMediaParcelable {
+public:
+    DataShare::DataSharePredicates predicates;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+
+public:  // basic functions
+    std::string ToString() const;
+};
+
+class RequestEditDataRspBody : public IPC::IMediaParcelable {
+public:
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+
+public:  // basic functions
+    std::string ToString() const;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_REQUEST_EDIT_DATA_VO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/include/vo/start_asset_analysis_vo.h b/services/media_assets_manager/include/vo/start_asset_analysis_vo.h
new file mode 100644
index 0000000000..a431945a9d
--- /dev/null
+++ b/services/media_assets_manager/include/vo/start_asset_analysis_vo.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OHOS_MEDIA_ASSETS_MANAGER_START_ASSET_ANALYSIS_VO_H
+#define OHOS_MEDIA_ASSETS_MANAGER_START_ASSET_ANALYSIS_VO_H
+
+#include <string>
+#include <vector>
+#include "i_media_parcelable.h"
+#include "datashare_predicates.h"
+#include "datashare_result_set.h"
+#include "data_ability_predicates.h"
+
+namespace OHOS::Media {
+class StartAssetAnalysisReqBody : public IPC::IMediaParcelable {
+public:
+    DataShare::DataSharePredicates predicates;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+
+public:  // basic functions
+    std::string ToString() const;
+};
+
+class StartAssetAnalysisRspBody : public IPC::IMediaParcelable {
+public:
+    std::shared_ptr<DataShare::DataShareResultSet> resultSet;
+
+public:  // functions of Parcelable.
+    bool Unmarshalling(MessageParcel &parcel) override;
+    bool Marshalling(MessageParcel &parcel) const override;
+
+public:  // basic functions
+    std::string ToString() const;
+};
+} // namespace OHOS::Media
+#endif // OHOS_MEDIA_ASSETS_MANAGER_START_ASSET_ANALYSIS_VO_H
\ No newline at end of file
diff --git a/services/media_assets_manager/src/controller/media_assets_controller_service.cpp b/services/media_assets_manager/src/controller/media_assets_controller_service.cpp
index 84a586bf45..d7ca2dd414 100644
--- a/services/media_assets_manager/src/controller/media_assets_controller_service.cpp
+++ b/services/media_assets_manager/src/controller/media_assets_controller_service.cpp
@@ -19,6 +19,7 @@
 #include "media_assets_service.h"
 #include "media_log.h"
 #include "create_asset_vo.h"
+#include "create_asset_dto.h"
 #include "form_info_vo.h"
 #include "form_info_dto.h"
 #include "modify_assets_vo.h"
@@ -35,7 +36,6 @@
 #include "media_file_utils.h"
 #include "cloud_enhancement_vo.h"
 #include "cloud_enhancement_dto.h"
-
 #include "start_download_cloud_media_vo.h"
 #include "retain_cloud_media_asset_vo.h"
 #include "cloud_media_asset_manager.h"
@@ -45,11 +45,59 @@
 #include "start_thumbnail_creation_task_vo.h"
 #include "stop_thumbnail_creation_task_vo.h"
 #include "thumbnail_service.h"
+#include "get_asset_analysis_data_vo.h"
+#include "get_asset_analysis_data_dto.h"
+#include "is_edited_vo.h"
+#include "request_edit_data_vo.h"
+#include "get_edit_data_vo.h"
+#include "start_asset_analysis_vo.h"
+#include "get_cloudmedia_asset_status_vo.h"
+#include "medialibrary_photo_operations.h"
+#include "rdb_utils.h"
+#include "medialibrary_rdbstore.h"
+#include "medialibrary_vision_operations.h"
+#include "cloud_media_asset_manager.h"
+#include "request_content_vo.h"
+#include "get_cloud_enhancement_pair_vo.h"
+#include "query_cloud_enhancement_task_state_vo.h"
+#include "query_cloud_enhancement_task_state_dto.h"
+#include "vision_photo_map_column.h"
+#include "photo_map_operations.h"
+#include "photo_album_column.h"
+#include "photo_map_column.h"
+#include "result_set_utils.h"
+#include "medialibrary_album_operations.h"
+#include "vision_album_column.h"
+#include "medialibrary_analysis_album_operations.h"
+#include "adapted_vo.h"
+#include "get_photo_index_vo.h"
+#include "query_photo_vo.h"
+#include "get_highlight_album_info_vo.h"
+#include "get_analysis_process_vo.h"
+#include "get_index_construct_progress_vo.h"
+#include "medialibrary_rdb_utils.h"
+#include "permission_common.h"
 
 namespace OHOS::Media {
 using namespace std;
+using namespace OHOS::RdbDataShareAdapter;
+
+using SpecialRequestHandle = void (MediaAssetsControllerService::*)(
+    MessageParcel &, MessageParcel &, OHOS::Media::IPC::IPCContext &);
+
 using RequestHandle = void (MediaAssetsControllerService::*)(MessageParcel &, MessageParcel &);
 
+const std::map<uint32_t, SpecialRequestHandle> SPECIAL_HANDLERS = {
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_GET_ASSETS),
+        &MediaAssetsControllerService::GetAssets
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::GET_BURST_ASSETS),
+        &MediaAssetsControllerService::GetBurstAssets
+    },
+};
+
 const std::map<uint32_t, RequestHandle> HANDLERS = {
     {
         static_cast<uint32_t>(MediaLibraryBusinessCode::REMOVE_FORM_INFO),
@@ -151,6 +199,18 @@ const std::map<uint32_t, RequestHandle> HANDLERS = {
         static_cast<uint32_t>(MediaLibraryBusinessCode::SET_SUPPORTED_WATERMARK_TYPE),
         &MediaAssetsControllerService::SetSupportedWatermarkType
     },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::FIND_ALL_DUPLICATE_ASSETS),
+        &MediaAssetsControllerService::GetAllDuplicateAssets
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::FIND_DUPLICATE_ASSETS_TO_DELETE),
+        &MediaAssetsControllerService::GetDuplicateAssetsToDelete
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::GET_INDEX_CONSTRUCT_PROGRESS),
+        &MediaAssetsControllerService::GetIndexConstructProgress
+    },
     {
         static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_PUBLIC_CREATE_ASSET),
         &MediaAssetsControllerService::PublicCreateAsset
@@ -207,6 +267,10 @@ const std::map<uint32_t, RequestHandle> HANDLERS = {
         static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_SYSTEM_BATCH_SET_USER_COMMENT),
         &MediaAssetsControllerService::SetAssetsUserComment
     },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_GET_ASSET_ANALYSIS_DATA),
+        &MediaAssetsControllerService::GetAssetAnalysisData
+    },
     {
         static_cast<uint32_t>(MediaLibraryBusinessCode::CLONE_ASSET),
         &MediaAssetsControllerService::CloneAsset
@@ -271,21 +335,69 @@ const std::map<uint32_t, RequestHandle> HANDLERS = {
         static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_STOP_THUMBNAIL_CREATION_TASK),
         &MediaAssetsControllerService::StopThumbnailCreationTask
     },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_IS_EDITED),
+        &MediaAssetsControllerService::IsEdited
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_REQUEST_EDIT_DATA),
+        &MediaAssetsControllerService::RequestEditData
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_GET_EDIT_DATA),
+        &MediaAssetsControllerService::GetEditData
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_GET_CLOUDMEDIA_ASSET_STATUS),
+        &MediaAssetsControllerService::GetCloudMediaAssetStatus
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_START_ASSET_ANALYSIS),
+        &MediaAssetsControllerService::StartAssetAnalysis
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_REQUEST_CONTENT),
+        &MediaAssetsControllerService::RequestContent
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::GET_CLOUD_ENHANCEMENT_PAIR),
+        &MediaAssetsControllerService::GetCloudEnhancementPair
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::QUERY_CLOUD_ENHANCEMENT_TASK_STATE),
+        &MediaAssetsControllerService::QueryCloudEnhancementTaskState
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::SYNC_CLOUD_ENHANCEMENT_TASK_STATUS),
+        &MediaAssetsControllerService::SyncCloudEnhancementTaskStatus
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::QUERY_PHOTO_STATUS),
+        &MediaAssetsControllerService::QueryPhotoStatus
+    },
+    {
+        static_cast<uint32_t>(MediaLibraryBusinessCode::LOG_MOVING_PHOTO),
+        &MediaAssetsControllerService::LogMovingPhoto
+    },
 };
 
 bool MediaAssetsControllerService::Accept(uint32_t code)
 {
-    return HANDLERS.find(code) != HANDLERS.end();
+    return HANDLERS.find(code) != HANDLERS.end() || SPECIAL_HANDLERS.find(code) != SPECIAL_HANDLERS.end();
 }
 
-void MediaAssetsControllerService::OnRemoteRequest(uint32_t code, MessageParcel &data,
-    MessageParcel &reply, OHOS::Media::IPC::IPCContext &context)
+void MediaAssetsControllerService::OnRemoteRequest(
+    uint32_t code, MessageParcel &data, MessageParcel &reply, OHOS::Media::IPC::IPCContext &context)
 {
-    auto it = HANDLERS.find(code);
-    if (it == HANDLERS.end()) {
-        return IPC::UserDefineIPC().WriteResponseBody(reply, E_IPC_SEVICE_NOT_FOUND);
+    auto handlersIt = HANDLERS.find(code);
+    if (handlersIt != HANDLERS.end()) {
+        return (this->*(handlersIt->second))(data, reply);
     }
-    return (this->*(it->second))(data, reply);
+    auto specialHandlersIt = SPECIAL_HANDLERS.find(code);
+    if (specialHandlersIt != SPECIAL_HANDLERS.end()) {
+        return (this->*(specialHandlersIt->second))(data, reply, context);
+    }
+    return IPC::UserDefineIPC().WriteResponseBody(reply, E_IPC_SEVICE_NOT_FOUND);
 }
 
 void MediaAssetsControllerService::RemoveFormInfo(MessageParcel &data, MessageParcel &reply)
@@ -842,6 +954,162 @@ void MediaAssetsControllerService::SetSupportedWatermarkType(MessageParcel &data
     IPC::UserDefineIPC().WriteResponseBody(reply, ret);
 }
 
+void MediaAssetsControllerService::GetAssets(
+    MessageParcel &data, MessageParcel &reply, OHOS::Media::IPC::IPCContext &context)
+{
+    MEDIA_INFO_LOG("enter");
+    GetAssetsReqBody reqBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+
+    ret = ParameterUtils::CheckWhereClause(reqBody.predicates.GetWhereClause());
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("CheckWhereClause fialed");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+    GetAssetsDto dto = GetAssetsDto::Create(reqBody);
+    if (context.GetByPassCode() == E_PERMISSION_DB_BYPASS) {
+        string clientAppId = GetClientAppId();
+        if (clientAppId.empty()) {
+            MEDIA_ERR_LOG("clientAppId is empty");
+            IPC::UserDefineIPC().WriteResponseBody(reply, Media::E_PERMISSION_DENIED);
+            return;
+        }
+        dto.predicates.And()->EqualTo("owner_appid", clientAppId);
+    }
+    MediaLibraryRdbUtils::AddVirtualColumnsOfDateType(dto.columns);
+    auto resultSet = MediaAssetsService::GetInstance().GetAssets(dto);
+    if (resultSet == nullptr) {
+        MEDIA_ERR_LOG("resultSet is null");
+        IPC::UserDefineIPC().WriteResponseBody(reply, E_FAIL);
+        return;
+    }
+    GetAssetsRespBody respBody;
+    respBody.resultSet = resultSet;
+    IPC::UserDefineIPC().WriteResponseBody(reply, respBody);
+}
+
+void MediaAssetsControllerService::GetBurstAssets(
+    MessageParcel &data, MessageParcel &reply, OHOS::Media::IPC::IPCContext &context)
+{
+    MEDIA_INFO_LOG("enter");
+    GetAssetsReqBody reqBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+
+    ret = ParameterUtils::CheckWhereClause(reqBody.predicates.GetWhereClause());
+    if (ret != E_OK || reqBody.burstKey.empty()) {
+        MEDIA_ERR_LOG("CheckWhereClause fialed or burstKey is empty");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+    GetAssetsDto dto = GetAssetsDto::Create(reqBody);
+    if (context.GetByPassCode() == E_PERMISSION_DB_BYPASS) {
+        string clientAppId = GetClientAppId();
+        if (clientAppId.empty()) {
+            MEDIA_ERR_LOG("clientAppId is empty");
+            IPC::UserDefineIPC().WriteResponseBody(reply, Media::E_PERMISSION_DENIED);
+            return;
+        }
+        dto.predicates.And()->EqualTo("owner_appid", clientAppId);
+    }
+    dto.predicates.OrderByAsc(MediaColumn::MEDIA_NAME);
+    MediaLibraryRdbUtils::AddVirtualColumnsOfDateType(dto.columns);
+    auto resultSet = MediaAssetsService::GetInstance().GetAssets(dto);
+    if (resultSet == nullptr) {
+        MEDIA_ERR_LOG("resultSet is null");
+        IPC::UserDefineIPC().WriteResponseBody(reply, E_FAIL);
+        return;
+    }
+    GetAssetsRespBody respBody;
+    respBody.resultSet = resultSet;
+    IPC::UserDefineIPC().WriteResponseBody(reply, respBody);
+}
+
+void MediaAssetsControllerService::GetAllDuplicateAssets(MessageParcel &data, MessageParcel &reply)
+{
+    MEDIA_INFO_LOG("enter");
+    GetAssetsReqBody reqBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+
+    ret = ParameterUtils::CheckWhereClause(reqBody.predicates.GetWhereClause());
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("CheckWhereClause fialed");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+    GetAssetsDto dto = GetAssetsDto::Create(reqBody);
+    MediaLibraryRdbUtils::AddVirtualColumnsOfDateType(dto.columns);
+    auto resultSet = MediaAssetsService::GetInstance().GetAllDuplicateAssets(dto);
+    if (resultSet == nullptr) {
+        MEDIA_ERR_LOG("resultSet is null");
+        IPC::UserDefineIPC().WriteResponseBody(reply, E_FAIL);
+        return;
+    }
+    GetAssetsRespBody respBody;
+    respBody.resultSet = resultSet;
+    IPC::UserDefineIPC().WriteResponseBody(reply, respBody);
+}
+
+void MediaAssetsControllerService::GetDuplicateAssetsToDelete(MessageParcel &data, MessageParcel &reply)
+{
+    MEDIA_INFO_LOG("enter");
+    GetAssetsReqBody reqBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+
+    ret = ParameterUtils::CheckWhereClause(reqBody.predicates.GetWhereClause());
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("CheckWhereClause fialed");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+    GetAssetsDto dto = GetAssetsDto::Create(reqBody);
+    MediaLibraryRdbUtils::AddVirtualColumnsOfDateType(dto.columns);
+    auto resultSet = MediaAssetsService::GetInstance().GetDuplicateAssetsToDelete(dto);
+    if (resultSet == nullptr) {
+        MEDIA_ERR_LOG("resultSet is null");
+        IPC::UserDefineIPC().WriteResponseBody(reply, E_FAIL);
+        return;
+    }
+    GetAssetsRespBody respBody;
+    respBody.resultSet = resultSet;
+    IPC::UserDefineIPC().WriteResponseBody(reply, respBody);
+}
+
+void MediaAssetsControllerService::GetIndexConstructProgress(MessageParcel &data, MessageParcel &reply)
+{
+    MEDIA_INFO_LOG("enter");
+    std::string indexProgress;
+    auto ret = MediaAssetsService::GetInstance().GetIndexConstructProgress(indexProgress);
+    if (ret != E_OK) {
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        MEDIA_ERR_LOG("get index construct progress failed, ret: %{public}d", ret);
+        return;
+    }
+    GetIndexConstructProgressRespBody respBody;
+    respBody.indexProgress = indexProgress;
+    IPC::UserDefineIPC().WriteResponseBody(reply, respBody);
+}
+
 void MediaAssetsControllerService::PublicCreateAsset(MessageParcel &data, MessageParcel &reply)
 {
     CreateAssetReqBody reqBody;
@@ -861,13 +1129,9 @@ void MediaAssetsControllerService::PublicCreateAsset(MessageParcel &data, Messag
         return;
     }
 
-    CreateAssetDto dto;
-    reqBody.Convert2Dto(dto);
+    CreateAssetDto dto(reqBody);
     ret = MediaAssetsService::GetInstance().CreateAsset(dto);
-    if (ret == E_OK) {
-        rspBody.InitByDto(dto);
-    }
-    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+    IPC::UserDefineIPC().WriteResponseBody(reply, dto.GetRspBody(), ret);
 }
 
 void MediaAssetsControllerService::SystemCreateAsset(MessageParcel &data, MessageParcel &reply)
@@ -888,14 +1152,10 @@ void MediaAssetsControllerService::SystemCreateAsset(MessageParcel &data, Messag
         return;
     }
 
-    CreateAssetDto dto;
-    reqBody.Convert2Dto(dto);
+    CreateAssetDto dto(reqBody);
     (void)ParameterUtils::GetTitleAndExtension(dto.displayName, dto.title, dto.extension);
     ret = MediaAssetsService::GetInstance().CreateAsset(dto);
-    if (ret == E_OK) {
-        rspBody.InitByDto(dto);
-    }
-    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+    IPC::UserDefineIPC().WriteResponseBody(reply, dto.GetRspBody(), ret);
 }
 
 void MediaAssetsControllerService::PublicCreateAssetForApp(MessageParcel &data, MessageParcel &reply)
@@ -916,13 +1176,9 @@ void MediaAssetsControllerService::PublicCreateAssetForApp(MessageParcel &data,
         return;
     }
 
-    CreateAssetDto dto;
-    reqBody.Convert2Dto(dto);
+    CreateAssetDto dto(reqBody);
     ret = MediaAssetsService::GetInstance().CreateAssetForApp(dto);
-    if (ret == E_OK) {
-        rspBody.InitByDto(dto);
-    }
-    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+    IPC::UserDefineIPC().WriteResponseBody(reply, dto.GetRspBody(), ret);
 }
 
 void MediaAssetsControllerService::SystemCreateAssetForApp(MessageParcel &data, MessageParcel &reply)
@@ -943,13 +1199,9 @@ void MediaAssetsControllerService::SystemCreateAssetForApp(MessageParcel &data,
         return;
     }
 
-    CreateAssetDto dto;
-    reqBody.Convert2Dto(dto);
+    CreateAssetDto dto(reqBody);
     ret = MediaAssetsService::GetInstance().CreateAssetForApp(dto);
-    if (ret == E_OK) {
-        rspBody.InitByDto(dto);
-    }
-    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+    IPC::UserDefineIPC().WriteResponseBody(reply, dto.GetRspBody(), ret);
 }
 
 void MediaAssetsControllerService::CreateAssetForAppWithAlbum(MessageParcel &data, MessageParcel &reply)
@@ -970,13 +1222,9 @@ void MediaAssetsControllerService::CreateAssetForAppWithAlbum(MessageParcel &dat
         return;
     }
 
-    CreateAssetDto dto;
-    reqBody.Convert2Dto(dto);
+    CreateAssetDto dto(reqBody);
     ret = MediaAssetsService::GetInstance().CreateAssetForAppWithAlbum(dto);
-    if (ret == E_OK) {
-        rspBody.InitByDto(dto);
-    }
-    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+    IPC::UserDefineIPC().WriteResponseBody(reply, dto.GetRspBody(), ret);
 }
 
 void MediaAssetsControllerService::SetAssetTitle(MessageParcel &data, MessageParcel &reply)
@@ -1105,6 +1353,33 @@ void MediaAssetsControllerService::SetAssetsUserComment(MessageParcel &data, Mes
     IPC::UserDefineIPC().WriteResponseBody(reply, ret);
 }
 
+void MediaAssetsControllerService::GetAssetAnalysisData(MessageParcel &data, MessageParcel &reply)
+{
+    GetAssetAnalysisDataReqBody reqBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        MEDIA_ERR_LOG("GetAssetAnalysisData Read Request Error");
+        return;
+    }
+
+    GetAssetAnalysisDataDto dto;
+    dto.fileId = reqBody.fileId;
+    dto.language = reqBody.language;
+    dto.analysisType = reqBody.analysisType;
+    dto.analysisTotal = reqBody.analysisTotal;
+    ret = MediaAssetsService::GetInstance().GetAssetAnalysisData(dto);
+    if (ret != E_OK) {
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        MEDIA_ERR_LOG("GetAssetAnalysisData failed, ret:%{public}d", ret);
+        return;
+    }
+
+    GetAssetAnalysisDataRspBody rspBody;
+    rspBody.resultSet = std::move(dto.resultSet);
+    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody);
+}
+
 void MediaAssetsControllerService::CloneAsset(MessageParcel &data, MessageParcel &reply)
 {
     MEDIA_INFO_LOG("enter CloneAsset");
@@ -1333,6 +1608,7 @@ void MediaAssetsControllerService::RetainCloudMediaAsset(MessageParcel &data, Me
     IPC::UserDefineIPC().WriteResponseBody(reply, ret);
     return;
 }
+
 void MediaAssetsControllerService::GrantPhotoUriPermission(MessageParcel &data, MessageParcel &reply)
 {
     MEDIA_INFO_LOG("enter GrantPhotoUriPermission");
@@ -1441,4 +1717,208 @@ void MediaAssetsControllerService::StopThumbnailCreationTask(MessageParcel &data
     IPC::UserDefineIPC().WriteResponseBody(reply, ret);
     return;
 }
+
+void MediaAssetsControllerService::IsEdited(MessageParcel &data, MessageParcel &reply)
+{
+    MEDIA_INFO_LOG("enter IsEdited");
+    IsEditedReqBody reqBody;
+    IsEditedRspBody rspBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("IsEdited Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+    DataShare::DataSharePredicates predicates;
+    vector<string> columns = { PhotoColumn::PHOTO_EDIT_TIME };
+    predicates.EqualTo(MediaColumn::MEDIA_ID, to_string(reqBody.fileId));
+    MediaLibraryCommand cmd(OperationObject::FILESYSTEM_PHOTO, OperationType::QUERY, MediaLibraryApi::API_10);
+    cmd.SetDataSharePred(predicates);
+    auto resultSet = MediaLibraryPhotoOperations::Query(cmd, columns);
+    auto resultSetBridge = RdbDataShareAdapter::RdbUtils::ToResultSetBridge(resultSet);
+    rspBody.resultSet = make_shared<DataShare::DataShareResultSet>(resultSetBridge);
+    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+}
+
+void MediaAssetsControllerService::RequestEditData(MessageParcel &data, MessageParcel &reply)
+{
+    MEDIA_INFO_LOG("enter RequestEditData");
+    RequestEditDataReqBody reqBody;
+    RequestEditDataRspBody rspBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("RequestEditData Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+    NativeRdb::RdbPredicates rdbPredicate =
+        RdbDataShareAdapter::RdbUtils::ToPredicates(reqBody.predicates, PhotoColumn::PHOTOS_TABLE);
+
+    auto resultSet = MediaLibraryRdbStore::QueryEditDataExists(rdbPredicate);
+    auto resultSetBridge = RdbDataShareAdapter::RdbUtils::ToResultSetBridge(resultSet);
+    rspBody.resultSet = make_shared<DataShare::DataShareResultSet>(resultSetBridge);
+    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+}
+
+void MediaAssetsControllerService::GetEditData(MessageParcel &data, MessageParcel &reply)
+{
+    MEDIA_INFO_LOG("enter GetEditData");
+    GetEditDataReqBody reqBody;
+    GetEditDataRspBody rspBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("GetEditData Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+    NativeRdb::RdbPredicates rdbPredicate =
+        RdbDataShareAdapter::RdbUtils::ToPredicates(reqBody.predicates, PhotoColumn::PHOTOS_TABLE);
+
+    auto resultSet = MediaLibraryRdbStore::QueryEditDataExists(rdbPredicate);
+    auto resultSetBridge = RdbDataShareAdapter::RdbUtils::ToResultSetBridge(resultSet);
+    rspBody.resultSet = make_shared<DataShare::DataShareResultSet>(resultSetBridge);
+    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+}
+
+void MediaAssetsControllerService::GetCloudMediaAssetStatus(MessageParcel &data, MessageParcel &reply)
+{
+    MEDIA_INFO_LOG("enter GetCloudMediaAssetStatus");
+    GetCloudMediaAssetStatusReqBody reqBody;
+    GetCloudMediaAssetStatusReqBody rspBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("GetCloudMediaAssetStatus Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+
+    CloudMediaAssetManager &instance =  CloudMediaAssetManager::GetInstance();
+    rspBody.status = instance.GetCloudMediaAssetTaskStatus();
+    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+}
+
+void MediaAssetsControllerService::StartAssetAnalysis(MessageParcel &data, MessageParcel &reply)
+{
+    MEDIA_INFO_LOG("enter StartAssetAnalysis");
+    StartAssetAnalysisReqBody reqBody;
+    StartAssetAnalysisRspBody rspBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("StartAssetAnalysis Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+    MediaLibraryCommand cmd
+        (OperationObject::ANALYSIS_PHOTO_MAP, OperationType::UPDATE_PORTRAITS_ORDER, MediaLibraryApi::API_10);
+    cmd.SetDataSharePred(reqBody.predicates);
+    auto resultSet = MediaLibraryVisionOperations::HandleForegroundAnalysisOperation(cmd);
+    auto resultSetBridge = RdbDataShareAdapter::RdbUtils::ToResultSetBridge(resultSet);
+    rspBody.resultSet = make_shared<DataShare::DataShareResultSet>(resultSetBridge);
+    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+}
+
+void MediaAssetsControllerService::RequestContent(MessageParcel &data, MessageParcel &reply)
+{
+    MEDIA_INFO_LOG("enter RequestContent");
+    RequestContentReqBody reqBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("RequestContent Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+
+    int32_t position = 0;
+    RequestContentRespBody respBody;
+
+    ret = MediaAssetsService::GetInstance().RequestContent(reqBody.mediaId, position);
+    respBody.position = position;
+    IPC::UserDefineIPC().WriteResponseBody(reply, respBody, ret);
+    return;
+}
+
+void MediaAssetsControllerService::GetCloudEnhancementPair(MessageParcel &data, MessageParcel &reply)
+{
+    MEDIA_INFO_LOG("enter GetCloudEnhancementPair");
+    GetCloudEnhancementPairReqBody reqBody;
+    GetCloudEnhancementPairRespBody respBody;
+
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("GetCloudEnhancementPair Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+
+    shared_ptr<NativeRdb::ResultSet> result =
+        MediaAssetsService::GetInstance().GetCloudEnhancementPair(reqBody.photoUri);
+    auto resultSetBridge = RdbUtils::ToResultSetBridge(result);
+    respBody.resultSet = make_shared<DataShare::DataShareResultSet>(resultSetBridge);
+    IPC::UserDefineIPC().WriteResponseBody(reply, respBody, ret);
+}
+
+void MediaAssetsControllerService::QueryCloudEnhancementTaskState(MessageParcel &data, MessageParcel &reply)
+{
+    MEDIA_INFO_LOG("enter QueryCloudEnhancementTaskState");
+    QueryCloudEnhancementTaskStateReqBody reqBody;
+    QueryCloudEnhancementTaskStateRespBody respBody;
+
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("QueryCloudEnhancementTaskState Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+
+    QueryCloudEnhancementTaskStateDto dto;
+    ret = MediaAssetsService::GetInstance().QueryCloudEnhancementTaskState(reqBody.photoUri, dto);
+    respBody.fileId = dto.fileId;
+    respBody.photoId = dto.photoId;
+    respBody.ceAvailable = dto.ceAvailable;
+    respBody.CEErrorCode = dto.CEErrorCode;
+    IPC::UserDefineIPC().WriteResponseBody(reply, respBody, ret);
+}
+
+void MediaAssetsControllerService::SyncCloudEnhancementTaskStatus(MessageParcel &data, MessageParcel &reply)
+{
+    MEDIA_INFO_LOG("enter SyncCloudEnhancementTaskStatus");
+    CloudEnhancementReqBody reqBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("SyncCloudEnhancementTaskStatus Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+    if (ret == E_OK) {
+        ret = MediaAssetsService::GetInstance().SyncCloudEnhancementTaskStatus();
+    }
+    IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+}
+
+void MediaAssetsControllerService::QueryPhotoStatus(MessageParcel &data, MessageParcel &reply)
+{
+    QueryPhotoReqBody reqBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("QueryPhotoStatus Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+    QueryPhotoRspBody rspBody;
+    ret = MediaAssetsService::GetInstance().QueryPhotoStatus(reqBody, rspBody);
+    IPC::UserDefineIPC().WriteResponseBody(reply, rspBody, ret);
+}
+
+void MediaAssetsControllerService::LogMovingPhoto(MessageParcel &data, MessageParcel &reply)
+{
+    AdaptedReqBody reqBody;
+    int32_t ret = IPC::UserDefineIPC().ReadRequestBody(data, reqBody);
+    if (ret != E_OK) {
+        MEDIA_ERR_LOG("LogMovingPhoto Read Request Error");
+        IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+        return;
+    }
+    ret = MediaAssetsService::GetInstance().LogMovingPhoto(reqBody);
+    IPC::UserDefineIPC().WriteResponseBody(reply, ret);
+}
 } // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/src/controller/media_assets_permission_policy.cpp b/services/media_assets_manager/src/controller/media_assets_permission_policy.cpp
index 85a1fd0f2c..449f5a0784 100755
--- a/services/media_assets_manager/src/controller/media_assets_permission_policy.cpp
+++ b/services/media_assets_manager/src/controller/media_assets_permission_policy.cpp
@@ -55,6 +55,11 @@ static std::unordered_map<uint32_t, std::vector<std::vector<PermissionType>>> me
     {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_START_THUMBNAIL_CREATION_TASK),
         {{SYSTEMAPI_PERM, WRITE_PERM}}},
     {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_STOP_THUMBNAIL_CREATION_TASK), {{SYSTEMAPI_PERM, WRITE_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::GET_CLOUD_ENHANCEMENT_PAIR), {{SYSTEMAPI_PERM, READ_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::QUERY_CLOUD_ENHANCEMENT_TASK_STATE),
+        {{SYSTEMAPI_PERM, READ_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::SYNC_CLOUD_ENHANCEMENT_TASK_STATUS),
+        {{SYSTEMAPI_PERM, READ_PERM}}},
     // ASSETS_BUSINESS_CODE_START begin
     {static_cast<uint32_t>(MediaLibraryBusinessCode::COMMIT_EDITED_ASSET), {{SYSTEMAPI_PERM, WRITE_PERM}}},
     {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_PUBLIC_CREATE_ASSET), {{WRITE_PERM}}},
@@ -64,7 +69,8 @@ static std::unordered_map<uint32_t, std::vector<std::vector<PermissionType>>> me
     {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_SYSTEM_CREATE_ASSET_FOR_APP_WITH_MODE),
         {{SYSTEMAPI_PERM, WRITE_PERM}}},
     {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_SYSTEM_CREATE_ASSET_FOR_APP_WITH_ALBUM),
-        {{SYSTEMAPI_PERM, WRITE_PERM, READ_PERM}}},
+        {{SYSTEMAPI_PERM, WRITE_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_GET_ASSET_ANALYSIS_DATA), {{SYSTEMAPI_PERM, READ_PERM}}},
     {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_SYS_TRASH_PHOTOS), {{SYSTEMAPI_PERM, WRITE_PERM}}},
     {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_TRASH_PHOTOS), {{WRITE_PERM}}},
     {static_cast<uint32_t>(MediaLibraryBusinessCode::DELETE_PHOTOS_COMPLETED), {{SYSTEMAPI_PERM, WRITE_PERM}}},
@@ -102,10 +108,25 @@ static std::unordered_map<uint32_t, std::vector<std::vector<PermissionType>>> me
     {static_cast<uint32_t>(MediaLibraryBusinessCode::PAUSE_DOWNLOAD_CLOUDMEDIA), {{SYSTEMAPI_PERM, CLOUDFILE_SYNC}}},
     {static_cast<uint32_t>(MediaLibraryBusinessCode::CANCEL_DOWNLOAD_CLOUDMEDIA), {{SYSTEMAPI_PERM, CLOUDFILE_SYNC}}},
     {static_cast<uint32_t>(MediaLibraryBusinessCode::RETAIN_CLOUDMEDIA_ASSET), {{SYSTEMAPI_PERM, CLOUDFILE_SYNC}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_IS_EDITED), {{SYSTEMAPI_PERM, READ_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_REQUEST_EDIT_DATA), {{SYSTEMAPI_PERM, READ_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_GET_EDIT_DATA), {{SYSTEMAPI_PERM, READ_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_GET_CLOUDMEDIA_ASSET_STATUS), {{SYSTEMAPI_PERM, READ_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_START_ASSET_ANALYSIS), {{SYSTEMAPI_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_REQUEST_CONTENT), { {READ_PERM} }},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::QUERY_PHOTO_STATUS), {{READ_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::LOG_MOVING_PHOTO), {{}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_GET_ASSETS), {{READ_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::GET_BURST_ASSETS), {{READ_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::FIND_ALL_DUPLICATE_ASSETS), {{SYSTEMAPI_PERM, READ_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::FIND_DUPLICATE_ASSETS_TO_DELETE), {{SYSTEMAPI_PERM, READ_PERM}}},
+    {static_cast<uint32_t>(MediaLibraryBusinessCode::GET_INDEX_CONSTRUCT_PROGRESS), {{SYSTEMAPI_PERM, READ_PERM}}},
 };
 
 static std::unordered_set<uint32_t> mediaAssetsPermissionDbBypass = {
-    static_cast<uint32_t>(MediaLibraryBusinessCode::MEDIA_BUSINESS_CODE_START)};
+    static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_GET_ASSETS),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::GET_BURST_ASSETS),
+};
 
 int32_t MediaAssetsControllerService::GetPermissionPolicy(
     uint32_t code, std::vector<std::vector<PermissionType>> &permissionPolicy, bool &isBypass)
diff --git a/services/media_assets_manager/src/dto/create_asset_dto.cpp b/services/media_assets_manager/src/dto/create_asset_dto.cpp
new file mode 100644
index 0000000000..8bf0e1a333
--- /dev/null
+++ b/services/media_assets_manager/src/dto/create_asset_dto.cpp
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "create_asset_dto.h"
+
+namespace OHOS::Media {
+
+CreateAssetDto::CreateAssetDto(const CreateAssetReqBody &reqBody)
+{
+    this->mediaType = reqBody.mediaType;
+    this->photoSubtype = reqBody.photoSubtype;
+    this->title = reqBody.title;
+    this->extension = reqBody.extension;
+    this->displayName = reqBody.displayName;
+    this->cameraShotKey = reqBody.cameraShotKey;
+}
+
+CreateAssetDto::CreateAssetDto(const CreateAssetForAppReqBody &reqBody)
+{
+    this->tokenId = reqBody.tokenId;
+    this->mediaType = reqBody.mediaType;
+    this->photoSubtype = reqBody.photoSubtype;
+    this->title = reqBody.title;
+    this->extension = reqBody.extension;
+    this->bundleName = reqBody.bundleName;
+    this->packageName = reqBody.packageName;
+    this->appId = reqBody.appId;
+    this->ownerAlbumId = reqBody.ownerAlbumId;
+}
+
+CreateAssetRspBody CreateAssetDto::GetRspBody()
+{
+    CreateAssetRspBody rspBody;
+    rspBody.fileId = this->fileId;
+    rspBody.outUri = this->outUri;
+    return rspBody;
+}
+}  // namespace OHOS::Media
diff --git a/services/media_assets_manager/src/dto/get_assets_dto.cpp b/services/media_assets_manager/src/dto/get_assets_dto.cpp
new file mode 100755
index 0000000000..0ff4c91d4d
--- /dev/null
+++ b/services/media_assets_manager/src/dto/get_assets_dto.cpp
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "get_assets_dto.h"
+
+namespace OHOS::Media {
+GetAssetsDto GetAssetsDto::Create(const GetAssetsReqBody &req)
+{
+    GetAssetsDto dto;
+    dto.predicates = req.predicates;
+    dto.columns = req.columns;
+    return dto;
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/src/dto/query_cloud_enhancement_task_state_dto.cpp b/services/media_assets_manager/src/dto/query_cloud_enhancement_task_state_dto.cpp
new file mode 100644
index 0000000000..90d6740dc4
--- /dev/null
+++ b/services/media_assets_manager/src/dto/query_cloud_enhancement_task_state_dto.cpp
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaQueryCloudEnhancementTaskStateDto"
+
+#include "query_cloud_enhancement_task_state_dto.h"
+
+#include <sstream>
+
+namespace OHOS::Media {
+using namespace std;
+std::string QueryCloudEnhancementTaskStateDto::ToString() const
+{
+    std::stringstream ss;
+    ss << "{"
+       << "\"photoUri\": \"" << photoUri << "\","
+       << "\"fileId\": \"" << to_string(fileId) << "\","
+       << "\"photoId\": \"" << photoId << "\","
+       << "\"ceAvailable\": \"" << to_string(ceAvailable) << "\","
+       << "\"CEErrorCode\": \"" << to_string(CEErrorCode)
+       << "}";
+    return ss.str();
+}
+} // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/src/media_assets_rdb_operations.cpp b/services/media_assets_manager/src/media_assets_rdb_operations.cpp
index 1ddedafc01..c21d98126c 100644
--- a/services/media_assets_manager/src/media_assets_rdb_operations.cpp
+++ b/services/media_assets_manager/src/media_assets_rdb_operations.cpp
@@ -491,4 +491,26 @@ int32_t MediaAssetsRdbOperations::StopThumbnailCreationTask(int32_t requestId)
     ThumbnailService::GetInstance()->CancelAstcBatchTask(requestId);
     return E_OK;
 }
+
+int32_t MediaAssetsRdbOperations::QueryEnhancementTaskState(const string& photoUri,
+    QueryCloudEnhancementTaskStateDto& dto)
+{
+    vector<string> columns = {
+        MediaColumn::MEDIA_ID, PhotoColumn::PHOTO_ID,
+        PhotoColumn::PHOTO_CE_AVAILABLE, PhotoColumn::PHOTO_CE_STATUS_CODE
+    };
+    MediaLibraryCommand cmd(PhotoColumn::PHOTOS_TABLE);
+    DataShare::DataSharePredicates predicates;
+    predicates.EqualTo(MediaColumn::MEDIA_ID, photoUri);
+    cmd.SetDataSharePred(predicates);
+    auto resultSet = EnhancementManager::GetInstance().HandleQueryOperation(cmd, columns);
+    bool cond = (resultSet == nullptr || resultSet->GoToFirstRow() != NativeRdb::E_OK);
+    CHECK_AND_RETURN_RET_LOG(!cond, -E_HAS_DB_ERROR, "Failed to query album!");
+    dto.fileId = GetInt32Val(MediaColumn::MEDIA_ID, resultSet);
+    dto.photoId = GetStringVal(PhotoColumn::PHOTO_ID, resultSet);
+    dto.ceAvailable = GetInt32Val(PhotoColumn::PHOTO_CE_AVAILABLE, resultSet);
+    dto.CEErrorCode = GetInt32Val(PhotoColumn::PHOTO_CE_STATUS_CODE, resultSet);
+    resultSet->Close();
+    return E_OK;
+}
 } // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/src/media_assets_service.cpp b/services/media_assets_manager/src/media_assets_service.cpp
index 82638c9cf0..27092714c3 100644
--- a/services/media_assets_manager/src/media_assets_service.cpp
+++ b/services/media_assets_manager/src/media_assets_service.cpp
@@ -50,8 +50,41 @@
 #include "medialibrary_album_operations.h"
 #include "enhancement_manager.h"
 #include "rdb_utils.h"
+#include "location_column.h"
+#include "vision_column.h"
+#include "vision_aesthetics_score_column.h"
+#include "vision_composition_column.h"
+#include "vision_face_tag_column.h"
+#include "vision_head_column.h"
+#include "vision_image_face_column.h"
+#include "vision_label_column.h"
+#include "vision_object_column.h"
+#include "vision_ocr_column.h"
+#include "vision_pose_column.h"
+#include "vision_recommendation_column.h"
+#include "vision_saliency_detect_column.h"
+#include "vision_segmentation_column.h"
+#include "vision_total_column.h"
+#include "vision_video_label_column.h"
+#include "vision_multi_crop_column.h"
+#include "medialibrary_data_manager.h"
 #include "media_app_uri_permission_column.h"
 #include "media_app_uri_sensitive_column.h"
+#include "duplicate_photo_operation.h"
+#include "medialibrary_search_operations.h"
+#include "medialibrary_common_utils.h"
+#include "photo_map_column.h"
+#include "album_operation_uri.h"
+#include "medialibrary_business_code.h"
+#include "rdb_utils.h"
+#include "datashare_result_set.h"
+#include "query_result_vo.h"
+#include "user_photography_info_column.h"
+#include "story_album_column.h"
+#include "userfile_manager_types.h"
+#include "story_cover_info_column.h"
+#include "story_play_info_column.h"
+#include "vision_column_comm.h"
 
 using namespace std;
 using namespace OHOS::RdbDataShareAdapter;
@@ -62,6 +95,7 @@ const int32_t YES = 1;
 const int32_t NO = 0;
 const std::string SET_LOCATION_KEY = "set_location";
 const std::string SET_LOCATION_VALUE = "1";
+constexpr int32_t HIGH_QUALITY_IMAGE = 0;
 
 static void UpdateVisionTableForEdit(AsyncTaskData *taskData)
 {
@@ -260,24 +294,8 @@ int32_t MediaAssetsService::AssetChangeSetEditData(const NativeRdb::ValuesBucket
     MediaLibraryCommand cmd(
         OperationObject::FILESYSTEM_PHOTO, OperationType::ADD_FILTERS, values, MediaLibraryApi::API_10);
 
-    string clientBundle = MediaLibraryBundleManager::GetInstance()->GetClientBundleName();
-    if (clientBundle.empty()) {
-        MEDIA_ERR_LOG("GetClientBundleName failed");
-    } else {
-        cmd.SetBundleName(clientBundle);
-    }
-
-#ifdef DISTRIBUTED
-    OHOS::DistributedHardware::DmDeviceInfo deviceInfo;
-    auto &deviceManager = OHOS::DistributedHardware::DeviceManager::GetInstance();
-    int32_t ret = deviceManager.GetLocalDeviceInfo(BUNDLE_NAME, deviceInfo);
-    if (ret < 0) {
-        MEDIA_ERR_LOG("GetLocalDeviceInfo ret = %{public}d", ret);
-    } else {
-        cmd.SetDeviceName(deviceInfo.deviceName);
-    }
-#endif
-
+    cmd.SetDeviceName(GetLocalDeviceName());
+    cmd.SetBundleName(GetClientBundleName());
     return MediaLibraryPhotoOperations::AddFilters(cmd);
 }
 
@@ -291,24 +309,8 @@ int32_t MediaAssetsService::AssetChangeSubmitCache(SubmitCacheDto &dto)
         cmd.SetApiParam(SET_LOCATION_KEY, SET_LOCATION_VALUE);
     }
 
-    string clientBundle = MediaLibraryBundleManager::GetInstance()->GetClientBundleName();
-    if (clientBundle.empty()) {
-        MEDIA_ERR_LOG("GetClientBundleName failed");
-    } else {
-        cmd.SetBundleName(clientBundle);
-    }
-
-#ifdef DISTRIBUTED
-    OHOS::DistributedHardware::DmDeviceInfo deviceInfo;
-    auto &deviceManager = OHOS::DistributedHardware::DeviceManager::GetInstance();
-    int32_t ret = deviceManager.GetLocalDeviceInfo(BUNDLE_NAME, deviceInfo);
-    if (ret < 0) {
-        MEDIA_ERR_LOG("GetLocalDeviceInfo ret = %{public}d", ret);
-    } else {
-        cmd.SetDeviceName(deviceInfo.deviceName);
-    }
-#endif
-
+    cmd.SetDeviceName(GetLocalDeviceName());
+    cmd.SetBundleName(GetClientBundleName());
     int32_t ret = MediaLibraryPhotoOperations::SubmitCache(cmd);
     CHECK_AND_RETURN_RET_LOG(ret >= 0, ret, "MediaLibraryPhotoOperations::SubmitCache failed");
     dto.fileId = ret;
@@ -321,24 +323,8 @@ int32_t MediaAssetsService::AssetChangeCreateAsset(AssetChangeCreateAssetDto &dt
     MediaLibraryCommand cmd(
         OperationObject::FILESYSTEM_PHOTO, OperationType::CREATE, dto.values, MediaLibraryApi::API_10);
 
-    string clientBundle = MediaLibraryBundleManager::GetInstance()->GetClientBundleName();
-    if (clientBundle.empty()) {
-        MEDIA_ERR_LOG("GetClientBundleName failed");
-    } else {
-        cmd.SetBundleName(clientBundle);
-    }
-
-#ifdef DISTRIBUTED
-    OHOS::DistributedHardware::DmDeviceInfo deviceInfo;
-    auto &deviceManager = OHOS::DistributedHardware::DeviceManager::GetInstance();
-    int32_t ret = deviceManager.GetLocalDeviceInfo(BUNDLE_NAME, deviceInfo);
-    if (ret < 0) {
-        MEDIA_ERR_LOG("GetLocalDeviceInfo ret = %{public}d", ret);
-    } else {
-        cmd.SetDeviceName(deviceInfo.deviceName);
-    }
-#endif
-
+    cmd.SetDeviceName(GetLocalDeviceName());
+    cmd.SetBundleName(GetClientBundleName());
     int32_t ret = MediaLibraryPhotoOperations::Create(cmd);
     CHECK_AND_RETURN_RET_LOG(ret > 0, ret, "MediaLibraryPhotoOperations::Create failed");
     dto.fileId = ret;
@@ -498,6 +484,72 @@ int32_t MediaAssetsService::SetSupportedWatermarkType(const int32_t fileId, cons
     return MediaLibraryPhotoOperations::UpdateSupportedWatermarkType(cmd);
 }
 
+std::shared_ptr<DataShare::DataShareResultSet> MediaAssetsService::GetAssets(const GetAssetsDto &dto)
+{
+    MediaLibraryCommand cmd(OperationObject::FILESYSTEM_PHOTO, OperationType::QUERY, MediaLibraryApi::API_10);
+    cmd.SetDataSharePred(dto.predicates);
+    // MEDIALIBRARY_TABLE just for RdbPredicates
+    NativeRdb::RdbPredicates rdbPredicate = RdbUtils::ToPredicates(dto.predicates, MEDIALIBRARY_TABLE);
+    cmd.GetAbsRdbPredicates()->SetWhereClause(rdbPredicate.GetWhereClause());
+    cmd.GetAbsRdbPredicates()->SetWhereArgs(rdbPredicate.GetWhereArgs());
+    cmd.GetAbsRdbPredicates()->SetOrder(rdbPredicate.GetOrder());
+
+    auto resultSet = MediaLibraryPhotoOperations::Query(cmd, dto.columns);
+    CHECK_AND_RETURN_RET_LOG(resultSet, nullptr, "Failed to query assets");
+    auto resultSetBridge = RdbDataShareAdapter::RdbUtils::ToResultSetBridge(resultSet);
+    return make_shared<DataShare::DataShareResultSet>(resultSetBridge);
+}
+
+std::shared_ptr<DataShare::DataShareResultSet> MediaAssetsService::GetAllDuplicateAssets(const GetAssetsDto &dto)
+{
+    RdbPredicates predicates = RdbDataShareAdapter::RdbUtils::ToPredicates(dto.predicates, PhotoColumn::PHOTOS_TABLE);
+    auto resultSet = DuplicatePhotoOperation::GetAllDuplicateAssets(predicates, dto.columns);
+    CHECK_AND_RETURN_RET_LOG(resultSet, nullptr, "Failed to query duplicate assets");
+    auto resultSetBridge = RdbDataShareAdapter::RdbUtils::ToResultSetBridge(resultSet);
+    return make_shared<DataShare::DataShareResultSet>(resultSetBridge);
+}
+
+std::shared_ptr<DataShare::DataShareResultSet> MediaAssetsService::GetDuplicateAssetsToDelete(const GetAssetsDto &dto)
+{
+    RdbPredicates predicates = RdbDataShareAdapter::RdbUtils::ToPredicates(dto.predicates, PhotoColumn::PHOTOS_TABLE);
+    auto resultSet = DuplicatePhotoOperation::GetDuplicateAssetsToDelete(predicates, dto.columns);
+    CHECK_AND_RETURN_RET_LOG(resultSet, nullptr, "Failed to query duplicate assets for delete");
+    auto resultSetBridge = RdbDataShareAdapter::RdbUtils::ToResultSetBridge(resultSet);
+    return make_shared<DataShare::DataShareResultSet>(resultSetBridge);
+}
+
+int32_t MediaAssetsService::GetIndexConstructProgress(std::string &indexProgress)
+{
+    auto resultSet = MediaLibrarySearchOperations::QueryIndexConstructProgress();
+    CHECK_AND_RETURN_RET_LOG(resultSet, E_FAIL, "Failed to query index construct progress");
+
+    auto errCode = resultSet->GoToFirstRow();
+    if (errCode != NativeRdb::E_OK) {
+        MEDIA_ERR_LOG("ResultSet GotoFirstRow failed, errCode=%{public}d", errCode);
+        return E_FAIL;
+    }
+
+    const vector<string> columns = {PHOTO_COMPLETE_NUM, PHOTO_TOTAL_NUM, VIDEO_COMPLETE_NUM, VIDEO_TOTAL_NUM};
+    int32_t index = 0;
+    string value = "";
+    indexProgress = "{";
+    for (const auto &item : columns) {
+        if (resultSet->GetColumnIndex(item, index) != NativeRdb::E_OK) {
+            MEDIA_ERR_LOG("ResultSet GetColumnIndex failed, progressObject=%{public}s", item.c_str());
+            return E_FAIL;
+        }
+        if (resultSet->GetString(index, value) != NativeRdb::E_OK) {
+            MEDIA_ERR_LOG("ResultSet GetString failed, progressObject=%{public}s", item.c_str());
+            return E_FAIL;
+        }
+        indexProgress += "\"" + item + "\":" + value + ",";
+    }
+    indexProgress = indexProgress.substr(0, indexProgress.length() - 1);
+    indexProgress += "}";
+    MEDIA_DEBUG_LOG("GetProgressStr progress=%{public}s", indexProgress.c_str());
+    return E_OK;
+}
+
 int32_t MediaAssetsService::CreateAsset(CreateAssetDto& dto)
 {
     NativeRdb::ValuesBucket assetInfo;
@@ -517,7 +569,8 @@ int32_t MediaAssetsService::CreateAsset(CreateAssetDto& dto)
     MediaLibraryCommand cmd(OperationObject::FILESYSTEM_PHOTO, OperationType::CREATE, MediaLibraryApi::API_10);
 
     cmd.SetValueBucket(assetInfo);
-    cmd.SetBundleName(MediaLibraryBundleManager::GetInstance()->GetClientBundleName());
+    cmd.SetDeviceName(GetLocalDeviceName());
+    cmd.SetBundleName(GetClientBundleName());
     int32_t ret = MediaLibraryPhotoOperations::Create(cmd);
     CHECK_AND_RETURN_RET_LOG(ret > 0, ret, "MediaLibraryPhotoOperations::Create failed");
     dto.fileId = ret;
@@ -541,7 +594,8 @@ int32_t MediaAssetsService::CreateAssetForApp(CreateAssetDto& dto)
     MediaLibraryCommand cmd(OperationObject::FILESYSTEM_PHOTO, OperationType::CREATE, MediaLibraryApi::API_10);
 
     cmd.SetValueBucket(assetInfo);
-    cmd.SetBundleName(MediaLibraryBundleManager::GetInstance()->GetClientBundleName());
+    cmd.SetDeviceName(GetLocalDeviceName());
+    cmd.SetBundleName(GetClientBundleName());
     int32_t ret = MediaLibraryPhotoOperations::Create(cmd);
     CHECK_AND_RETURN_RET_LOG(ret > 0, ret, "MediaLibraryPhotoOperations::Create failed");
     dto.fileId = ret;
@@ -572,7 +626,8 @@ int32_t MediaAssetsService::CreateAssetForAppWithAlbum(CreateAssetDto& dto)
 
     cmd.SetValueBucket(assetInfo);
     cmd.SetApiParam("tokenId", to_string(dto.tokenId));
-    cmd.SetBundleName(MediaLibraryBundleManager::GetInstance()->GetClientBundleName());
+    cmd.SetDeviceName(GetLocalDeviceName());
+    cmd.SetBundleName(GetClientBundleName());
     int32_t ret = MediaLibraryPhotoOperations::Create(cmd);
     CHECK_AND_RETURN_RET_LOG(ret > 0, ret, "MediaLibraryPhotoOperations::Create failed");
     dto.fileId = ret;
@@ -717,6 +772,99 @@ int32_t MediaAssetsService::SetAssetsUserComment(const std::vector<int32_t> &fil
     return MediaLibraryPhotoOperations::Update(cmd);
 }
 
+struct AnalysisConfig {
+    std::string tableName;
+    std::string totalColumnName;
+    std::vector<std::string> columns;
+};
+
+static const std::string FACE_ALBUM_URI = "'" + PhotoAlbumColumns::ANALYSIS_ALBUM_URI_PREFIX + "' || " +
+    ANALYSIS_ALBUM_TABLE + "." + ALBUM_ID + " AS " + ALBUM_URI;
+
+static const map<int32_t, struct AnalysisConfig> ANALYSIS_CONFIG_MAP = {
+    { ANALYSIS_AESTHETICS_SCORE, { VISION_AESTHETICS_TABLE, AESTHETICS_SCORE, { AESTHETICS_SCORE, PROB } } },
+    { ANALYSIS_LABEL, { VISION_LABEL_TABLE, LABEL, { CATEGORY_ID, SUB_LABEL, PROB, FEATURE,
+        SIM_RESULT, SALIENCY_SUB_PROB } } },
+    { ANALYSIS_VIDEO_LABEL, { VISION_VIDEO_LABEL_TABLE, VIDEO_LABEL, { CATEGORY_ID, CONFIDENCE_PROBABILITY,
+        SUB_CATEGORY, SUB_CONFIDENCE_PROB, SUB_LABEL, SUB_LABEL_PROB, SUB_LABEL_TYPE,
+        TRACKS, VIDEO_PART_FEATURE, FILTER_TAG} } },
+    { ANALYSIS_OCR, { VISION_OCR_TABLE, OCR, { OCR_TEXT, OCR_TEXT_MSG, OCR_WIDTH, OCR_HEIGHT } } },
+    { ANALYSIS_FACE, { VISION_IMAGE_FACE_TABLE, FACE, { FACE_ID, FACE_ALBUM_URI, SCALE_X, SCALE_Y,
+        SCALE_WIDTH, SCALE_HEIGHT, LANDMARKS, PITCH, YAW, ROLL, PROB, TOTAL_FACES, FEATURES, FACE_OCCLUSION,
+        BEAUTY_BOUNDER_X, BEAUTY_BOUNDER_Y, BEAUTY_BOUNDER_WIDTH, BEAUTY_BOUNDER_HEIGHT, FACE_AESTHETICS_SCORE} } },
+    { ANALYSIS_OBJECT, { VISION_OBJECT_TABLE, OBJECT, { OBJECT_ID, OBJECT_LABEL, OBJECT_SCALE_X, OBJECT_SCALE_Y,
+        OBJECT_SCALE_WIDTH, OBJECT_SCALE_HEIGHT, PROB, SCALE_X, SCALE_Y, SCALE_WIDTH, SCALE_HEIGHT } } },
+    { ANALYSIS_RECOMMENDATION, { VISION_RECOMMENDATION_TABLE, RECOMMENDATION, { RECOMMENDATION_ID,
+        RECOMMENDATION_RESOLUTION, RECOMMENDATION_SCALE_X, RECOMMENDATION_SCALE_Y, RECOMMENDATION_SCALE_WIDTH,
+        RECOMMENDATION_SCALE_HEIGHT, SCALE_X, SCALE_Y, SCALE_WIDTH, SCALE_HEIGHT } } },
+    { ANALYSIS_SEGMENTATION, { VISION_SEGMENTATION_TABLE, SEGMENTATION, { SEGMENTATION_AREA, SEGMENTATION_NAME,
+        PROB } } },
+    { ANALYSIS_COMPOSITION, { VISION_COMPOSITION_TABLE, COMPOSITION, { COMPOSITION_ID, COMPOSITION_RESOLUTION,
+        CLOCK_STYLE, CLOCK_LOCATION_X, CLOCK_LOCATION_Y, CLOCK_COLOUR, COMPOSITION_SCALE_X, COMPOSITION_SCALE_Y,
+        COMPOSITION_SCALE_WIDTH, COMPOSITION_SCALE_HEIGHT, SCALE_X, SCALE_Y, SCALE_WIDTH, SCALE_HEIGHT } } },
+    { ANALYSIS_SALIENCY, { VISION_SALIENCY_TABLE, SALIENCY, { SALIENCY_X, SALIENCY_Y } } },
+    { ANALYSIS_DETAIL_ADDRESS, { PhotoColumn::PHOTOS_TABLE, DETAIL_ADDRESS, {
+        PhotoColumn::PHOTOS_TABLE + "." + LATITUDE, PhotoColumn::PHOTOS_TABLE + "." + LONGITUDE, LANGUAGE, COUNTRY,
+        ADMIN_AREA, SUB_ADMIN_AREA, LOCALITY, SUB_LOCALITY, THOROUGHFARE, SUB_THOROUGHFARE, FEATURE_NAME, CITY_NAME,
+        ADDRESS_DESCRIPTION, LOCATION_TYPE, AOI, POI, FIRST_AOI, FIRST_POI, LOCATION_VERSION, FIRST_AOI_CATEGORY,
+        FIRST_POI_CATEGORY} } },
+    { ANALYSIS_HUMAN_FACE_TAG, { VISION_FACE_TAG_TABLE, FACE_TAG, { VISION_FACE_TAG_TABLE + "." + TAG_ID, TAG_NAME,
+        USER_OPERATION, GROUP_TAG, RENAME_OPERATION, CENTER_FEATURES, USER_DISPLAY_LEVEL, TAG_ORDER, IS_ME, COVER_URI,
+        COUNT, PORTRAIT_DATE_MODIFY, ALBUM_TYPE, IS_REMOVED } } },
+    { ANALYSIS_HEAD_POSITION, { VISION_HEAD_TABLE, HEAD, { HEAD_ID, HEAD_LABEL, HEAD_SCALE_X, HEAD_SCALE_Y,
+        HEAD_SCALE_WIDTH, HEAD_SCALE_HEIGHT, PROB, SCALE_X, SCALE_Y, SCALE_WIDTH, SCALE_HEIGHT } } },
+    { ANALYSIS_BONE_POSE, { VISION_POSE_TABLE, POSE, { POSE_ID, POSE_LANDMARKS, POSE_SCALE_X, POSE_SCALE_Y,
+        POSE_SCALE_WIDTH, POSE_SCALE_HEIGHT, PROB, POSE_TYPE, SCALE_X, SCALE_Y, SCALE_WIDTH, SCALE_HEIGHT } } },
+    { ANALYSIS_MULTI_CROP, { VISION_RECOMMENDATION_TABLE, RECOMMENDATION, { MOVEMENT_CROP, MOVEMENT_VERSION } } },
+};
+
+int32_t MediaAssetsService::GetAssetAnalysisData(GetAssetAnalysisDataDto &dto)
+{
+    MEDIA_INFO_LOG("fileId:%{public}d, analysisType:%{public}d, language:%{public}s, analysisTotal:%{public}d",
+        dto.fileId, dto.analysisType, dto.language.c_str(), dto.analysisTotal);
+    auto it = ANALYSIS_CONFIG_MAP.find(dto.analysisType);
+    if (it == ANALYSIS_CONFIG_MAP.end()) {
+        MEDIA_ERR_LOG("Invalid analysisType:%{public}d", dto.analysisType);
+        return -EINVAL;
+    }
+
+    const AnalysisConfig &config = it->second;
+    std::shared_ptr<NativeRdb::ResultSet> resultSet;
+    if (dto.analysisTotal) {
+        NativeRdb::RdbPredicates predicate(VISION_TOTAL_TABLE);
+        predicate.EqualTo(MediaColumn::MEDIA_ID, to_string(dto.fileId));
+        resultSet = MediaLibraryRdbStore::QueryWithFilter(predicate, { config.totalColumnName });
+    } else {
+        NativeRdb::RdbPredicates rdbPredicate(config.tableName);
+        if (dto.analysisType == ANALYSIS_FACE) {
+            string onClause = VISION_IMAGE_FACE_TABLE + "." + TAG_ID + " = " + ANALYSIS_ALBUM_TABLE + "." + TAG_ID +
+                " AND " + ANALYSIS_ALBUM_TABLE + "." + ALBUM_SUBTYPE + " = " + to_string(PhotoAlbumSubType::PORTRAIT);
+            rdbPredicate.LeftOuterJoin(ANALYSIS_ALBUM_TABLE)->On({ onClause });
+            rdbPredicate.EqualTo(MediaColumn::MEDIA_ID, to_string(dto.fileId));
+            resultSet = MediaLibraryRdbStore::QueryWithFilter(rdbPredicate, config.columns);
+        } else if (dto.analysisType == ANALYSIS_HUMAN_FACE_TAG) {
+            string onClause = VISION_IMAGE_FACE_TABLE + "." + TAG_ID + " = " + VISION_FACE_TAG_TABLE + "." + TAG_ID;
+            rdbPredicate.InnerJoin(VISION_IMAGE_FACE_TABLE)->On({ onClause });
+            rdbPredicate.EqualTo(MediaColumn::MEDIA_ID, to_string(dto.fileId));
+            resultSet = MediaLibraryRdbStore::QueryWithFilter(rdbPredicate, config.columns);
+        } else if (dto.analysisType == ANALYSIS_DETAIL_ADDRESS) {
+            string onClause = GEO_KNOWLEDGE_TABLE + "." + LANGUAGE + " = \'" + dto.language + "\' AND " +
+                PhotoColumn::PHOTOS_TABLE + "." + PhotoColumn::MEDIA_ID + " = " + GEO_KNOWLEDGE_TABLE + "." + FILE_ID;
+            rdbPredicate.LeftOuterJoin(GEO_KNOWLEDGE_TABLE)->On({ onClause });
+            rdbPredicate.EqualTo(PhotoColumn::PHOTOS_TABLE + "." + PhotoColumn::MEDIA_ID, to_string(dto.fileId));
+            resultSet = MediaLibraryDataManager::QueryGeo(rdbPredicate, config.columns);
+        } else {
+            rdbPredicate.EqualTo(MediaColumn::MEDIA_ID, to_string(dto.fileId));
+            resultSet = MediaLibraryRdbStore::QueryWithFilter(rdbPredicate, config.columns);
+        }
+    }
+
+    CHECK_AND_RETURN_RET_LOG(resultSet != nullptr, E_HAS_DB_ERROR, "resultSet nullptr");
+    auto bridge = RdbUtils::ToResultSetBridge(resultSet);
+    dto.resultSet = make_shared<DataShare::DataShareResultSet>(bridge);
+    return E_OK;
+}
+
 int32_t MediaAssetsService::CloneAsset(const CloneAssetDto& cloneAssetDto)
 {
     MEDIA_INFO_LOG("MediaAssetsService::CloneAsset, fileId:%{public}d, title:%{public}s",
@@ -854,4 +1002,87 @@ int32_t MediaAssetsService::StopThumbnailCreationTask(const StopThumbnailCreatio
     MEDIA_INFO_LOG("MediaAssetsService::StopThumbnailCreationTask ret:%{public}d", errCode);
     return errCode;
 }
+
+int32_t MediaAssetsService::RequestContent(const string& mediaId, int32_t& position)
+{
+    NativeRdb::RdbPredicates predicates(PhotoColumn::PHOTOS_TABLE);
+    predicates.EqualTo(MediaColumn::MEDIA_ID, mediaId);
+    std::vector<std::string> fetchColumn { PhotoColumn::PHOTO_POSITION };
+
+    auto resultSet = MediaLibraryRdbStore::QueryWithFilter(predicates, fetchColumn);
+    if (resultSet == nullptr || resultSet->GoToFirstRow() != E_OK) {
+        MEDIA_ERR_LOG("query resultSet is nullptr");
+        return E_ERR;
+    }
+
+    int index;
+    int err = resultSet->GetColumnIndex(PhotoColumn::PHOTO_POSITION, index);
+    if (err != E_OK) {
+        MEDIA_ERR_LOG("Failed to GetColumnIndex");
+        return E_ERR;
+    }
+    resultSet->GetInt(index, position);
+    return E_OK;
+}
+
+shared_ptr<NativeRdb::ResultSet> MediaAssetsService::GetCloudEnhancementPair(const string& photoUri)
+{
+    MediaLibraryCommand cmd(PhotoColumn::PHOTOS_TABLE);
+    DataShare::DataSharePredicates predicates;
+    predicates.EqualTo(MediaColumn::MEDIA_ID, photoUri);
+    cmd.SetDataSharePred(predicates);
+    return EnhancementManager::GetInstance().HandleGetPairOperation(cmd);
+}
+
+int32_t MediaAssetsService::QueryCloudEnhancementTaskState(const string& photoUri,
+    QueryCloudEnhancementTaskStateDto& dto)
+{
+    return this->rdbOperation_.QueryEnhancementTaskState(photoUri, dto);
+}
+
+int32_t MediaAssetsService::SyncCloudEnhancementTaskStatus()
+{
+    return EnhancementManager::GetInstance().HandleSyncOperation();
+}
+
+int32_t MediaAssetsService::QueryPhotoStatus(const QueryPhotoReqBody &req, QueryPhotoRspBody &rsp)
+{
+    DataShare::DataSharePredicates predicates;
+    predicates.EqualTo(MediaColumn::MEDIA_ID, req.fileId);
+    using namespace RdbDataShareAdapter;
+    RdbPredicates rdbPredicates = RdbUtils::ToPredicates(predicates, PhotoColumn::PHOTOS_TABLE);
+    std::vector<std::string> columns { PhotoColumn::PHOTO_QUALITY, PhotoColumn::PHOTO_ID };
+
+    shared_ptr<NativeRdb::ResultSet> resSet = MediaLibraryRdbStore::QueryWithFilter(rdbPredicates, columns);
+
+    auto resultSetBridge = RdbUtils::ToResultSetBridge(resSet);
+    using namespace DataShare;
+    auto resultSet = make_shared<DataShareResultSet>(resultSetBridge);
+
+    if (resultSet == nullptr || resultSet->GoToFirstRow() != E_OK) {
+        MEDIA_INFO_LOG("query resultSet is nullptr");
+        return E_ERR;
+    }
+    int indexOfPhotoId = -1;
+    resultSet->GetColumnIndex(PhotoColumn::PHOTO_ID, indexOfPhotoId);
+    std::string photoId;
+    resultSet->GetString(indexOfPhotoId, photoId);
+    rsp.photoId = photoId;
+
+    int columnIndexQuality = -1;
+    resultSet->GetColumnIndex(PhotoColumn::PHOTO_QUALITY, columnIndexQuality);
+    int currentPhotoQuality = HIGH_QUALITY_IMAGE;
+    resultSet->GetInt(columnIndexQuality, currentPhotoQuality);
+    rsp.photoQuality = currentPhotoQuality;
+    return E_SUCCESS;
+}
+
+int32_t MediaAssetsService::LogMovingPhoto(const AdaptedReqBody &req)
+{
+    string packageName = MediaLibraryBundleManager::GetInstance()->GetClientBundleName();
+    CHECK_AND_WARN_LOG(!packageName.empty(), "Package name is empty, adapted: %{public}d",
+        static_cast<int>(req.adapted));
+    DfxManager::GetInstance()->HandleAdaptationToMovingPhoto(packageName, req.adapted);
+    return E_SUCCESS;
+}
 } // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/src/vo/adapted_vo.cpp b/services/media_assets_manager/src/vo/adapted_vo.cpp
new file mode 100644
index 0000000000..50deabbe9f
--- /dev/null
+++ b/services/media_assets_manager/src/vo/adapted_vo.cpp
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "adapted_vo.h"
+
+#include <sstream>
+
+namespace OHOS::Media {
+bool AdaptedReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    return parcel.ReadBool(this->adapted);
+}
+
+bool AdaptedReqBody::Marshalling(MessageParcel &parcel) const
+{
+    return parcel.WriteBool(this->adapted);
+}
+
+} // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/src/vo/create_asset_vo.cpp b/services/media_assets_manager/src/vo/create_asset_vo.cpp
index 0f327f45fb..a0506ef8f1 100644
--- a/services/media_assets_manager/src/vo/create_asset_vo.cpp
+++ b/services/media_assets_manager/src/vo/create_asset_vo.cpp
@@ -49,16 +49,6 @@ bool CreateAssetReqBody::Marshalling(MessageParcel &parcel) const
     return parcel.WriteString(this->cameraShotKey);
 }
 
-void CreateAssetReqBody::Convert2Dto(CreateAssetDto &dto)
-{
-    dto.mediaType = this->mediaType;
-    dto.photoSubtype = this->photoSubtype;
-    dto.title = this->title;
-    dto.extension = this->extension;
-    dto.displayName = this->displayName;
-    dto.cameraShotKey = this->cameraShotKey;
-}
-
 bool CreateAssetRspBody::Unmarshalling(MessageParcel &parcel)
 {
     bool status = parcel.ReadInt32(this->fileId);
@@ -73,12 +63,6 @@ bool CreateAssetRspBody::Marshalling(MessageParcel &parcel) const
     return parcel.WriteString(this->outUri);
 }
 
-void CreateAssetRspBody::InitByDto(const CreateAssetDto &dto)
-{
-    this->fileId = dto.fileId;
-    this->outUri = dto.outUri;
-}
-
 bool CreateAssetForAppReqBody::Unmarshalling(MessageParcel &parcel)
 {
     bool status = parcel.ReadInt32(this->tokenId);
@@ -124,17 +108,4 @@ bool CreateAssetForAppReqBody::Marshalling(MessageParcel &parcel) const
     CHECK_AND_RETURN_RET(status, status);
     return parcel.WriteString(this->ownerAlbumId);
 }
-
-void CreateAssetForAppReqBody::Convert2Dto(CreateAssetDto &dto)
-{
-    dto.tokenId = this->tokenId;
-    dto.mediaType = this->mediaType;
-    dto.photoSubtype = this->photoSubtype;
-    dto.title = this->title;
-    dto.extension = this->extension;
-    dto.bundleName = this->bundleName;
-    dto.packageName = this->packageName;
-    dto.appId = this->appId;
-    dto.ownerAlbumId = this->ownerAlbumId;
-}
 } // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/src/vo/get_asset_analysis_data_vo.cpp b/services/media_assets_manager/src/vo/get_asset_analysis_data_vo.cpp
new file mode 100644
index 0000000000..2781786509
--- /dev/null
+++ b/services/media_assets_manager/src/vo/get_asset_analysis_data_vo.cpp
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "get_asset_analysis_data_vo.h"
+
+#include "media_log.h"
+
+namespace OHOS::Media {
+
+bool GetAssetAnalysisDataReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = parcel.ReadInt32(this->fileId);
+    CHECK_AND_RETURN_RET_LOG(status, status, "Read fileId failed");
+    status = parcel.ReadInt32(this->analysisType);
+    CHECK_AND_RETURN_RET_LOG(status, status, "Read analysisType failed");
+    status = parcel.ReadString(this->language);
+    CHECK_AND_RETURN_RET_LOG(status, status, "Read language failed");
+    return parcel.ReadBool(this->analysisTotal);
+}
+
+bool GetAssetAnalysisDataReqBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = parcel.WriteInt32(this->fileId);
+    CHECK_AND_RETURN_RET_LOG(status, status, "Write fileId failed");
+    status = parcel.WriteInt32(this->analysisType);
+    CHECK_AND_RETURN_RET_LOG(status, status, "Write analysisType failed");
+    status = parcel.WriteString(this->language);
+    CHECK_AND_RETURN_RET_LOG(status, status, "Write language failed");
+    return parcel.WriteBool(this->analysisTotal);
+}
+
+bool GetAssetAnalysisDataRspBody::Unmarshalling(MessageParcel &parcel)
+{
+    this->resultSet = DataShare::DataShareResultSet::Unmarshal(parcel);
+    CHECK_AND_RETURN_RET_LOG(this->resultSet != nullptr, false, "resultSet nullptr");
+    return true;
+}
+
+bool GetAssetAnalysisDataRspBody::Marshalling(MessageParcel &parcel) const
+{
+    CHECK_AND_RETURN_RET_LOG(this->resultSet != nullptr, false, "resultSet nullptr");
+    return DataShare::DataShareResultSet::Marshal(this->resultSet, parcel);
+}
+} // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/src/vo/get_assets_vo.cpp b/services/media_assets_manager/src/vo/get_assets_vo.cpp
new file mode 100644
index 0000000000..98ee8cff56
--- /dev/null
+++ b/services/media_assets_manager/src/vo/get_assets_vo.cpp
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "get_assets_vo.h"
+
+#include "itypes_util.h"
+#include "media_log.h"
+
+namespace OHOS::Media {
+
+bool GetAssetsReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = DataShare::DataSharePredicates::Unmarshal(predicates, parcel);
+
+    CHECK_AND_RETURN_RET_LOG(status, false, "predicates Unmarshal failed");
+
+    return ITypesUtil::Unmarshal(parcel, columns, burstKey);
+}
+
+bool GetAssetsReqBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = DataShare::DataSharePredicates::Marshal(predicates, parcel);
+
+    CHECK_AND_RETURN_RET_LOG(status, false, "predicates Marshal failed");
+
+    return ITypesUtil::Marshal(parcel, columns, burstKey);
+}
+
+bool GetAssetsRespBody::Unmarshalling(MessageParcel &parcel)
+{
+    resultSet = DataShare::DataShareResultSet::Unmarshal(parcel);
+    CHECK_AND_RETURN_RET_LOG(resultSet != nullptr, false, "resultSet Unmarshal failed");
+    return true;
+}
+
+bool GetAssetsRespBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = resultSet == nullptr || !DataShare::DataShareResultSet::Marshal(resultSet, parcel);
+    CHECK_AND_RETURN_RET_LOG(!status, false, "resultSet Marshal failed");
+    return true;
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/src/vo/get_cloud_enhancement_pair_vo.cpp b/services/media_assets_manager/src/vo/get_cloud_enhancement_pair_vo.cpp
new file mode 100644
index 0000000000..0183be1a1d
--- /dev/null
+++ b/services/media_assets_manager/src/vo/get_cloud_enhancement_pair_vo.cpp
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaGetCloudEnhancementPairVo"
+
+#include "get_cloud_enhancement_pair_vo.h"
+
+#include <sstream>
+
+#include "media_log.h"
+#include "data_ability_predicates.h"
+
+namespace OHOS::Media {
+using namespace std;
+bool GetCloudEnhancementPairReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = parcel.ReadString(this->photoUri);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+bool GetCloudEnhancementPairReqBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = parcel.WriteString(this->photoUri);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+string GetCloudEnhancementPairReqBody::ToString() const
+{
+    std::stringstream ss;
+    ss << "{"
+       << "\"photoUri\": \"" << photoUri
+       << "}";
+    return ss.str();
+}
+
+bool GetCloudEnhancementPairRespBody::Unmarshalling(MessageParcel &parcel)
+{
+    this->resultSet = DataShare::DataShareResultSet::Unmarshal(parcel);
+    CHECK_AND_RETURN_RET_LOG(this->resultSet != nullptr, false, "resultSet is nullptr");
+    return true;
+}
+
+bool GetCloudEnhancementPairRespBody::Marshalling(MessageParcel &parcel) const
+{
+    bool cond = this->resultSet == nullptr || !DataShare::DataShareResultSet::Marshal(this->resultSet, parcel);
+    CHECK_AND_RETURN_RET_LOG(!cond, false, "marshalling failed");
+    return true;
+}
+} // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/src/vo/get_cloudmedia_asset_status_vo.cpp b/services/media_assets_manager/src/vo/get_cloudmedia_asset_status_vo.cpp
new file mode 100644
index 0000000000..986f8d3513
--- /dev/null
+++ b/services/media_assets_manager/src/vo/get_cloudmedia_asset_status_vo.cpp
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "get_cloudmedia_asset_status_vo.h"
+
+#include <sstream>
+
+#include "media_log.h"
+
+namespace OHOS::Media {
+using namespace std;
+bool GetCloudMediaAssetStatusReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    return parcel.ReadString(this->status);
+}
+
+bool GetCloudMediaAssetStatusReqBody::Marshalling(MessageParcel &parcel) const
+{
+    return parcel.WriteString(this->status);
+}
+
+string GetCloudMediaAssetStatusReqBody::ToString() const
+{
+    std::stringstream ss;
+    ss << "{"
+        << "\"status\": \"" << this->status << "\""
+        << "}";
+    return ss.str();
+}
+} // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/src/vo/get_edit_data_vo.cpp b/services/media_assets_manager/src/vo/get_edit_data_vo.cpp
new file mode 100644
index 0000000000..e0b4a8d773
--- /dev/null
+++ b/services/media_assets_manager/src/vo/get_edit_data_vo.cpp
@@ -0,0 +1,75 @@
+ /*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "get_edit_data_vo.h"
+
+#include <sstream>
+#include "media_log.h"
+#include "itypes_util.h"
+
+namespace OHOS::Media {
+
+bool GetEditDataReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    if (!DataShare::DataSharePredicates::Unmarshal(this->predicates, parcel)) {
+        return false;
+    }
+    return true;
+}
+
+bool GetEditDataReqBody::Marshalling(MessageParcel &parcel) const
+{
+    if (!DataShare::DataSharePredicates::Marshal(this->predicates, parcel)) {
+        return false;
+    }
+    return true;
+}
+
+
+std::string GetEditDataReqBody::ToString() const
+{
+    std::stringstream ss;
+    // todo: add the content of GetAssetsReqBody
+    return ss.str();
+}
+
+bool GetEditDataRspBody::Unmarshalling(MessageParcel &parcel)
+{
+    this->resultSet = DataShare::DataShareResultSet::Unmarshal(parcel);
+    if (this->resultSet == nullptr) {
+        MEDIA_ERR_LOG("QueueEditDataRspBody ReadFromParcel failed");
+        return false;
+    }
+    MEDIA_INFO_LOG("QueueEditDataRspBody ReadFromParcel success");
+    return true;
+}
+
+bool GetEditDataRspBody::Marshalling(MessageParcel &parcel) const
+{
+    if (this->resultSet == nullptr || !DataShare::DataShareResultSet::Marshal(this->resultSet, parcel)) {
+        MEDIA_ERR_LOG("QueueEditDataRspBody Marshalling failed");
+        return false;
+    }
+    MEDIA_INFO_LOG("QueueEditDataRspBody Marshalling success");
+    return true;
+}
+
+std::string GetEditDataRspBody::ToString() const
+{
+    std::stringstream ss;
+    // todo: add the content of GetAssetsRespBody
+    return ss.str();
+}
+};
\ No newline at end of file
diff --git a/services/media_assets_manager/src/vo/get_index_construct_progress_vo.cpp b/services/media_assets_manager/src/vo/get_index_construct_progress_vo.cpp
new file mode 100644
index 0000000000..6df0ec04ee
--- /dev/null
+++ b/services/media_assets_manager/src/vo/get_index_construct_progress_vo.cpp
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "get_index_construct_progress_vo.h"
+
+#include "itypes_util.h"
+
+namespace OHOS::Media {
+
+bool GetIndexConstructProgressRespBody::Unmarshalling(MessageParcel &parcel)
+{
+    return ITypesUtil::Unmarshal(parcel, indexProgress);
+}
+
+bool GetIndexConstructProgressRespBody::Marshalling(MessageParcel &parcel) const
+{
+    return ITypesUtil::Marshal(parcel, indexProgress);
+}
+}  // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/src/vo/is_edited_vo.cpp b/services/media_assets_manager/src/vo/is_edited_vo.cpp
new file mode 100644
index 0000000000..a5b0c66f62
--- /dev/null
+++ b/services/media_assets_manager/src/vo/is_edited_vo.cpp
@@ -0,0 +1,65 @@
+ /*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "is_edited_vo.h"
+
+#include <sstream>
+#include "media_log.h"
+#include "itypes_util.h"
+
+namespace OHOS::Media {
+
+bool IsEditedReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = parcel.ReadInt32(this->fileId);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+bool IsEditedReqBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = parcel.WriteInt32(this->fileId);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+bool IsEditedRspBody::Unmarshalling(MessageParcel &parcel)
+{
+    this->resultSet = DataShare::DataShareResultSet::Unmarshal(parcel);
+    if (this->resultSet == nullptr) {
+        MEDIA_ERR_LOG("QueueEditDataRspBody ReadFromParcel failed");
+        return false;
+    }
+    MEDIA_INFO_LOG("QueueEditDataRspBody ReadFromParcel success");
+    return true;
+}
+
+bool IsEditedRspBody::Marshalling(MessageParcel &parcel) const
+{
+    if (this->resultSet == nullptr || !DataShare::DataShareResultSet::Marshal(this->resultSet, parcel)) {
+        MEDIA_ERR_LOG("QueueEditDataRspBody Marshalling failed");
+        return false;
+    }
+    MEDIA_INFO_LOG("QueueEditDataRspBody Marshalling success");
+    return true;
+}
+
+std::string IsEditedRspBody::ToString() const
+{
+    std::stringstream ss;
+    // todo: add the content of GetAssetsRespBody
+    return ss.str();
+}
+};
\ No newline at end of file
diff --git a/services/media_assets_manager/src/vo/query_cloud_enhancement_task_state_vo.cpp b/services/media_assets_manager/src/vo/query_cloud_enhancement_task_state_vo.cpp
new file mode 100644
index 0000000000..08785625f9
--- /dev/null
+++ b/services/media_assets_manager/src/vo/query_cloud_enhancement_task_state_vo.cpp
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaQueryCloudEnhancementTaskStateVo"
+
+#include "query_cloud_enhancement_task_state_vo.h"
+
+#include <sstream>
+
+#include "media_itypes_utils.h"
+#include "media_log.h"
+
+namespace OHOS::Media {
+using namespace std;
+bool QueryCloudEnhancementTaskStateReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = parcel.ReadString(this->photoUri);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+bool QueryCloudEnhancementTaskStateReqBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = parcel.WriteString(this->photoUri);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+string QueryCloudEnhancementTaskStateReqBody::ToString() const
+{
+    std::stringstream ss;
+    ss << "{"
+       << "\"photoUri\": \"" << photoUri
+       << "}";
+    return ss.str();
+}
+
+bool QueryCloudEnhancementTaskStateRespBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = parcel.ReadInt32(this->fileId);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.ReadString(this->photoId);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.ReadInt32(this->ceAvailable);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.ReadInt32(this->CEErrorCode);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+bool QueryCloudEnhancementTaskStateRespBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = parcel.WriteInt32(this->fileId);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.WriteString(this->photoId);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.WriteInt32(this->ceAvailable);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.WriteInt32(this->CEErrorCode);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+string QueryCloudEnhancementTaskStateRespBody::ToString() const
+{
+    std::stringstream ss;
+    ss << "{"
+        << "\"fileId\": \"" << to_string(this->fileId) << "\""
+        << ",\"photoId\": \"" << this->photoId << "\""
+        << ",\"ceAvailable\": \"" << to_string(this->ceAvailable) << "\""
+        << ",\"CEErrorCode\": \"" << to_string(this->CEErrorCode) << "\""
+        << "}";
+    return ss.str();
+}
+} // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/src/vo/query_photo_vo.cpp b/services/media_assets_manager/src/vo/query_photo_vo.cpp
new file mode 100644
index 0000000000..010019c3c3
--- /dev/null
+++ b/services/media_assets_manager/src/vo/query_photo_vo.cpp
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "query_photo_vo.h"
+#include <sstream>
+#include "media_log.h"
+
+namespace OHOS::Media {
+bool QueryPhotoReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    return parcel.ReadString(this->fileId);
+}
+bool QueryPhotoReqBody::Marshalling(MessageParcel &parcel) const
+{
+    return parcel.WriteString(this->fileId);
+}
+
+bool QueryPhotoRspBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = parcel.ReadString(this->photoId);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.ReadInt32(this->photoQuality);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+bool QueryPhotoRspBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = parcel.WriteString(this->photoId);
+    CHECK_AND_RETURN_RET(status, status);
+    status = parcel.WriteInt32(this->photoQuality);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+} // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/src/vo/request_content_vo.cpp b/services/media_assets_manager/src/vo/request_content_vo.cpp
new file mode 100755
index 0000000000..1fb288fddd
--- /dev/null
+++ b/services/media_assets_manager/src/vo/request_content_vo.cpp
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define MLOG_TAG "MediaRequestContentVo"
+
+#include "request_content_vo.h"
+
+#include <sstream>
+
+#include "media_itypes_utils.h"
+#include "media_log.h"
+
+namespace OHOS::Media {
+using namespace std;
+bool RequestContentReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = parcel.ReadString(this->mediaId);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+bool RequestContentReqBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = parcel.WriteString(this->mediaId);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+bool RequestContentRespBody::Unmarshalling(MessageParcel &parcel)
+{
+    bool status = parcel.ReadInt32(this->position);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+
+bool RequestContentRespBody::Marshalling(MessageParcel &parcel) const
+{
+    bool status = parcel.WriteInt32(this->position);
+    CHECK_AND_RETURN_RET(status, status);
+    return true;
+}
+} // namespace OHOS::Media
\ No newline at end of file
diff --git a/services/media_assets_manager/src/vo/request_edit_data_vo.cpp b/services/media_assets_manager/src/vo/request_edit_data_vo.cpp
new file mode 100644
index 0000000000..8ca56705a0
--- /dev/null
+++ b/services/media_assets_manager/src/vo/request_edit_data_vo.cpp
@@ -0,0 +1,74 @@
+ /*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "request_edit_data_vo.h"
+#include <sstream>
+#include "media_log.h"
+#include "itypes_util.h"
+
+namespace OHOS::Media {
+
+bool RequestEditDataReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    if (!DataShare::DataSharePredicates::Unmarshal(this->predicates, parcel)) {
+        return false;
+    }
+    return true;
+}
+
+bool RequestEditDataReqBody::Marshalling(MessageParcel &parcel) const
+{
+    if (!DataShare::DataSharePredicates::Marshal(this->predicates, parcel)) {
+        return false;
+    }
+    return true;
+}
+
+
+std::string RequestEditDataReqBody::ToString() const
+{
+    std::stringstream ss;
+    // todo: add the content of GetAssetsReqBody
+    return ss.str();
+}
+
+bool RequestEditDataRspBody::Unmarshalling(MessageParcel &parcel)
+{
+    this->resultSet = DataShare::DataShareResultSet::Unmarshal(parcel);
+    if (this->resultSet == nullptr) {
+        MEDIA_ERR_LOG("QueueEditDataRspBody ReadFromParcel failed");
+        return false;
+    }
+    MEDIA_INFO_LOG("QueueEditDataRspBody ReadFromParcel success");
+    return true;
+}
+
+bool RequestEditDataRspBody::Marshalling(MessageParcel &parcel) const
+{
+    if (this->resultSet == nullptr || !DataShare::DataShareResultSet::Marshal(this->resultSet, parcel)) {
+        MEDIA_ERR_LOG("QueueEditDataRspBody Marshalling failed");
+        return false;
+    }
+    MEDIA_INFO_LOG("QueueEditDataRspBody Marshalling success");
+    return true;
+}
+
+std::string RequestEditDataRspBody::ToString() const
+{
+    std::stringstream ss;
+    // todo: add the content of GetAssetsRespBody
+    return ss.str();
+}
+};
\ No newline at end of file
diff --git a/services/media_assets_manager/src/vo/start_asset_analysis_vo.cpp b/services/media_assets_manager/src/vo/start_asset_analysis_vo.cpp
new file mode 100644
index 0000000000..e57881d602
--- /dev/null
+++ b/services/media_assets_manager/src/vo/start_asset_analysis_vo.cpp
@@ -0,0 +1,75 @@
+ /*
+ * Copyright (C) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "start_asset_analysis_vo.h"
+
+#include <sstream>
+#include "media_log.h"
+#include "itypes_util.h"
+
+namespace OHOS::Media {
+
+bool StartAssetAnalysisReqBody::Unmarshalling(MessageParcel &parcel)
+{
+    if (!DataShare::DataSharePredicates::Unmarshal(this->predicates, parcel)) {
+        return false;
+    }
+    return true;
+}
+
+bool StartAssetAnalysisReqBody::Marshalling(MessageParcel &parcel) const
+{
+    if (!DataShare::DataSharePredicates::Marshal(this->predicates, parcel)) {
+        return false;
+    }
+    return true;
+}
+
+
+std::string StartAssetAnalysisReqBody::ToString() const
+{
+    std::stringstream ss;
+    // todo: add the content of GetAssetsReqBody
+    return ss.str();
+}
+
+bool StartAssetAnalysisRspBody::Unmarshalling(MessageParcel &parcel)
+{
+    this->resultSet = DataShare::DataShareResultSet::Unmarshal(parcel);
+    if (this->resultSet == nullptr) {
+        MEDIA_ERR_LOG("QueueEditDataRspBody ReadFromParcel failed");
+        return false;
+    }
+    MEDIA_INFO_LOG("QueueEditDataRspBody ReadFromParcel success");
+    return true;
+}
+
+bool StartAssetAnalysisRspBody::Marshalling(MessageParcel &parcel) const
+{
+    if (this->resultSet == nullptr || !DataShare::DataShareResultSet::Marshal(this->resultSet, parcel)) {
+        MEDIA_ERR_LOG("QueueEditDataRspBody Marshalling failed");
+        return false;
+    }
+    MEDIA_INFO_LOG("QueueEditDataRspBody Marshalling success");
+    return true;
+}
+
+std::string StartAssetAnalysisRspBody::ToString() const
+{
+    std::stringstream ss;
+    // todo: add the content of GetAssetsRespBody
+    return ss.str();
+}
+};
\ No newline at end of file
diff --git a/services/media_permission/include/media_cloud_permission_check.h b/services/media_permission/include/media_cloud_permission_check.h
new file mode 100755
index 0000000000..250a1f52e5
--- /dev/null
+++ b/services/media_permission/include/media_cloud_permission_check.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef OHOS_MEDIALIBRARY_CLOUD_PERMISSION_CHECK_H
+#define OHOS_MEDIALIBRARY_CLOUD_PERMISSION_CHECK_H
+
+#include "media_permission_check.h"
+
+namespace OHOS::Media {
+class CloudReadPermissionCheck : public PermissionCheck {
+public:
+    int32_t CheckPermission(uint32_t businessCode, const PermissionHeaderReq &data) override;
+};
+
+class CloudWritePermissionCheck : public PermissionCheck {
+public:
+    int32_t CheckPermission(uint32_t businessCode, const PermissionHeaderReq &data) override;
+};
+} // namespace OHOS::Media
+#endif  // OHOS_MEDIALIBRARY_CLOUD_PERMISSION_CHECK_H
diff --git a/services/media_permission/include/media_permission_policy_type.h b/services/media_permission/include/media_permission_policy_type.h
index e16b4cdd20..2b856bb8b0 100755
--- a/services/media_permission/include/media_permission_policy_type.h
+++ b/services/media_permission/include/media_permission_policy_type.h
@@ -21,7 +21,9 @@ enum PermissionType {
     PRIVATE_PERM,
     READ_PERM,
     WRITE_PERM,
-    CLOUDFILE_SYNC
+    CLOUDFILE_SYNC,
+    CLOUD_READ,
+    CLOUD_WRITE
 };
 } // namespace OHOS::Media
 #endif  // OHOS_MEDIALIBRARY_PERMISSION_POLICY_TYPE_H
diff --git a/services/media_permission/src/media_business_code_permission_map.cpp b/services/media_permission/src/media_business_code_permission_map.cpp
index e766f0d903..f676642c8f 100755
--- a/services/media_permission/src/media_business_code_permission_map.cpp
+++ b/services/media_permission/src/media_business_code_permission_map.cpp
@@ -22,7 +22,18 @@
 using namespace std;
 namespace OHOS::Media {
 // API blacklist for deprecated read or write permission
-std::unordered_set<uint32_t> PermissionCheck::deprecatedReadPermissionSet = {};
+std::unordered_set<uint32_t> PermissionCheck::deprecatedReadPermissionSet = {
+    static_cast<uint32_t>(MediaLibraryBusinessCode::QUERY_PHOTO_STATUS),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::GET_PHOTO_INDEX),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::GET_ANALYSIS_PROCESS),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::GET_HIGHLIGHT_ALBUM_INFO),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::QUERY_CLOUD_ENHANCEMENT_TASK_STATE),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::SYNC_CLOUD_ENHANCEMENT_TASK_STATUS),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::GET_CLOUD_ENHANCEMENT_PAIR),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::GET_FACE_ID),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::QUEUE_GET_CLOUDMEDIA_ASSET_STATUS),
+};
+
 std::unordered_set<uint32_t> PermissionCheck::deprecatedWritePermissionSet = {
     static_cast<uint32_t>(MediaLibraryBusinessCode::CLONE_ASSET),
     static_cast<uint32_t>(MediaLibraryBusinessCode::COMMIT_EDITED_ASSET),
@@ -33,15 +44,14 @@ std::unordered_set<uint32_t> PermissionCheck::deprecatedWritePermissionSet = {
     static_cast<uint32_t>(MediaLibraryBusinessCode::REMOVE_GALLERY_FORM_INFO),
     static_cast<uint32_t>(MediaLibraryBusinessCode::DELETE_HIGH_LIGHT_ALBUMS),
     static_cast<uint32_t>(MediaLibraryBusinessCode::UPDATE_GALLERY_FORM_INFO),
-    static_cast<uint32_t>(MediaLibraryBusinessCode::CHANGE_REQUEST_ADD_ASSETS),
-    static_cast<uint32_t>(MediaLibraryBusinessCode::CHANGE_REQUEST_REMOVE_ASSETS),
-    static_cast<uint32_t>(MediaLibraryBusinessCode::CHANGE_REQUEST_MOVE_ASSETS),
-    static_cast<uint32_t>(MediaLibraryBusinessCode::CHANGE_REQUEST_RECOVER_ASSETS),
-    static_cast<uint32_t>(MediaLibraryBusinessCode::CHANGE_REQUEST_DELETE_ASSETS),
-    static_cast<uint32_t>(MediaLibraryBusinessCode::CHANGE_REQUEST_DISMISS_ASSETS),
-    static_cast<uint32_t>(MediaLibraryBusinessCode::CHANGE_REQUEST_MERGE_ALBUM),
-    static_cast<uint32_t>(MediaLibraryBusinessCode::CHANGE_REQUEST_PLACE_BEFORE),
     static_cast<uint32_t>(MediaLibraryBusinessCode::CHANGE_REQUEST_SET_ORDER_POSITION),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::PAH_GET_ORDER_POSITION),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::SUBMIT_CLOUD_ENHANCEMENT_TASKS),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::PRIORITIZE_CLOUD_ENHANCEMENT_TASK),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::CANCEL_CLOUD_ENHANCEMENT_TASKS),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::CANCEL_ALL_CLOUD_ENHANCEMENT_TASKS),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::SET_HIGH_LIGHT_USER_ACTION_DATA),
+    static_cast<uint32_t>(MediaLibraryBusinessCode::SET_SUBTITLE),
 };
 // API whitelist for check grant operation permission
 std::unordered_set<uint32_t> PermissionCheck::grantOperationPermissionSet = {
diff --git a/services/media_permission/src/media_cloud_permission_check.cpp b/services/media_permission/src/media_cloud_permission_check.cpp
new file mode 100755
index 0000000000..fbd6eea1bc
--- /dev/null
+++ b/services/media_permission/src/media_cloud_permission_check.cpp
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License"){return 0;}
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define MLOG_TAG "MediaPermissionCheck"
+#include <string>
+#include "media_cloud_permission_check.h"
+
+using namespace std;
+
+namespace OHOS::Media {
+const std::string CLOUD_READ_ALL_PHOTO_PERMISSION = "ohos.permission.READ_ALL_PHOTO";
+const std::string CLOUD_WRITE_ALL_PHOTO_PERMISSION = "ohos.permission.WRITE_ALL_PHOTO";
+
+int32_t CloudReadPermissionCheck::CheckPermission(uint32_t businessCode, const PermissionHeaderReq &data)
+{
+    MEDIA_INFO_LOG("CloudReadPermissionCheck enter, API code=%{public}d", businessCode);
+    CHECK_AND_RETURN_RET_LOG(PermissionUtils::CheckCallerPermission(CLOUD_READ_ALL_PHOTO_PERMISSION),
+        E_PERMISSION_DENIED, "CloudReadAllPhoto permission denied!");
+    return E_SUCCESS;
+}
+
+int32_t CloudWritePermissionCheck::CheckPermission(uint32_t businessCode, const PermissionHeaderReq &data)
+{
+    MEDIA_INFO_LOG("CloudWritePermissionCheck enter, API code=%{public}d", businessCode);
+    CHECK_AND_RETURN_RET_LOG(PermissionUtils::CheckCallerPermission(CLOUD_WRITE_ALL_PHOTO_PERMISSION),
+        E_PERMISSION_DENIED, "CloudWriteAllPhoto permission denied!");
+    return E_SUCCESS;
+}
+} // namespace OHOS::Media
diff --git a/services/media_permission/src/media_permission_check.cpp b/services/media_permission/src/media_permission_check.cpp
index cace0e61c7..c96bdcdbfa 100755
--- a/services/media_permission/src/media_permission_check.cpp
+++ b/services/media_permission/src/media_permission_check.cpp
@@ -21,6 +21,7 @@
 #include "media_read_permission_check.h"
 #include "media_write_permission_check.h"
 #include "media_cloudfile_sync_permission_check.h"
+#include "media_cloud_permission_check.h"
 #include "media_file_utils.h"
 #include "permission_common.h"
 #include "medialibrary_data_manager.h"
@@ -38,7 +39,9 @@ std::unordered_map<PermissionType, std::shared_ptr<PermissionCheck>> PermissionC
     {PRIVATE_PERM, std::make_shared<PrivatePermissionCheck>()},
     {READ_PERM, std::make_shared<ReadCompositePermCheck>()},
     {WRITE_PERM, std::make_shared<WriteCompositePermCheck>()},
-    {CLOUDFILE_SYNC, std::make_shared<CloudFileSyncPermissionCheck>()}
+    {CLOUDFILE_SYNC, std::make_shared<CloudFileSyncPermissionCheck>()},
+    {CLOUD_READ, std::make_shared<CloudReadPermissionCheck>()},
+    {CLOUD_WRITE, std::make_shared<CloudWritePermissionCheck>()}
 };
 
 static void CollectPermissionInfo(MediaLibraryCommand &cmd, const string &mode,
-- 
2.45.2.huawei.8

